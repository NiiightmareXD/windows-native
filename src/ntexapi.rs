use windows::{
    core::{GUID, PWSTR},
    Wdk::{
        Foundation::OBJECT_ATTRIBUTES,
        System::SystemServices::{KUSER_SHARED_DATA, SYSTEM_FIRMWARE_TABLE_INFORMATION},
    },
    Win32::{
        Foundation::{BOOLEAN, HANDLE, LUID, NTSTATUS, UNICODE_STRING},
        Security::{GENERIC_MAPPING, SECURITY_DESCRIPTOR},
        System::{
            Diagnostics::Etw::{
                EVENT_TRACE_FLAG_ALPC, EVENT_TRACE_FLAG_DBGPRINT, EVENT_TRACE_FLAG_DEBUG_EVENTS,
                EVENT_TRACE_FLAG_DISK_FILE_IO, EVENT_TRACE_FLAG_DISK_IO,
                EVENT_TRACE_FLAG_DISK_IO_INIT, EVENT_TRACE_FLAG_FILE_IO,
                EVENT_TRACE_FLAG_FILE_IO_INIT, EVENT_TRACE_FLAG_IMAGE_LOAD, EVENT_TRACE_FLAG_JOB,
                EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS, EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS,
                EVENT_TRACE_FLAG_NETWORK_TCPIP, EVENT_TRACE_FLAG_NO_SYSCONFIG,
                EVENT_TRACE_FLAG_PROCESS, EVENT_TRACE_FLAG_PROCESS_COUNTERS,
                EVENT_TRACE_FLAG_REGISTRY, EVENT_TRACE_FLAG_SPLIT_IO, EVENT_TRACE_FLAG_THREAD,
                EVENT_TRACE_FLAG_VAMAP, EVENT_TRACE_TYPE_ACCEPT, EVENT_TRACE_TYPE_ACKDUP,
                EVENT_TRACE_TYPE_ACKFULL, EVENT_TRACE_TYPE_ACKPART,
                EVENT_TRACE_TYPE_CONFIG_CI_INFO, EVENT_TRACE_TYPE_CONFIG_DPI,
                EVENT_TRACE_TYPE_CONFIG_IDECHANNEL, EVENT_TRACE_TYPE_CONFIG_IRQ,
                EVENT_TRACE_TYPE_CONFIG_LOGICALDISK, EVENT_TRACE_TYPE_CONFIG_MACHINEID,
                EVENT_TRACE_TYPE_CONFIG_NIC, EVENT_TRACE_TYPE_CONFIG_NUMANODE,
                EVENT_TRACE_TYPE_CONFIG_OPTICALMEDIA, EVENT_TRACE_TYPE_CONFIG_PLATFORM,
                EVENT_TRACE_TYPE_CONFIG_PNP, EVENT_TRACE_TYPE_CONFIG_POWER,
                EVENT_TRACE_TYPE_CONFIG_PROCESSORGROUP, EVENT_TRACE_TYPE_CONFIG_PROCESSORNUMBER,
                EVENT_TRACE_TYPE_CONFIG_SERVICES, EVENT_TRACE_TYPE_CONFIG_VIDEO,
                EVENT_TRACE_TYPE_CONNECT, EVENT_TRACE_TYPE_CONNFAIL, EVENT_TRACE_TYPE_COPY_ARP,
                EVENT_TRACE_TYPE_COPY_TCP, EVENT_TRACE_TYPE_DC_END, EVENT_TRACE_TYPE_DC_START,
                EVENT_TRACE_TYPE_DISCONNECT, EVENT_TRACE_TYPE_END,
                EVENT_TRACE_TYPE_FLT_POSTOP_COMPLETION, EVENT_TRACE_TYPE_FLT_POSTOP_FAILURE,
                EVENT_TRACE_TYPE_FLT_POSTOP_INIT, EVENT_TRACE_TYPE_FLT_PREOP_COMPLETION,
                EVENT_TRACE_TYPE_FLT_PREOP_FAILURE, EVENT_TRACE_TYPE_FLT_PREOP_INIT,
                EVENT_TRACE_TYPE_INFO, EVENT_TRACE_TYPE_IO_FLUSH, EVENT_TRACE_TYPE_IO_FLUSH_INIT,
                EVENT_TRACE_TYPE_IO_READ, EVENT_TRACE_TYPE_IO_READ_INIT,
                EVENT_TRACE_TYPE_IO_REDIRECTED_INIT, EVENT_TRACE_TYPE_IO_WRITE,
                EVENT_TRACE_TYPE_IO_WRITE_INIT, EVENT_TRACE_TYPE_LOAD, EVENT_TRACE_TYPE_MM_AV,
                EVENT_TRACE_TYPE_MM_COW, EVENT_TRACE_TYPE_MM_DZF, EVENT_TRACE_TYPE_MM_GPF,
                EVENT_TRACE_TYPE_MM_HPF, EVENT_TRACE_TYPE_MM_TF, EVENT_TRACE_TYPE_OPTICAL_IO_FLUSH,
                EVENT_TRACE_TYPE_OPTICAL_IO_FLUSH_INIT, EVENT_TRACE_TYPE_OPTICAL_IO_READ,
                EVENT_TRACE_TYPE_OPTICAL_IO_READ_INIT, EVENT_TRACE_TYPE_OPTICAL_IO_WRITE,
                EVENT_TRACE_TYPE_OPTICAL_IO_WRITE_INIT, EVENT_TRACE_TYPE_RECEIVE,
                EVENT_TRACE_TYPE_RECONNECT, EVENT_TRACE_TYPE_REGKCBRUNDOWNBEGIN,
                EVENT_TRACE_TYPE_REGKCBRUNDOWNEND, EVENT_TRACE_TYPE_RETRANSMIT,
                EVENT_TRACE_TYPE_SEND, EVENT_TRACE_TYPE_START, EVENT_TRACE_TYPE_TERMINATE,
            },
            Kernel::{EVENT_TYPE, TIMER_TYPE, WNF_STATE_NAME},
            SystemInformation::{FIRMWARE_TYPE, GROUP_AFFINITY},
            SystemServices::IMAGE_EXPORT_DIRECTORY,
            WindowsProgramming::CLIENT_ID,
        },
    },
};

use crate::{
    bitfield::{BitfieldUnit, UnionField},
    ntioapi::{BUS_DATA_TYPE, FILE_IO_COMPLETION_INFORMATION, INTERFACE_TYPE},
    ntkeapi::{KPROFILE_SOURCE, KTHREAD_STATE, KWAIT_REASON},
    ntldr::RTL_PROCESS_MODULE_INFORMATION_EX,
    ntlpcapi::PORT_MESSAGE,
    ntpebteb::TEB,
    ntrtl::{RTL_BITMAP, RTL_FEATURE_CONFIGURATION},
    phnt_ntdef::TRACEHANDLE,
};

pub const EFI_VARIABLE_NON_VOLATILE: u32 = 1;
pub const EFI_VARIABLE_BOOTSERVICE_ACCESS: u32 = 2;
pub const EFI_VARIABLE_RUNTIME_ACCESS: u32 = 4;
pub const EFI_VARIABLE_HARDWARE_ERROR_RECORD: u32 = 8;
pub const EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS: u32 = 16;
pub const EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS: u32 = 32;
pub const EFI_VARIABLE_APPEND_WRITE: u32 = 64;
pub const EFI_VARIABLE_ENHANCED_AUTHENTICATED_ACCESS: u32 = 128;
pub const EVENT_QUERY_STATE: u32 = 1;
pub const EVENT_MODIFY_STATE: u32 = 2;
pub const EVENT_ALL_ACCESS: u32 = 2031619;
pub const MUTANT_QUERY_STATE: u32 = 1;
pub const MUTANT_ALL_ACCESS: u32 = 2031617;
pub const EVENT_PAIR_ALL_ACCESS: u32 = 2031616;
pub const SEMAPHORE_QUERY_STATE: u32 = 1;
pub const SEMAPHORE_MODIFY_STATE: u32 = 2;
pub const SEMAPHORE_ALL_ACCESS: u32 = 2031619;
pub const PROFILE_CONTROL: u32 = 1;
pub const PROFILE_ALL_ACCESS: u32 = 983041;
pub const KEYEDEVENT_WAIT: u32 = 1;
pub const KEYEDEVENT_WAKE: u32 = 2;
pub const KEYEDEVENT_ALL_ACCESS: u32 = 983043;
pub const WORKER_FACTORY_RELEASE_WORKER: u32 = 1;
pub const WORKER_FACTORY_WAIT: u32 = 2;
pub const WORKER_FACTORY_SET_INFORMATION: u32 = 4;
pub const WORKER_FACTORY_QUERY_INFORMATION: u32 = 8;
pub const WORKER_FACTORY_READY_WORKER: u32 = 16;
pub const WORKER_FACTORY_SHUTDOWN: u32 = 32;
pub const WORKER_FACTORY_ALL_ACCESS: u32 = 983103;
pub const MM_WORKING_SET_MAX_HARD_ENABLE: u32 = 1;
pub const MM_WORKING_SET_MAX_HARD_DISABLE: u32 = 2;
pub const MM_WORKING_SET_MIN_HARD_ENABLE: u32 = 4;
pub const MM_WORKING_SET_MIN_HARD_DISABLE: u32 = 8;
pub const EVENT_TRACE_FLAG_EXT_ITEMS: u32 = 2164195328;
pub const EVENT_TRACE_FLAG_EXT_LEN_NEW_STRUCT: u32 = 255;
pub const ETW_MINIMUM_CACHED_STACK_LENGTH: u32 = 4;
pub const ETW_SW_ARRAY_SIZE: u32 = 256;
pub const ETW_STACK_SW_ARRAY_SIZE: u32 = 192;
pub const ETW_MAX_STACKWALK_FILTER: u32 = 256;
pub const ETW_MAX_TAG_FILTER: u32 = 4;
pub const ETW_MAX_POOLTAG_FILTER: u32 = 4;
pub const ETW_EXT_ENABLE_FLAGS: u32 = 1;
pub const ETW_EXT_PIDS: u32 = 2;
pub const ETW_EXT_STACKWALK_FILTER: u32 = 3;
pub const ETW_EXT_POOLTAG_FILTER: u32 = 4;
pub const ETW_EXT_STACK_CACHING: u32 = 5;
pub const TRACE_HEADER_EVENT_TRACE: u32 = 1073741824;
pub const TRACE_HEADER_ENUM_MASK: u32 = 16711680;
pub const PERF_MASK_INDEX: u32 = 3758096384;
pub const PERF_MASK_GROUP: i64 = -3758096385;
pub const PERF_NUM_MASKS: u32 = 8;
pub const PERF_MEMORY: u32 = 536870913;
pub const PERF_PROFILE: u32 = 536870914;
pub const PERF_CONTEXT_SWITCH: u32 = 536870916;
pub const PERF_FOOTPRINT: u32 = 536870920;
pub const PERF_DRIVERS: u32 = 536870928;
pub const PERF_REFSET: u32 = 536870944;
pub const PERF_POOL: u32 = 536870976;
pub const PERF_POOLTRACE: u32 = 536870977;
pub const PERF_DPC: u32 = 536871040;
pub const PERF_COMPACT_CSWITCH: u32 = 536871168;
pub const PERF_DISPATCHER: u32 = 536871424;
pub const PERF_PMC_PROFILE: u32 = 536871936;
pub const PERF_PROFILING: u32 = 536871938;
pub const PERF_PROCESS_INSWAP: u32 = 536872960;
pub const PERF_AFFINITY: u32 = 536875008;
pub const PERF_PRIORITY: u32 = 536879104;
pub const PERF_INTERRUPT: u32 = 536887296;
pub const PERF_VIRTUAL_ALLOC: u32 = 536903680;
pub const PERF_SPINLOCK: u32 = 536936448;
pub const PERF_SYNC_OBJECTS: u32 = 537001984;
pub const PERF_DPC_QUEUE: u32 = 537133056;
pub const PERF_MEMINFO: u32 = 537395200;
pub const PERF_CONTMEM_GEN: u32 = 537919488;
pub const PERF_SPINLOCK_CNTRS: u32 = 538968064;
pub const PERF_SPININSTR: u32 = 539033600;
pub const PERF_SESSION: u32 = 541065216;
pub const PERF_PFSECTION: u32 = 541065216;
pub const PERF_MEMINFO_WS: u32 = 545259520;
pub const PERF_KERNEL_QUEUE: u32 = 553648128;
pub const PERF_INTERRUPT_STEER: u32 = 570425344;
pub const PERF_SHOULD_YIELD: u32 = 603979776;
pub const PERF_WS: u32 = 671088640;
pub const PERF_ANTI_STARVATION: u32 = 1073741825;
pub const PERF_PROCESS_FREEZE: u32 = 1073741826;
pub const PERF_PFN_LIST: u32 = 1073741828;
pub const PERF_WS_DETAIL: u32 = 1073741832;
pub const PERF_WS_ENTRY: u32 = 1073741840;
pub const PERF_HEAP: u32 = 1073741856;
pub const PERF_SYSCALL: u32 = 1073741888;
pub const PERF_UMS: u32 = 1073741952;
pub const PERF_BACKTRACE: u32 = 1073742080;
pub const PERF_VULCAN: u32 = 1073742336;
pub const PERF_OBJECTS: u32 = 1073742848;
pub const PERF_EVENTS: u32 = 1073743872;
pub const PERF_FULLTRACE: u32 = 1073745920;
pub const PERF_DFSS: u32 = 1073750016;
pub const PERF_PREFETCH: u32 = 1073758208;
pub const PERF_PROCESSOR_IDLE: u32 = 1073774592;
pub const PERF_CPU_CONFIG: u32 = 1073807360;
pub const PERF_TIMER: u32 = 1073872896;
pub const PERF_CLOCK_INTERRUPT: u32 = 1074003968;
pub const PERF_LOAD_BALANCER: u32 = 1074266112;
pub const PERF_CLOCK_TIMER: u32 = 1074790400;
pub const PERF_IDLE_SELECTION: u32 = 1075838976;
pub const PERF_IPI: u32 = 1077936128;
pub const PERF_IO_TIMER: u32 = 1082130432;
pub const PERF_REG_HIVE: u32 = 1090519040;
pub const PERF_REG_NOTIF: u32 = 1107296256;
pub const PERF_PPM_EXIT_LATENCY: u32 = 1140850688;
pub const PERF_WORKER_THREAD: u32 = 1207959552;
pub const PERF_OPTICAL_IO: u32 = 2147483649;
pub const PERF_OPTICAL_IO_INIT: u32 = 2147483650;
pub const PERF_DLL_INFO: u32 = 2147483656;
pub const PERF_DLL_FLUSH_WS: u32 = 2147483664;
pub const PERF_OB_HANDLE: u32 = 2147483712;
pub const PERF_OB_OBJECT: u32 = 2147483776;
pub const PERF_WAKE_DROP: u32 = 2147484160;
pub const PERF_WAKE_EVENT: u32 = 2147484672;
pub const PERF_DEBUGGER: u32 = 2147485696;
pub const PERF_PROC_ATTACH: u32 = 2147487744;
pub const PERF_WAKE_COUNTER: u32 = 2147491840;
pub const PERF_POWER: u32 = 2147516416;
pub const PERF_SOFT_TRIM: u32 = 2147549184;
pub const PERF_CC: u32 = 2147614720;
pub const PERF_FLT_IO_INIT: u32 = 2148007936;
pub const PERF_FLT_IO: u32 = 2148532224;
pub const PERF_FLT_FASTIO: u32 = 2149580800;
pub const PERF_FLT_IO_FAILURE: u32 = 2151677952;
pub const PERF_HV_PROFILE: u32 = 2155872256;
pub const PERF_WDF_DPC: u32 = 2164260864;
pub const PERF_WDF_INTERRUPT: u32 = 2181038080;
pub const PERF_CACHE_FLUSH: u32 = 2214592512;
pub const PERF_HIBER_RUNDOWN: u32 = 2684354561;
pub const PERF_SYSCFG_SYSTEM: u32 = 3221225473;
pub const PERF_SYSCFG_GRAPHICS: u32 = 3221225474;
pub const PERF_SYSCFG_STORAGE: u32 = 3221225476;
pub const PERF_SYSCFG_NETWORK: u32 = 3221225480;
pub const PERF_SYSCFG_SERVICES: u32 = 3221225488;
pub const PERF_SYSCFG_PNP: u32 = 3221225504;
pub const PERF_SYSCFG_OPTICAL: u32 = 3221225536;
pub const PERF_SYSCFG_ALL: u32 = 3758096383;
pub const PERF_CLUSTER_OFF: u32 = 3758096385;
pub const PERF_MEMORY_CONTROL: u32 = 3758096386;
pub const EVENT_TRACE_GROUP_HEADER: u32 = 0;
pub const EVENT_TRACE_GROUP_IO: u32 = 256;
pub const EVENT_TRACE_GROUP_MEMORY: u32 = 512;
pub const EVENT_TRACE_GROUP_PROCESS: u32 = 768;
pub const EVENT_TRACE_GROUP_FILE: u32 = 1024;
pub const EVENT_TRACE_GROUP_THREAD: u32 = 1280;
pub const EVENT_TRACE_GROUP_TCPIP: u32 = 1536;
pub const EVENT_TRACE_GROUP_JOB: u32 = 1792;
pub const EVENT_TRACE_GROUP_UDPIP: u32 = 2048;
pub const WMI_LOG_TYPE_REG_RUNDOWNBEGIN: u32 =
    EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGKCBRUNDOWNBEGIN;
pub const WMI_LOG_TYPE_REG_RUNDOWNEND: u32 =
    EVENT_TRACE_GROUP_REGISTRY | EVENT_TRACE_TYPE_REGKCBRUNDOWNEND;
pub const EVENT_TRACE_GROUP_REGISTRY: u32 = 2304;
pub const EVENT_TRACE_GROUP_DBGPRINT: u32 = 2560;
pub const EVENT_TRACE_GROUP_CONFIG: u32 = 2816;
pub const EVENT_TRACE_GROUP_SPARE1: u32 = 3072;
pub const EVENT_TRACE_GROUP_WNF: u32 = 3328;
pub const EVENT_TRACE_GROUP_POOL: u32 = 3584;
pub const EVENT_TRACE_GROUP_PERFINFO: u32 = 3840;
pub const EVENT_TRACE_GROUP_HEAP: u32 = 4096;
pub const EVENT_TRACE_GROUP_OBJECT: u32 = 4352;
pub const EVENT_TRACE_GROUP_POWER: u32 = 4608;
pub const EVENT_TRACE_GROUP_MODBOUND: u32 = 4864;
pub const EVENT_TRACE_GROUP_IMAGE: u32 = 5120;
pub const EVENT_TRACE_GROUP_DPC: u32 = 5376;
pub const EVENT_TRACE_GROUP_CC: u32 = 5632;
pub const EVENT_TRACE_GROUP_CRITSEC: u32 = 5888;
pub const EVENT_TRACE_GROUP_STACKWALK: u32 = 6144;
pub const EVENT_TRACE_GROUP_UMS: u32 = 6400;
pub const EVENT_TRACE_GROUP_ALPC: u32 = 6656;
pub const EVENT_TRACE_GROUP_SPLITIO: u32 = 6912;
pub const EVENT_TRACE_GROUP_THREAD_POOL: u32 = 7168;
pub const EVENT_TRACE_GROUP_HYPERVISOR: u32 = 7424;
pub const EVENT_TRACE_GROUP_HYPERVISORX: u32 = 7680;
pub const WMI_LOG_TYPE_GROUP_MASKS_END: u32 = 32;
pub const WMI_LOG_TYPE_RUNDOWN_BEGIN: u32 = 48;
pub const WMI_LOG_TYPE_RUNDOWN_END: u32 = 49;
pub const WMI_LOG_TYPE_DBGID_NB10: u32 = 65;
pub const WMI_LOG_TYPE_BUILD_LAB: u32 = 66;
pub const WMI_LOG_TYPE_BINARY_PATH: u32 = 67;
pub const WMI_LOG_TYPE_HEADER: u32 = 0;
pub const WMI_LOG_TYPE_HEADER_EXTENSION: u32 = 5;
pub const WMI_LOG_TYPE_RUNDOWN_COMPLETE: u32 = 8;
pub const WMI_LOG_TYPE_DBGID_RSDS: u32 = 64;
pub const WMI_LOG_TYPE_CONFIG_CPU: u32 = 2826;
pub const WMI_LOG_TYPE_CONFIG_PHYSICALDISK: u32 = 2827;
pub const WMI_LOG_TYPE_CONFIG_LOGICALDISK: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_LOGICALDISK;
pub const WMI_LOG_TYPE_CONFIG_OPTICALMEDIA: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_OPTICALMEDIA;
pub const WMI_LOG_TYPE_CONFIG_NIC: u32 = EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_NIC;
pub const WMI_LOG_TYPE_CONFIG_VIDEO: u32 = EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_VIDEO;
pub const WMI_LOG_TYPE_CONFIG_SERVICES: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_SERVICES;
pub const WMI_LOG_TYPE_CONFIG_POWER: u32 = EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_POWER;
pub const WMI_LOG_TYPE_CONFIG_IRQ: u32 = EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_IRQ;
pub const WMI_LOG_TYPE_CONFIG_PNP: u32 = EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PNP;
pub const WMI_LOG_TYPE_CONFIG_IDECHANNEL: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_IDECHANNEL;
pub const WMI_LOG_TYPE_CONFIG_NUMANODE: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_NUMANODE;
pub const WMI_LOG_TYPE_CONFIG_PLATFORM: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PLATFORM;
pub const WMI_LOG_TYPE_CONFIG_PROCESSORGROUP: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PROCESSORGROUP;
pub const WMI_LOG_TYPE_CONFIG_PROCESSORNUMBER: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_PROCESSORNUMBER;
pub const WMI_LOG_TYPE_CONFIG_DPI: u32 = EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_DPI;
pub const WMI_LOG_TYPE_CONFIG_CODEINTEGRITY: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_CI_INFO;
pub const WMI_LOG_TYPE_CONFIG_MACHINEID: u32 =
    EVENT_TRACE_GROUP_CONFIG | EVENT_TRACE_TYPE_CONFIG_MACHINEID;
pub const PERFINFO_LOG_TYPE_FILENAME: u32 = EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_INFO;
pub const PERFINFO_LOG_TYPE_FILENAME_CREATE: u32 = 1056;
pub const PERFINFO_LOG_TYPE_FILENAME_SAME: u32 = 1057;
pub const PERFINFO_LOG_TYPE_FILENAME_NULL: u32 = 1058;
pub const PERFINFO_LOG_TYPE_FILENAME_DELETE: u32 = 1059;
pub const PERFINFO_LOG_TYPE_FILENAME_RUNDOWN: u32 = 1060;
pub const PERFINFO_LOG_TYPE_MAPFILE: u32 = 1061;
pub const PERFINFO_LOG_TYPE_UNMAPFILE: u32 = 1062;
pub const PERFINFO_LOG_TYPE_MAPFILE_DC_START: u32 = 1063;
pub const PERFINFO_LOG_TYPE_MAPFILE_DC_END: u32 = 1064;
pub const PERFINFO_LOG_TYPE_FILE_IO_CREATE: u32 = 1088;
pub const PERFINFO_LOG_TYPE_FILE_IO_CLEANUP: u32 = 1089;
pub const PERFINFO_LOG_TYPE_FILE_IO_CLOSE: u32 = 1090;
pub const PERFINFO_LOG_TYPE_FILE_IO_READ: u32 = 1091;
pub const PERFINFO_LOG_TYPE_FILE_IO_WRITE: u32 = 1092;
pub const PERFINFO_LOG_TYPE_FILE_IO_SET_INFORMATION: u32 = 1093;
pub const PERFINFO_LOG_TYPE_FILE_IO_DELETE: u32 = 1094;
pub const PERFINFO_LOG_TYPE_FILE_IO_RENAME: u32 = 1095;
pub const PERFINFO_LOG_TYPE_FILE_IO_DIRENUM: u32 = 1096;
pub const PERFINFO_LOG_TYPE_FILE_IO_FLUSH: u32 = 1097;
pub const PERFINFO_LOG_TYPE_FILE_IO_QUERY_INFORMATION: u32 = 1098;
pub const PERFINFO_LOG_TYPE_FILE_IO_FS_CONTROL: u32 = 1099;
pub const PERFINFO_LOG_TYPE_FILE_IO_OPERATION_END: u32 = 1100;
pub const PERFINFO_LOG_TYPE_FILE_IO_DIRNOTIFY: u32 = 1101;
pub const PERFINFO_LOG_TYPE_FILE_IO_CREATE_NEW: u32 = 1102;
pub const PERFINFO_LOG_TYPE_FILE_IO_DELETE_PATH: u32 = 1103;
pub const PERFINFO_LOG_TYPE_FILE_IO_RENAME_PATH: u32 = 1104;
pub const PERFINFO_LOG_TYPE_FILE_IO_SETLINK_PATH: u32 = 1105;
pub const PERFINFO_LOG_TYPE_FILE_IO_SETLINK: u32 = 1106;
pub const PERFINFO_LOG_TYPE_FLT_PREOP_INIT: u32 =
    EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_PREOP_INIT;
pub const PERFINFO_LOG_TYPE_FLT_POSTOP_INIT: u32 =
    EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_POSTOP_INIT;
pub const PERFINFO_LOG_TYPE_FLT_PREOP_COMPLETION: u32 =
    EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_PREOP_COMPLETION;
pub const PERFINFO_LOG_TYPE_FLT_POSTOP_COMPLETION: u32 =
    EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_POSTOP_COMPLETION;
pub const PERFINFO_LOG_TYPE_FLT_PREOP_FAILURE: u32 =
    EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_PREOP_FAILURE;
pub const PERFINFO_LOG_TYPE_FLT_POSTOP_FAILURE: u32 =
    EVENT_TRACE_GROUP_FILE | EVENT_TRACE_TYPE_FLT_POSTOP_FAILURE;
pub const WMI_LOG_TYPE_JOB_CREATE: u32 = 1824;
pub const WMI_LOG_TYPE_JOB_TERMINATE: u32 = 1825;
pub const WMI_LOG_TYPE_JOB_OPEN: u32 = 1826;
pub const WMI_LOG_TYPE_JOB_ASSIGN_PROCESS: u32 = 1827;
pub const WMI_LOG_TYPE_JOB_REMOVE_PROCESS: u32 = 1828;
pub const WMI_LOG_TYPE_JOB_SET: u32 = 1829;
pub const WMI_LOG_TYPE_JOB_QUERY: u32 = 1830;
pub const WMI_LOG_TYPE_JOB_SET_FAILED: u32 = 1831;
pub const WMI_LOG_TYPE_JOB_QUERY_FAILED: u32 = 1832;
pub const WMI_LOG_TYPE_JOB_SET_NOTIFICATION: u32 = 1833;
pub const WMI_LOG_TYPE_JOB_SEND_NOTIFICATION: u32 = 1834;
pub const WMI_LOG_TYPE_JOB_QUERY_VIOLATION: u32 = 1835;
pub const WMI_LOG_TYPE_JOB_SET_CPU_RATE: u32 = 1836;
pub const WMI_LOG_TYPE_JOB_SET_NET_RATE: u32 = 1837;
pub const WMI_LOG_TYPE_PROCESS_CREATE: u32 = EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_START;
pub const WMI_LOG_TYPE_PROCESS_DELETE: u32 = EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_END;
pub const WMI_LOG_TYPE_PROCESS_DC_START: u32 =
    EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_DC_START;
pub const WMI_LOG_TYPE_PROCESS_DC_END: u32 = EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_DC_END;
pub const WMI_LOG_TYPE_PROCESS_LOAD_IMAGE: u32 = EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_LOAD;
pub const WMI_LOG_TYPE_PROCESS_TERMINATE: u32 =
    EVENT_TRACE_GROUP_PROCESS | EVENT_TRACE_TYPE_TERMINATE;
pub const PERFINFO_LOG_TYPE_PROCESS_PERFCTR_END: u32 = 800;
pub const PERFINFO_LOG_TYPE_PROCESS_PERFCTR_RD: u32 = 801;
pub const PERFINFO_LOG_TYPE_INSWAPPROCESS: u32 = 803;
pub const PERFINFO_LOG_TYPE_PROCESS_FREEZE: u32 = 804;
pub const PERFINFO_LOG_TYPE_PROCESS_THAW: u32 = 805;
pub const PERFINFO_LOG_TYPE_BOOT_PHASE_START: u32 = 806;
pub const PERFINFO_LOG_TYPE_ZOMBIE_PROCESS: u32 = 807;
pub const PERFINFO_LOG_TYPE_PROCESS_SET_AFFINITY: u32 = 808;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_USER: u32 = 816;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_EXECUTION: u32 = 817;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_KERNEL: u32 = 818;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_INSTRUMENTATION: u32 = 819;
pub const PERFINFO_LOG_TYPE_CHARGE_WAKE_COUNTER_PRESERVE_PROCESS: u32 = 820;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_USER: u32 = 832;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_EXECUTION: u32 = 833;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_KERNEL: u32 = 834;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_INSTRUMENTATION: u32 = 835;
pub const PERFINFO_LOG_TYPE_RELEASE_WAKE_COUNTER_PRESERVE_PROCESS: u32 = 836;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_USER: u32 = 848;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_EXECUTION: u32 = 849;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_KERNEL: u32 = 850;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_INSTRUMENTATION: u32 = 851;
pub const PERFINFO_LOG_TYPE_WAKE_DROP_PRESERVE_PROCESS: u32 = 852;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_USER: u32 = 864;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_EXECUTION: u32 = 865;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_KERNEL: u32 = 866;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_INSTRUMENTATION: u32 = 867;
pub const PERFINFO_LOG_TYPE_WAKE_EVENT_PRESERVE_PROCESS: u32 = 868;
pub const PERFINFO_LOG_TYPE_DEBUG_EVENT: u32 = 880;
pub const WMI_LOG_TYPE_IMAGE_RELOCATION: u32 = 5152;
pub const WMI_LOG_TYPE_IMAGE_KERNEL_BASE: u32 = 5153;
pub const WMI_LOG_TYPE_IMAGE_HYPERCALL_PAGE: u32 = 5154;
pub const WMI_LOG_TYPE_IMAGE_LOAD: u32 = EVENT_TRACE_GROUP_IMAGE | EVENT_TRACE_TYPE_START;
pub const WMI_LOG_TYPE_IMAGE_UNLOAD: u32 = EVENT_TRACE_GROUP_IMAGE | EVENT_TRACE_TYPE_END;
pub const WMI_LOG_TYPE_IMAGE_DC_START: u32 = EVENT_TRACE_GROUP_IMAGE | EVENT_TRACE_TYPE_DC_START;
pub const WMI_LOG_TYPE_IMAGE_DC_END: u32 = EVENT_TRACE_GROUP_IMAGE | EVENT_TRACE_TYPE_DC_END;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_ATTEMPT: u32 = 5248;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_SUCCESS: u32 = 5249;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_FAIL: u32 = 5250;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_ACQUIRE_WAIT: u32 = 5251;
pub const PERFINFO_LOG_TYPE_LDR_PROC_INIT_DONE: u32 = 5252;
pub const PERFINFO_LOG_TYPE_LDR_CREATE_SECTION: u32 = 5253;
pub const PERFINFO_LOG_TYPE_LDR_SECTION_CREATED: u32 = 5254;
pub const PERFINFO_LOG_TYPE_LDR_MAP_VIEW: u32 = 5255;
pub const PERFINFO_LOG_TYPE_LDR_RELOCATE_IMAGE: u32 = 5264;
pub const PERFINFO_LOG_TYPE_LDR_IMAGE_RELOCATED: u32 = 5265;
pub const PERFINFO_LOG_TYPE_LDR_HANDLE_OLD_DESCRIPTORS: u32 = 5266;
pub const PERFINFO_LOG_TYPE_LDR_OLD_DESCRIPTORS_HANDLED: u32 = 5267;
pub const PERFINFO_LOG_TYPE_LDR_HANDLE_NEW_DESCRIPTORS: u32 = 5268;
pub const PERFINFO_LOG_TYPE_LDR_NEW_DESCRIPTORS_HANDLED: u32 = 5269;
pub const PERFINFO_LOG_TYPE_LDR_DLLMAIN_EXIT: u32 = 5270;
pub const PERFINFO_LOG_TYPE_LDR_FIND_DLL: u32 = 5280;
pub const PERFINFO_LOG_TYPE_LDR_VIEW_MAPPED: u32 = 5281;
pub const PERFINFO_LOG_TYPE_LDR_LOCK_RELEASE: u32 = 5282;
pub const PERFINFO_LOG_TYPE_LDR_DLLMAIN_ENTER: u32 = 5283;
pub const PERFINFO_LOG_TYPE_LDR_ERROR: u32 = 5284;
pub const PERFINFO_LOG_TYPE_LDR_VIEW_MAPPING: u32 = 5285;
pub const PERFINFO_LOG_TYPE_LDR_SNAPPING: u32 = 5286;
pub const PERFINFO_LOG_TYPE_LDR_SNAPPED: u32 = 5287;
pub const PERFINFO_LOG_TYPE_LDR_LOADING: u32 = 5288;
pub const PERFINFO_LOG_TYPE_LDR_LOADED: u32 = 5289;
pub const PERFINFO_LOG_TYPE_LDR_FOUND_KNOWN_DLL: u32 = 5290;
pub const PERFINFO_LOG_TYPE_LDR_ABNORMAL: u32 = 5291;
pub const PERFINFO_LOG_TYPE_LDR_PLACEHOLDER: u32 = 5292;
pub const PERFINFO_LOG_TYPE_LDR_RDY_TO_INIT: u32 = 5293;
pub const PERFINFO_LOG_TYPE_LDR_RDY_TO_RUN: u32 = 5294;
pub const PERFINFO_LOG_TYPE_LDR_NEW_DLL_LOAD: u32 = 5296;
pub const PERFINFO_LOG_TYPE_LDR_NEW_DLL_AS_DATA: u32 = 5297;
pub const PERFINFO_LOG_TYPE_LDR_EXTERNAL_PATH: u32 = 5312;
pub const PERFINFO_LOG_TYPE_LDR_GENERATED_PATH: u32 = 5313;
pub const PERFINFO_LOG_TYPE_LDR_APISET_RESOLVING: u32 = 5328;
pub const PERFINFO_LOG_TYPE_LDR_APISET_HOSTED: u32 = 5329;
pub const PERFINFO_LOG_TYPE_LDR_APISET_UNHOSTED: u32 = 5330;
pub const PERFINFO_LOG_TYPE_LDR_APISET_UNRESOLVED: u32 = 5331;
pub const PERFINFO_LOG_TYPE_LDR_SEARCH_SECURITY: u32 = 5332;
pub const PERFINFO_LOG_TYPE_LDR_SEARCH_PATH_SECURITY: u32 = 5333;
pub const WMI_LOG_TYPE_THREAD_CREATE: u32 = EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_START;
pub const WMI_LOG_TYPE_THREAD_DELETE: u32 = EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_END;
pub const WMI_LOG_TYPE_THREAD_DC_START: u32 = EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_DC_START;
pub const WMI_LOG_TYPE_THREAD_DC_END: u32 = EVENT_TRACE_GROUP_THREAD | EVENT_TRACE_TYPE_DC_END;
pub const PERFINFO_LOG_TYPE_CONTEXTSWAP: u32 = 1316;
pub const PERFINFO_LOG_TYPE_CONTEXTSWAP_BATCH: u32 = 1317;
pub const PERFINFO_LOG_TYPE_SPINLOCK: u32 = 1321;
pub const PERFINFO_LOG_TYPE_QUEUE: u32 = 1322;
pub const PERFINFO_LOG_TYPE_RESOURCE: u32 = 1323;
pub const PERFINFO_LOG_TYPE_PUSHLOCK: u32 = 1324;
pub const PERFINFO_LOG_TYPE_WAIT_SINGLE: u32 = 1325;
pub const PERFINFO_LOG_TYPE_WAIT_MULTIPLE: u32 = 1326;
pub const PERFINFO_LOG_TYPE_DELAY_EXECUTION: u32 = 1327;
pub const PERFINFO_LOG_TYPE_THREAD_SET_PRIORITY: u32 = 1328;
pub const PERFINFO_LOT_TYPE_THREAD_SET_BASE_PRIORITY: u32 = 1329;
pub const PERFINFO_LOG_TYPE_THREAD_SET_BASE_PRIORITY: u32 = 1329;
pub const PERFINFO_LOG_TYPE_READY_THREAD: u32 = 1330;
pub const PERFINFO_LOG_TYPE_THREAD_SET_PAGE_PRIORITY: u32 = 1331;
pub const PERFINFO_LOG_TYPE_THREAD_SET_IO_PRIORITY: u32 = 1332;
pub const PERFINFO_LOG_TYPE_THREAD_SET_AFFINITY: u32 = 1333;
pub const PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM: u32 = 1337;
pub const PERFINFO_LOG_TYPE_DFSS_START_NEW_INTERVAL: u32 = 1338;
pub const PERFINFO_LOG_TYPE_DFSS_PROCESS_IDLE_ONLY_QUEUE: u32 = 1339;
pub const PERFINFO_LOG_TYPE_ANTI_STARVATION_BOOST: u32 = 1340;
pub const PERFINFO_LOG_TYPE_THREAD_MIGRATION: u32 = 1341;
pub const PERFINFO_LOG_TYPE_KQUEUE_ENQUEUE: u32 = 1342;
pub const PERFINFO_LOG_TYPE_KQUEUE_DEQUEUE: u32 = 1343;
pub const PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_START: u32 = 1344;
pub const PERFINFO_LOG_TYPE_WORKER_THREAD_ITEM_END: u32 = 1345;
pub const PERFINFO_LOG_TYPE_AUTO_BOOST_SET_FLOOR: u32 = 1346;
pub const PERFINFO_LOG_TYPE_AUTO_BOOST_CLEAR_FLOOR: u32 = 1347;
pub const PERFINFO_LOG_TYPE_AUTO_BOOST_NO_ENTRIES: u32 = 1348;
pub const PERFINFO_LOG_TYPE_THREAD_SUBPROCESSTAG_CHANGED: u32 = 1349;
pub const WMI_LOG_TYPE_TCPIP_SEND: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_SEND;
pub const WMI_LOG_TYPE_TCPIP_RECEIVE: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_RECEIVE;
pub const WMI_LOG_TYPE_TCPIP_CONNECT: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_CONNECT;
pub const WMI_LOG_TYPE_TCPIP_DISCONNECT: u32 =
    EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_DISCONNECT;
pub const WMI_LOG_TYPE_TCPIP_RETRANSMIT: u32 =
    EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_RETRANSMIT;
pub const WMI_LOG_TYPE_TCPIP_ACCEPT: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_ACCEPT;
pub const WMI_LOG_TYPE_TCPIP_RECONNECT: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_RECONNECT;
pub const WMI_LOG_TYPE_TCPIP_FAIL: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_CONNFAIL;
pub const WMI_LOG_TYPE_TCPIP_TCPCOPY: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_COPY_TCP;
pub const WMI_LOG_TYPE_TCPIP_ARPCOPY: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_COPY_ARP;
pub const WMI_LOG_TYPE_TCPIP_FULLACK: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_ACKFULL;
pub const WMI_LOG_TYPE_TCPIP_PARTACK: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_ACKPART;
pub const WMI_LOG_TYPE_TCPIP_DUPACK: u32 = EVENT_TRACE_GROUP_TCPIP | EVENT_TRACE_TYPE_ACKDUP;
pub const WMI_LOG_TYPE_UDP_SEND: u32 = EVENT_TRACE_GROUP_UDPIP | EVENT_TRACE_TYPE_SEND;
pub const WMI_LOG_TYPE_UDP_RECEIVE: u32 = EVENT_TRACE_GROUP_UDPIP | EVENT_TRACE_TYPE_RECEIVE;
pub const WMI_LOG_TYPE_UDP_FAIL: u32 = EVENT_TRACE_GROUP_UDPIP | EVENT_TRACE_TYPE_CONNFAIL;
pub const WMI_LOG_TYPE_TCPIP_SEND_IPV6: u32 = 1562;
pub const WMI_LOG_TYPE_TCPIP_RECEIVE_IPV6: u32 = 1563;
pub const WMI_LOG_TYPE_TCPIP_CONNECT_IPV6: u32 = 1564;
pub const WMI_LOG_TYPE_TCPIP_DISCONNECT_IPV6: u32 = 1565;
pub const WMI_LOG_TYPE_TCPIP_RETRANSMIT_IPV6: u32 = 1566;
pub const WMI_LOG_TYPE_TCPIP_ACCEPT_IPV6: u32 = 1567;
pub const WMI_LOG_TYPE_TCPIP_RECONNECT_IPV6: u32 = 1568;
pub const WMI_LOG_TYPE_TCPIP_FAIL_IPV6: u32 = 1569;
pub const WMI_LOG_TYPE_TCPIP_TCPCOPY_IPV6: u32 = 1570;
pub const WMI_LOG_TYPE_TCPIP_ARPCOPY_IPV6: u32 = 1571;
pub const WMI_LOG_TYPE_TCPIP_FULLACK_IPV6: u32 = 1572;
pub const WMI_LOG_TYPE_TCPIP_PARTACK_IPV6: u32 = 1573;
pub const WMI_LOG_TYPE_TCPIP_DUPACK_IPV6: u32 = 1574;
pub const WMI_LOG_TYPE_UDP_SEND_IPV6: u32 = 2074;
pub const WMI_LOG_TYPE_UDP_RECEIVE_IPV6: u32 = 2075;
pub const WMI_LOG_TYPE_IO_READ: u32 = EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_READ;
pub const WMI_LOG_TYPE_IO_WRITE: u32 = EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_WRITE;
pub const WMI_LOG_TYPE_IO_READ_INIT: u32 = EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_READ_INIT;
pub const WMI_LOG_TYPE_IO_WRITE_INIT: u32 = EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_WRITE_INIT;
pub const WMI_LOG_TYPE_IO_FLUSH: u32 = EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_FLUSH;
pub const WMI_LOG_TYPE_IO_FLUSH_INIT: u32 = EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_FLUSH_INIT;
pub const WMI_LOG_TYPE_IO_REDIRECTED_INIT: u32 =
    EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_IO_REDIRECTED_INIT;
pub const PERFINFO_LOG_TYPE_DRIVER_INIT: u32 = 288;
pub const PERFINFO_LOG_TYPE_DRIVER_INIT_COMPLETE: u32 = 289;
pub const PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_CALL: u32 = 290;
pub const PERFINFO_LOG_TYPE_DRIVER_MAJORFUNCTION_RETURN: u32 = 291;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_CALL: u32 = 292;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETIONROUTINE_RETURN: u32 = 293;
pub const PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_CALL: u32 = 294;
pub const PERFINFO_LOG_TYPE_DRIVER_ADD_DEVICE_RETURN: u32 = 295;
pub const PERFINFO_LOG_TYPE_DRIVER_STARTIO_CALL: u32 = 296;
pub const PERFINFO_LOG_TYPE_DRIVER_STARTIO_RETURN: u32 = 297;
pub const PERFINFO_LOG_TYPE_PREFETCH_ACTION: u32 = 304;
pub const PERFINFO_LOG_TYPE_PREFETCH_REQUEST: u32 = 305;
pub const PERFINFO_LOG_TYPE_PREFETCH_READLIST: u32 = 306;
pub const PERFINFO_LOG_TYPE_PREFETCH_READ: u32 = 307;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST: u32 = 308;
pub const PERFINFO_LOG_TYPE_DRIVER_COMPLETE_REQUEST_RETURN: u32 = 309;
pub const PERFINFO_LOG_TYPE_BOOT_PREFETCH_INFORMATION: u32 = 310;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_READ: u32 =
    EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_READ;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_WRITE: u32 =
    EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_WRITE;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_FLUSH: u32 =
    EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_FLUSH;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_READ_INIT: u32 =
    EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_READ_INIT;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_WRITE_INIT: u32 =
    EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_WRITE_INIT;
pub const PERFINFO_LOG_TYPE_OPTICAL_IO_FLUSH_INIT: u32 =
    EVENT_TRACE_GROUP_IO | EVENT_TRACE_TYPE_OPTICAL_IO_FLUSH_INIT;
pub const WMI_LOG_TYPE_PAGE_FAULT_TRANSITION: u32 =
    EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_TF;
pub const WMI_LOG_TYPE_PAGE_FAULT_DEMAND_ZERO: u32 =
    EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_DZF;
pub const WMI_LOG_TYPE_PAGE_FAULT_COPY_ON_WRITE: u32 =
    EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_COW;
pub const WMI_LOG_TYPE_PAGE_FAULT_GUARD_PAGE: u32 =
    EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_GPF;
pub const WMI_LOG_TYPE_PAGE_FAULT_HARD_PAGE_FAULT: u32 =
    EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_HPF;
pub const WMI_LOG_TYPE_PAGE_FAULT_ACCESS_VIOLATION: u32 =
    EVENT_TRACE_GROUP_MEMORY | EVENT_TRACE_TYPE_MM_AV;
pub const PERFINFO_LOG_TYPE_HARDFAULT: u32 = 544;
pub const PERFINFO_LOG_TYPE_REMOVEPAGEBYCOLOR: u32 = 545;
pub const PERFINFO_LOG_TYPE_REMOVEPAGEFROMLIST: u32 = 546;
pub const PERFINFO_LOG_TYPE_PAGEINMEMORY: u32 = 547;
pub const PERFINFO_LOG_TYPE_INSERTINFREELIST: u32 = 548;
pub const PERFINFO_LOG_TYPE_INSERTINMODIFIEDLIST: u32 = 549;
pub const PERFINFO_LOG_TYPE_INSERTINLIST: u32 = 550;
pub const PERFINFO_LOG_TYPE_INSERTATFRONT: u32 = 552;
pub const PERFINFO_LOG_TYPE_UNLINKFROMSTANDBY: u32 = 553;
pub const PERFINFO_LOG_TYPE_UNLINKFFREEORZERO: u32 = 554;
pub const PERFINFO_LOG_TYPE_WORKINGSETMANAGER: u32 = 555;
pub const PERFINFO_LOG_TYPE_TRIMPROCESS: u32 = 556;
pub const PERFINFO_LOG_TYPE_ZEROSHARECOUNT: u32 = 558;
pub const PERFINFO_LOG_TYPE_WSINFOPROCESS: u32 = 572;
pub const PERFINFO_LOG_TYPE_FAULTADDR_WITH_IP: u32 = 581;
pub const PERFINFO_LOG_TYPE_TRIMSESSION: u32 = 582;
pub const PERFINFO_LOG_TYPE_MEMORYSNAPLITE: u32 = 583;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_RUNDOWN: u32 = 584;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_CREATE: u32 = 585;
pub const PERFINFO_LOG_TYPE_WSINFOSESSION: u32 = 586;
pub const PERFINFO_LOG_TYPE_CREATE_SESSION: u32 = 587;
pub const PERFINFO_LOG_TYPE_SESSION_RUNDOWN_DC_END: u32 = 588;
pub const PERFINFO_LOG_TYPE_SESSION_RUNDOWN_DC_START: u32 = 589;
pub const PERFINFO_LOG_TYPE_SESSION_DELETE: u32 = 590;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_DELETE: u32 = 591;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ALLOC: u32 = 610;
pub const PERFINFO_LOG_TYPE_VIRTUAL_FREE: u32 = 611;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_RUNDOWN: u32 = 612;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_CREATE: u32 = 613;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_RESERVE: u32 = 614;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_RELEASE: u32 = 615;
pub const PERFINFO_LOG_TYPE_HEAP_RANGE_DESTROY: u32 = 616;
pub const PERFINFO_LOG_TYPE_PAGEFILE_BACK: u32 = 617;
pub const PERFINFO_LOG_TYPE_MEMINFO: u32 = 624;
pub const PERFINFO_LOG_TYPE_CONTMEM_GENERATE: u32 = 625;
pub const PERFINFO_LOG_TYPE_FILE_STORE_FAULT: u32 = 626;
pub const PERFINFO_LOG_TYPE_INMEMORY_STORE_FAULT: u32 = 627;
pub const PERFINFO_LOG_TYPE_COMPRESSED_PAGE: u32 = 628;
pub const PERFINFO_LOG_TYPE_PAGEINMEMORY_ACTIVE: u32 = 629;
pub const PERFINFO_LOG_TYPE_PAGE_ACCESS: u32 = 630;
pub const PERFINFO_LOG_TYPE_PAGE_RELEASE: u32 = 631;
pub const PERFINFO_LOG_TYPE_PAGE_RANGE_ACCESS: u32 = 632;
pub const PERFINFO_LOG_TYPE_PAGE_RANGE_RELEASE: u32 = 633;
pub const PERFINFO_LOG_TYPE_PAGE_COMBINE: u32 = 634;
pub const PERFINFO_LOG_TYPE_KERNEL_MEMUSAGE: u32 = 635;
pub const PERFINFO_LOG_TYPE_MM_STATS: u32 = 636;
pub const PERFINFO_LOG_TYPE_MEMINFOEX_WS: u32 = 637;
pub const PERFINFO_LOG_TYPE_MEMINFOEX_SESSIONWS: u32 = 638;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ROTATE: u32 = 639;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ALLOC_DC_START: u32 = 640;
pub const PERFINFO_LOG_TYPE_VIRTUAL_ALLOC_DC_END: u32 = 641;
pub const PERFINFO_LOG_TYPE_PAGE_ACCESS_EX: u32 = 642;
pub const PERFINFO_LOG_TYPE_REMOVEFROMWS: u32 = 643;
pub const PERFINFO_LOG_TYPE_WSSHAREABLE_RUNDOWN: u32 = 644;
pub const PERFINFO_LOG_TYPE_INMEMORYACTIVE_RUNDOWN: u32 = 645;
pub const PERFINFO_LOG_TYPE_MEM_RESET_INFO: u32 = 646;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_OBJECT_CREATE: u32 = 647;
pub const PERFINFO_LOG_TYPE_PFMAPPED_SECTION_OBJECT_DELETE: u32 = 648;
pub const PERFINFO_LOG_TYPE_CMCELLREFERRED: u32 = 2336;
pub const PERFINFO_LOG_TYPE_REG_SET_VALUE: u32 = 2337;
pub const PERFINFO_LOG_TYPE_REG_COUNTERS: u32 = 2338;
pub const PERFINFO_LOG_TYPE_REG_CONFIG: u32 = 2339;
pub const PERFINFO_LOG_TYPE_REG_HIVE_INITIALIZE: u32 = 2340;
pub const PERFINFO_LOG_TYPE_REG_HIVE_DESTROY: u32 = 2341;
pub const PERFINFO_LOG_TYPE_REG_HIVE_LINK: u32 = 2342;
pub const PERFINFO_LOG_TYPE_REG_HIVE_RUNDOWN_DC_END: u32 = 2343;
pub const PERFINFO_LOG_TYPE_REG_HIVE_DIRTY: u32 = 2344;
pub const PERFINFO_LOG_TYPE_REG_NOTIF_REGISTER: u32 = 2352;
pub const PERFINFO_LOG_TYPE_REG_NOTIF_DELIVER: u32 = 2353;
pub const PERFINFO_LOG_TYPE_RUNDOWN_CHECKPOINT: u32 = 3872;
pub const PERFINFO_LOG_TYPE_MARK: u32 = 3874;
pub const PERFINFO_LOG_TYPE_ASYNCMARK: u32 = 3876;
pub const PERFINFO_LOG_TYPE_IMAGENAME: u32 = 3878;
pub const PERFINFO_LOG_TYPE_DELAYS_CC_CAN_I_WRITE: u32 = 3879;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE: u32 = 3886;
pub const PERFINFO_LOG_TYPE_PMC_INTERRUPT: u32 = 3887;
pub const PERFINFO_LOG_TYPE_PMC_CONFIG: u32 = 3888;
pub const PERFINFO_LOG_TYPE_MSI_INTERRUPT: u32 = 3890;
pub const PERFINFO_LOG_TYPE_SYSCALL_ENTER: u32 = 3891;
pub const PERFINFO_LOG_TYPE_SYSCALL_EXIT: u32 = 3892;
pub const PERFINFO_LOG_TYPE_BACKTRACE: u32 = 3893;
pub const PERFINFO_LOG_TYPE_BACKTRACE_USERSTACK: u32 = 3894;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_CACHE: u32 = 3895;
pub const PERFINFO_LOG_TYPE_EXCEPTION_STACK: u32 = 3896;
pub const PERFINFO_LOG_TYPE_BRANCH_TRACE: u32 = 3897;
pub const PERFINFO_LOG_TYPE_DEBUGGER_ENABLED: u32 = 3898;
pub const PERFINFO_LOG_TYPE_DEBUGGER_EXIT: u32 = 3899;
pub const PERFINFO_LOG_TYPE_BRANCH_TRACE_DEBUG: u32 = 3904;
pub const PERFINFO_LOG_TYPE_BRANCH_ADDRESS_DEBUG: u32 = 3905;
pub const PERFINFO_LOG_TYPE_THREADED_DPC: u32 = 3906;
pub const PERFINFO_LOG_TYPE_INTERRUPT: u32 = 3907;
pub const PERFINFO_LOG_TYPE_DPC: u32 = 3908;
pub const PERFINFO_LOG_TYPE_TIMERDPC: u32 = 3909;
pub const PERFINFO_LOG_TYPE_IOTIMER_EXPIRATION: u32 = 3910;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_NMI: u32 = 3911;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_SET_INTERVAL: u32 = 3912;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_DC_START: u32 = 3913;
pub const PERFINFO_LOG_TYPE_SAMPLED_PROFILE_DC_END: u32 = 3914;
pub const PERFINFO_LOG_TYPE_SPINLOCK_DC_START: u32 = 3915;
pub const PERFINFO_LOG_TYPE_SPINLOCK_DC_END: u32 = 3916;
pub const PERFINFO_LOG_TYPE_ERESOURCE_DC_START: u32 = 3917;
pub const PERFINFO_LOG_TYPE_ERESOURCE_DC_END: u32 = 3918;
pub const PERFINFO_LOG_TYPE_CLOCK_INTERRUPT: u32 = 3919;
pub const PERFINFO_LOG_TYPE_TIMER_EXPIRATION_START: u32 = 3920;
pub const PERFINFO_LOG_TYPE_TIMER_EXPIRATION: u32 = 3921;
pub const PERFINFO_LOG_TYPE_TIMER_SET_PERIODIC: u32 = 3922;
pub const PERFINFO_LOG_TYPE_TIMER_SET_ONE_SHOT: u32 = 3923;
pub const PERFINFO_LOG_TYPE_TIMER_SET_THREAD: u32 = 3924;
pub const PERFINFO_LOG_TYPE_TIMER_CANCEL: u32 = 3925;
pub const PERFINFO_LOG_TYPE_TIME_ADJUSTMENT: u32 = 3926;
pub const PERFINFO_LOG_TYPE_CLOCK_MODE_SWITCH: u32 = 3927;
pub const PERFINFO_LOG_TYPE_CLOCK_TIME_UPDATE: u32 = 3928;
pub const PERFINFO_LOG_TYPE_CLOCK_DYNAMIC_TICK_VETO: u32 = 3929;
pub const PERFINFO_LOG_TYPE_CLOCK_CONFIGURATION: u32 = 3930;
pub const PERFINFO_LOG_TYPE_IPI: u32 = 3931;
pub const PERFINFO_LOG_TYPE_UNEXPECTED_INTERRUPT: u32 = 3932;
pub const PERFINFO_LOG_TYPE_IOTIMER_START: u32 = 3933;
pub const PERFINFO_LOG_TYPE_IOTIMER_STOP: u32 = 3934;
pub const PERFINFO_LOG_TYPE_PASSIVE_INTERRUPT: u32 = 3935;
pub const PERFINFO_LOG_TYPE_WDF_INTERRUPT: u32 = 3936;
pub const PERFINFO_LOG_TYPE_WDF_PASSIVE_INTERRUPT: u32 = 3937;
pub const PERFINFO_LOG_TYPE_WDF_DPC: u32 = 3938;
pub const PERFINFO_LOG_TYPE_CPU_CACHE_FLUSH: u32 = 3939;
pub const PERFINFO_LOG_TYPE_DPC_ENQUEUE: u32 = 3940;
pub const PERFINFO_LOG_TYPE_DPC_EXECUTION: u32 = 3941;
pub const PERFINFO_LOG_TYPE_INTERRUPT_STEERING: u32 = 3942;
pub const PERFINFO_LOG_TYPE_WDF_WORK_ITEM: u32 = 3943;
pub const PERFINFO_LOG_TYPE_KTIMER2_SET: u32 = 3944;
pub const PERFINFO_LOG_TYPE_KTIMER2_EXPIRATION: u32 = 3945;
pub const PERFINFO_LOG_TYPE_KTIMER2_CANCEL: u32 = 3946;
pub const PERFINFO_LOG_TYPE_KTIMER2_DISABLE: u32 = 3947;
pub const PERFINFO_LOG_TYPE_KTIMER2_FINALIZATION: u32 = 3948;
pub const PERFINFO_LOG_TYPE_SHOULD_YIELD_PROCESSOR: u32 = 3949;
pub const PERFINFO_LOG_TYPE_FUNCTION_CALL: u32 = 3968;
pub const PERFINFO_LOG_TYPE_FUNCTION_RETURN: u32 = 3969;
pub const PERFINFO_LOG_TYPE_FUNCTION_ENTER: u32 = 3970;
pub const PERFINFO_LOG_TYPE_FUNCTION_EXIT: u32 = 3971;
pub const PERFINFO_LOG_TYPE_TAILCALL: u32 = 3972;
pub const PERFINFO_LOG_TYPE_TRAP: u32 = 3973;
pub const PERFINFO_LOG_TYPE_SPINLOCK_ACQUIRE: u32 = 3974;
pub const PERFINFO_LOG_TYPE_SPINLOCK_RELEASE: u32 = 3975;
pub const PERFINFO_LOG_TYPE_CAP_COMMENT: u32 = 3976;
pub const PERFINFO_LOG_TYPE_CAP_RUNDOWN: u32 = 3977;
pub const PERFINFO_LOG_TYPE_DEBUG_PRINT: u32 = 2592;
pub const PERFINFO_LOG_TYPE_WNF_SUBSCRIBE: u32 = 3360;
pub const PERFINFO_LOG_TYPE_WNF_UNSUBSCRIBE: u32 = 3361;
pub const PERFINFO_LOG_TYPE_WNF_CALLBACK: u32 = 3362;
pub const PERFINFO_LOG_TYPE_WNF_PUBLISH: u32 = 3363;
pub const PERFINFO_LOG_TYPE_WNF_NAME_SUB_RUNDOWN: u32 = 3364;
pub const PERFINFO_LOG_TYPE_ALLOCATEPOOL: u32 = 3616;
pub const PERFINFO_LOG_TYPE_ALLOCATEPOOL_SESSION: u32 = 3617;
pub const PERFINFO_LOG_TYPE_FREEPOOL: u32 = 3618;
pub const PERFINFO_LOG_TYPE_FREEPOOL_SESSION: u32 = 3619;
pub const PERFINFO_LOG_TYPE_ADDPOOLPAGE: u32 = 3620;
pub const PERFINFO_LOG_TYPE_ADDPOOLPAGE_SESSION: u32 = 3621;
pub const PERFINFO_LOG_TYPE_BIGPOOLPAGE: u32 = 3622;
pub const PERFINFO_LOG_TYPE_BIGPOOLPAGE_SESSION: u32 = 3623;
pub const PERFINFO_LOG_TYPE_POOLSNAP_DC_START: u32 = 3624;
pub const PERFINFO_LOG_TYPE_POOLSNAP_DC_END: u32 = 3625;
pub const PERFINFO_LOG_TYPE_BIGPOOLSNAP_DC_START: u32 = 3626;
pub const PERFINFO_LOG_TYPE_BIGPOOLSNAP_DC_END: u32 = 3627;
pub const PERFINFO_LOG_TYPE_POOLSNAP_SESSION_DC_START: u32 = 3628;
pub const PERFINFO_LOG_TYPE_POOLSNAP_SESSION_DC_END: u32 = 3629;
pub const PERFINFO_LOG_TYPE_SESSIONBIGPOOLSNAP_DC_START: u32 = 3630;
pub const PERFINFO_LOG_TYPE_SESSIONBIGPOOLSNAP_DC_END: u32 = 3631;
pub const PERFINFO_LOG_TYPE_HEAP_CREATE: u32 = 4128;
pub const PERFINFO_LOG_TYPE_HEAP_ALLOC: u32 = 4129;
pub const PERFINFO_LOG_TYPE_HEAP_REALLOC: u32 = 4130;
pub const PERFINFO_LOG_TYPE_HEAP_DESTROY: u32 = 4131;
pub const PERFINFO_LOG_TYPE_HEAP_FREE: u32 = 4132;
pub const PERFINFO_LOG_TYPE_HEAP_EXTEND: u32 = 4133;
pub const PERFINFO_LOG_TYPE_HEAP_SNAPSHOT: u32 = 4134;
pub const PERFINFO_LOG_TYPE_HEAP_CREATE_SNAPSHOT: u32 = 4135;
pub const PERFINFO_LOG_TYPE_HEAP_DESTROY_SNAPSHOT: u32 = 4136;
pub const PERFINFO_LOG_TYPE_HEAP_EXTEND_SNAPSHOT: u32 = 4137;
pub const PERFINFO_LOG_TYPE_HEAP_CONTRACT: u32 = 4138;
pub const PERFINFO_LOG_TYPE_HEAP_LOCK: u32 = 4139;
pub const PERFINFO_LOG_TYPE_HEAP_UNLOCK: u32 = 4140;
pub const PERFINFO_LOG_TYPE_HEAP_VALIDATE: u32 = 4141;
pub const PERFINFO_LOG_TYPE_HEAP_WALK: u32 = 4142;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ALLOC: u32 = 4143;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_FREE: u32 = 4144;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ALLOC_CACHE: u32 = 4145;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_FREE_CACHE: u32 = 4146;
pub const PERFINFO_LOG_TYPE_HEAP_COMMIT: u32 = 4147;
pub const PERFINFO_LOG_TYPE_HEAP_DECOMMIT: u32 = 4148;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_INIT: u32 = 4149;
pub const PERFINFO_LOG_TYPE_HEAP_AFFINITY_ENABLE: u32 = 4150;
pub const PERFINFO_LOG_TYPE_HEAP_SUBSEGMENT_ACTIVATED: u32 = 4152;
pub const PERFINFO_LOG_TYPE_HEAP_AFFINITY_ASSIGN: u32 = 4153;
pub const PERFINFO_LOG_TYPE_HEAP_REUSE_THRESHOLD_ACTIVATED: u32 = 4154;
pub const PERFINFO_LOG_TYPE_CRITSEC_ENTER: u32 = 5920;
pub const PERFINFO_LOG_TYPE_CRITSEC_LEAVE: u32 = 5921;
pub const PERFINFO_LOG_TYPE_CRITSEC_COLLISION: u32 = 5922;
pub const PERFINFO_LOG_TYPE_CRITSEC_INITIALIZE: u32 = 5923;
pub const PERFINFO_LOG_TYPE_STACKWALK: u32 = 6176;
pub const PERFINFO_LOG_TYPE_STACKTRACE_CREATE: u32 = 6178;
pub const PERFINFO_LOG_TYPE_STACKTRACE_DELETE: u32 = 6179;
pub const PERFINFO_LOG_TYPE_STACKTRACE_RUNDOWN: u32 = 6180;
pub const PERFINFO_LOG_TYPE_STACKTRACE_KEY_KERNEL: u32 = 6181;
pub const PERFINFO_LOG_TYPE_STACKTRACE_KEY_USER: u32 = 6182;
pub const WMI_LOG_TYPE_ALPC_SEND_MESSAGE: u32 = 6689;
pub const WMI_LOG_TYPE_ALPC_RECEIVE_MESSAGE: u32 = 6690;
pub const WMI_LOG_TYPE_ALPC_WAIT_FOR_REPLY: u32 = 6691;
pub const WMI_LOG_TYPE_ALPC_WAIT_FOR_NEW_MESSAGE: u32 = 6692;
pub const WMI_LOG_TYPE_ALPC_UNWAIT: u32 = 6693;
pub const WMI_LOG_TYPE_ALPC_CONNECT_REQUEST: u32 = 6694;
pub const WMI_LOG_TYPE_ALPC_CONNECT_SUCCESS: u32 = 6695;
pub const WMI_LOG_TYPE_ALPC_CONNECT_FAIL: u32 = 6696;
pub const WMI_LOG_TYPE_ALPC_CLOSE_PORT: u32 = 6697;
pub const PERFINFO_LOG_TYPE_CREATE_HANDLE: u32 = 4384;
pub const PERFINFO_LOG_TYPE_CLOSE_HANDLE: u32 = 4385;
pub const PERFINFO_LOG_TYPE_DUPLICATE_HANDLE: u32 = 4386;
pub const PERFINFO_LOG_TYPE_OBJECT_TYPE_DC_START: u32 = 4388;
pub const PERFINFO_LOG_TYPE_OBJECT_TYPE_DC_END: u32 = 4389;
pub const PERFINFO_LOG_TYPE_OBJECT_HANDLE_DC_START: u32 = 4390;
pub const PERFINFO_LOG_TYPE_OBJECT_HANDLE_DC_END: u32 = 4391;
pub const PERFINFO_LOG_TYPE_CREATE_OBJECT: u32 = 4400;
pub const PERFINFO_LOG_TYPE_DELETE_OBJECT: u32 = 4401;
pub const PERFINFO_LOG_TYPE_REFERENCE_OBJECT: u32 = 4402;
pub const PERFINFO_LOG_TYPE_DEREFERENCE_OBJECT: u32 = 4403;
pub const PERFINFO_LOG_TYPE_BATTERY_LIFE_INFO: u32 = 4640;
pub const PERFINFO_LOG_TYPE_IDLE_STATE_CHANGE: u32 = 4641;
pub const PERFINFO_LOG_TYPE_SET_POWER_ACTION: u32 = 4642;
pub const PERFINFO_LOG_TYPE_SET_POWER_ACTION_RET: u32 = 4643;
pub const PERFINFO_LOG_TYPE_SET_DEVICES_STATE: u32 = 4644;
pub const PERFINFO_LOG_TYPE_SET_DEVICES_STATE_RET: u32 = 4645;
pub const PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE: u32 = 4646;
pub const PERFINFO_LOG_TYPE_PO_NOTIFY_DEVICE_COMPLETE: u32 = 4647;
pub const PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT: u32 = 4648;
pub const PERFINFO_LOG_TYPE_PO_SESSION_CALLOUT_RET: u32 = 4649;
pub const PERFINFO_LOG_TYPE_PO_PRESLEEP: u32 = 4656;
pub const PERFINFO_LOG_TYPE_PO_POSTSLEEP: u32 = 4657;
pub const PERFINFO_LOG_TYPE_PO_CALIBRATED_PERFCOUNTER: u32 = 4658;
pub const PERFINFO_LOG_TYPE_PPM_PERF_STATE_CHANGE: u32 = 4659;
pub const PERFINFO_LOG_TYPE_PPM_THROTTLE_STATE_CHANGE: u32 = 4660;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_STATE_CHANGE: u32 = 4661;
pub const PERFINFO_LOG_TYPE_PPM_THERMAL_CONSTRAINT: u32 = 4662;
pub const PERFINFO_LOG_TYPE_PO_SIGNAL_RESUME_UI: u32 = 4663;
pub const PERFINFO_LOG_TYPE_PO_SIGNAL_VIDEO_ON: u32 = 4664;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_STATE_ENTER: u32 = 4665;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_STATE_EXIT: u32 = 4666;
pub const PERFINFO_LOG_TYPE_PPM_PLATFORM_IDLE_STATE_ENTER: u32 = 4667;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_EXIT_LATENCY: u32 = 4668;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_PROCESSOR_SELECTION: u32 = 4669;
pub const PERFINFO_LOG_TYPE_PPM_IDLE_PLATFORM_SELECTION: u32 = 4670;
pub const PERFINFO_LOG_TYPE_PPM_COORDINATED_IDLE_ENTER: u32 = 4671;
pub const PERFINFO_LOG_TYPE_PPM_COORDINATED_IDLE_EXIT: u32 = 4672;
pub const PERFINFO_LOG_TYPE_COWHEADER: u32 = 4888;
pub const PERFINFO_LOG_TYPE_COWBLOB: u32 = 4889;
pub const PERFINFO_LOG_TYPE_COWBLOB_CLOSED: u32 = 4890;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_ENT: u32 = 4896;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_JUMP: u32 = 4897;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_RET: u32 = 4898;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_CALL: u32 = 4899;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_CALLRET: u32 = 4900;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_INT2E: u32 = 4901;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_INT2B: u32 = 4902;
pub const PERFINFO_LOG_TYPE_MODULEBOUND_FULLTRACE: u32 = 4903;
pub const PERFINFO_LOG_TYPE_MMCSS_START: u32 = 32;
pub const PERFINFO_LOG_TYPE_MMCSS_STOP: u32 = 33;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_EVENT: u32 = 34;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_WAKEUP: u32 = 35;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_SLEEP: u32 = 36;
pub const PERFINFO_LOG_TYPE_MMCSS_SCHEDULER_SLEEP_RESP: u32 = 37;
pub const PERFINFO_LOG_TYPE_SPLITIO_VOLMGR: u32 = 6944;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_ENQUEUE: u32 = 7200;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_DEQUEUE: u32 = 7201;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_START: u32 = 7202;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_STOP: u32 = 7203;
pub const PERFINFO_LOG_TYPE_TP_CALLBACK_CANCEL: u32 = 7204;
pub const PERFINFO_LOG_TYPE_TP_POOL_CREATE: u32 = 7205;
pub const PERFINFO_LOG_TYPE_TP_POOL_CLOSE: u32 = 7206;
pub const PERFINFO_LOG_TYPE_TP_POOL_TH_MIN_SET: u32 = 7207;
pub const PERFINFO_LOG_TYPE_TP_POOL_TH_MAX_SET: u32 = 7208;
pub const PERFINFO_LOG_TYPE_TP_WORKER_NUMANODE_SWITCH: u32 = 7209;
pub const PERFINFO_LOG_TYPE_TP_TIMER_SET: u32 = 7210;
pub const PERFINFO_LOG_TYPE_TP_TIMER_CANCELLED: u32 = 7211;
pub const PERFINFO_LOG_TYPE_TP_TIMER_SET_NTTIMER: u32 = 7212;
pub const PERFINFO_LOG_TYPE_TP_TIMER_CANCEL_NTTIMER: u32 = 7213;
pub const PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION_BEGIN: u32 = 7214;
pub const PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION_END: u32 = 7215;
pub const PERFINFO_LOG_TYPE_TP_TIMER_EXPIRATION: u32 = 7216;
pub const PERFINFO_LOG_TYPE_UMS_DIRECTED_SWITCH_START: u32 = 6432;
pub const PERFINFO_LOG_TYPE_UMS_DIRECTED_SWITCH_END: u32 = 6433;
pub const PERFINFO_LOG_TYPE_UMS_PARK: u32 = 6434;
pub const PERFINFO_LOG_TYPE_UMS_DISASSOCIATE: u32 = 6435;
pub const PERFINFO_LOG_TYPE_UMS_CONTEXT_SWITCH: u32 = 6436;
pub const PERFINFO_LOG_TYPE_CC_WORKITEM_ENQUEUE: u32 = 5632;
pub const PERFINFO_LOG_TYPE_CC_WORKITEM_DEQUEUE: u32 = 5633;
pub const PERFINFO_LOG_TYPE_CC_WORKITEM_COMPLETE: u32 = 5634;
pub const PERFINFO_LOG_TYPE_CC_READ_AHEAD: u32 = 5635;
pub const PERFINFO_LOG_TYPE_CC_WRITE_BEHIND: u32 = 5636;
pub const PERFINFO_LOG_TYPE_CC_LAZY_WRITE_SCAN: u32 = 5637;
pub const PERFINFO_LOG_TYPE_CC_CAN_I_WRITE_FAIL: u32 = 5638;
pub const PERFINFO_LOG_TYPE_CC_FLUSH_CACHE: u32 = 5641;
pub const PERFINFO_LOG_TYPE_CC_FLUSH_SECTION: u32 = 5642;
pub const PERFINFO_LOG_TYPE_CC_READ_AHEAD_PREFETCH: u32 = 5643;
pub const PERFINFO_LOG_TYPE_CC_SCHEDULE_READ_AHEAD: u32 = 5644;
pub const PERFINFO_LOG_TYPE_CC_LOGGED_STREAM_INFO: u32 = 5645;
pub const PERFINFO_LOG_TYPE_CC_EXTRA_WRITEBEHIND_THREAD: u32 = 5646;
pub const MAXIMUM_NODE_COUNT: u32 = 64;
pub const CODEINTEGRITY_OPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITY_OPTION_TESTSIGN: u32 = 2;
pub const CODEINTEGRITY_OPTION_UMCI_ENABLED: u32 = 4;
pub const CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED: u32 = 8;
pub const CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED: u32 = 16;
pub const CODEINTEGRITY_OPTION_TEST_BUILD: u32 = 32;
pub const CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD: u32 = 64;
pub const CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED: u32 = 128;
pub const CODEINTEGRITY_OPTION_FLIGHT_BUILD: u32 = 256;
pub const CODEINTEGRITY_OPTION_FLIGHTING_ENABLED: u32 = 512;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED: u32 = 1024;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED: u32 = 2048;
pub const CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED: u32 = 4096;
pub const CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED: u32 = 8192;
pub const CODEINTEGRITY_OPTION_WHQL_ENFORCEMENT_ENABLED: u32 = 16384;
pub const CODEINTEGRITY_OPTION_WHQL_AUDITMODE_ENABLED: u32 = 32768;
pub const SYSTEM_STORE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_STATS_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_STORE_CREATE_INFORMATION_VERSION: u32 = 6;
pub const SYSTEM_STORE_DELETE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_LIST_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_CACHE_LIST_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_CACHE_CREATE_INFORMATION_VERSION: u32 = 3;
pub const SYSTEM_CACHE_DELETE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_CACHE_STORE_CREATE_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_CACHE_STORE_DELETE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_CACHE_STATS_INFORMATION_VERSION: u32 = 3;
pub const SYSTEM_STORE_REGISTRATION_INFORMATION_VERSION: u32 = 2;
pub const SYSTEM_STORE_RESIZE_INFORMATION_VERSION: u32 = 6;
pub const SYSTEM_CACHE_STORE_RESIZE_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_CONFIG_INFORMATION_VERSION: u32 = 4;
pub const SYSTEM_STORE_HIGH_MEM_PRIORITY_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_TRIM_INFORMATION_VERSION: u32 = 1;
pub const SYSTEM_STORE_COMPRESSION_INFORMATION_VERSION: u32 = 3;
pub const MEMORY_COMBINE_FLAGS_COMMON_PAGES_ONLY: u32 = 4;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITYPOLICY_OPTION_AUDIT: u32 = 2;
pub const CODEINTEGRITYPOLICY_OPTION_REQUIRE_WHQL: u32 = 4;
pub const CODEINTEGRITYPOLICY_OPTION_DISABLED_FLIGHTSIGNING: u32 = 8;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_UMCI: u32 = 16;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_UPDATE_POLICY_NOREBOOT: u32 = 32;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_SECURE_SETTING_POLICY: u32 = 64;
pub const CODEINTEGRITYPOLICY_OPTION_ENABLED_UNSIGNED_SYSTEMINTEGRITY_POLICY: u32 = 128;
pub const CODEINTEGRITYPOLICY_OPTION_DYNAMIC_CODE_POLICY_ENABLED: u32 = 256;
pub const CODEINTEGRITYPOLICY_OPTION_RELOAD_POLICY_NO_REBOOT: u32 = 268435456;
pub const CODEINTEGRITYPOLICY_OPTION_CONDITIONAL_LOCKDOWN: u32 = 536870912;
pub const CODEINTEGRITYPOLICY_OPTION_NOLOCKDOWN: u32 = 1073741824;
pub const CODEINTEGRITYPOLICY_OPTION_LOCKDOWN: u32 = 2147483648;
pub const CODEINTEGRITYPOLICY_HVCIOPTION_ENABLED: u32 = 1;
pub const CODEINTEGRITYPOLICY_HVCIOPTION_STRICT: u32 = 2;
pub const CODEINTEGRITYPOLICY_HVCIOPTION_DEBUG: u32 = 4;
pub const SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_VERSION: u32 = 1;
pub const SYSDBG_LIVEDUMP_CONTROL_VERSION: u32 = 1;
pub const SYSDBG_LIVEDUMP_CONTROL_VERSION_WIN11: u32 = 2;
pub const HARDERROR_OVERRIDE_ERRORMODE: u32 = 268435456;
pub const PROCESSOR_FEATURE_MAX: u32 = 64;
pub const MAX_WOW64_SHARED_ENTRIES: u32 = 16;
pub const NX_SUPPORT_POLICY_ALWAYSOFF: u32 = 0;
pub const NX_SUPPORT_POLICY_ALWAYSON: u32 = 1;
pub const NX_SUPPORT_POLICY_OPTIN: u32 = 2;
pub const NX_SUPPORT_POLICY_OPTOUT: u32 = 3;
pub const FLG_STOP_ON_EXCEPTION: u32 = 1;
pub const FLG_SHOW_LDR_SNAPS: u32 = 2;
pub const FLG_DEBUG_INITIAL_COMMAND: u32 = 4;
pub const FLG_STOP_ON_HUNG_GUI: u32 = 8;
pub const FLG_HEAP_ENABLE_TAIL_CHECK: u32 = 16;
pub const FLG_HEAP_ENABLE_FREE_CHECK: u32 = 32;
pub const FLG_HEAP_VALIDATE_PARAMETERS: u32 = 64;
pub const FLG_HEAP_VALIDATE_ALL: u32 = 128;
pub const FLG_APPLICATION_VERIFIER: u32 = 256;
pub const FLG_MONITOR_SILENT_PROCESS_EXIT: u32 = 512;
pub const FLG_POOL_ENABLE_TAGGING: u32 = 1024;
pub const FLG_HEAP_ENABLE_TAGGING: u32 = 2048;
pub const FLG_USER_STACK_TRACE_DB: u32 = 4096;
pub const FLG_KERNEL_STACK_TRACE_DB: u32 = 8192;
pub const FLG_MAINTAIN_OBJECT_TYPELIST: u32 = 16384;
pub const FLG_HEAP_ENABLE_TAG_BY_DLL: u32 = 32768;
pub const FLG_DISABLE_STACK_EXTENSION: u32 = 65536;
pub const FLG_ENABLE_CSRDEBUG: u32 = 131072;
pub const FLG_ENABLE_KDEBUG_SYMBOL_LOAD: u32 = 262144;
pub const FLG_DISABLE_PAGE_KERNEL_STACKS: u32 = 524288;
pub const FLG_ENABLE_SYSTEM_CRIT_BREAKS: u32 = 1048576;
pub const FLG_HEAP_DISABLE_COALESCING: u32 = 2097152;
pub const FLG_ENABLE_CLOSE_EXCEPTIONS: u32 = 4194304;
pub const FLG_ENABLE_EXCEPTION_LOGGING: u32 = 8388608;
pub const FLG_ENABLE_HANDLE_TYPE_TAGGING: u32 = 16777216;
pub const FLG_HEAP_PAGE_ALLOCS: u32 = 33554432;
pub const FLG_DEBUG_INITIAL_COMMAND_EX: u32 = 67108864;
pub const FLG_DISABLE_DBGPRINT: u32 = 134217728;
pub const FLG_CRITSEC_EVENT_CREATION: u32 = 268435456;
pub const FLG_STOP_ON_UNHANDLED_EXCEPTION: u32 = 536870912;
pub const FLG_ENABLE_HANDLE_EXCEPTIONS: u32 = 1073741824;
pub const FLG_DISABLE_PROTDLLS: u32 = 2147483648;
pub const FLG_VALID_BITS: u32 = 4294966783;
pub const FLG_BOOTONLY_VALID_BITS: u32 = 67788804;
pub const FLG_KERNELMODE_VALID_BITS: u32 = 1237582859;
pub const TIMER_QUERY_STATE: u32 = 1;
pub const TIMER_MODIFY_STATE: u32 = 2;
pub const TIMER_ALL_ACCESS: u32 = 2031619;
pub const PERF_PROCESS: u32 = 1;
pub const PERF_THREAD: u32 = EVENT_TRACE_FLAG_THREAD.0;
pub const PERF_PROC_THREAD: u32 = EVENT_TRACE_FLAG_PROCESS.0 | EVENT_TRACE_FLAG_THREAD.0;
pub const PERF_LOADER: u32 = EVENT_TRACE_FLAG_IMAGE_LOAD.0;
pub const PERF_PERF_COUNTER: u32 = EVENT_TRACE_FLAG_PROCESS_COUNTERS.0;
pub const PERF_FILENAME: u32 = EVENT_TRACE_FLAG_DISK_FILE_IO.0;
pub const PERF_DISK_IO: u32 = EVENT_TRACE_FLAG_DISK_FILE_IO.0 | EVENT_TRACE_FLAG_DISK_IO.0;
pub const PERF_DISK_IO_INIT: u32 = EVENT_TRACE_FLAG_DISK_IO_INIT.0;
pub const PERF_ALL_FAULTS: u32 = EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS.0;
pub const PERF_HARD_FAULTS: u32 = EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS.0;
pub const PERF_VAMAP: u32 = EVENT_TRACE_FLAG_VAMAP.0;
pub const PERF_NETWORK: u32 = EVENT_TRACE_FLAG_NETWORK_TCPIP.0;
pub const PERF_REGISTRY: u32 = EVENT_TRACE_FLAG_REGISTRY.0;
pub const PERF_DBGPRINT: u32 = EVENT_TRACE_FLAG_DBGPRINT.0;
pub const PERF_JOB: u32 = EVENT_TRACE_FLAG_JOB.0;
pub const PERF_ALPC: u32 = EVENT_TRACE_FLAG_ALPC.0;
pub const PERF_SPLIT_IO: u32 = EVENT_TRACE_FLAG_SPLIT_IO.0;
pub const PERF_DEBUG_EVENTS: u32 = EVENT_TRACE_FLAG_DEBUG_EVENTS;
pub const PERF_FILE_IO: u32 = EVENT_TRACE_FLAG_FILE_IO.0;
pub const PERF_FILE_IO_INIT: u32 = EVENT_TRACE_FLAG_FILE_IO_INIT.0;
pub const PERF_NO_SYSCONFIG: u32 = EVENT_TRACE_FLAG_NO_SYSCONFIG.0;
pub const SYSDBG_LIVEDUMP_CONTROL_SIZE_WIN11: u32 = 72;
pub const ATOM_FLAG_GLOBAL: u32 = 2;
pub const SYSDBG_LIVEDUMP_CONTROL_SIZE: u32 = 64;
pub const USER_SHARED_DATA: *const KUSER_SHARED_DATA = 0x7ffe0000 as *const KUSER_SHARED_DATA;
pub const FLG_USERMODE_VALID_BITS: u32 = 2989595123;
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtDelayExecution(Alertable: BOOLEAN, DelayInterval: *mut i64) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQuerySystemEnvironmentValue(
        VariableName: *mut UNICODE_STRING,
        VariableValue: PWSTR,
        ValueLength: u16,
        ReturnLength: *mut u16,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetSystemEnvironmentValue(
        VariableName: *mut UNICODE_STRING,
        VariableValue: *mut UNICODE_STRING,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQuerySystemEnvironmentValueEx(
        VariableName: *mut UNICODE_STRING,
        VendorGuid: *const GUID,
        Value: *mut std::ffi::c_void,
        ValueLength: *mut u32,
        Attributes: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetSystemEnvironmentValueEx(
        VariableName: *mut UNICODE_STRING,
        VendorGuid: *const GUID,
        Value: *mut std::ffi::c_void,
        ValueLength: u32,
        Attributes: u32,
    ) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_ENVIRONMENT_INFORMATION_CLASS {
    SystemEnvironmentNameInformation = 1,
    SystemEnvironmentValueInformation = 2,
    MaxSystemEnvironmentInfoClass = 3,
}
#[repr(C)]
pub struct VARIABLE_NAME {
    pub NextEntryOffset: u32,
    pub VendorGuid: GUID,
    pub Name: [u16; 1usize],
}
impl Default for VARIABLE_NAME {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for VARIABLE_NAME {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VARIABLE_NAME {{ Name: {:?} }}", self.Name)
    }
}
#[repr(C)]
pub struct VARIABLE_NAME_AND_VALUE {
    pub NextEntryOffset: u32,
    pub ValueOffset: u32,
    pub ValueLength: u32,
    pub Attributes: u32,
    pub VendorGuid: GUID,
    pub Name: [u16; 1usize],
}
impl Default for VARIABLE_NAME_AND_VALUE {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for VARIABLE_NAME_AND_VALUE {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "VARIABLE_NAME_AND_VALUE {{ Name: {:?} }}", self.Name)
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtEnumerateSystemEnvironmentValuesEx(
        InformationClass: u32,
        Buffer: *mut std::ffi::c_void,
        BufferLength: *mut u32,
    ) -> NTSTATUS;
}
#[repr(C)]
pub struct BOOT_ENTRY {
    pub Version: u32,
    pub Length: u32,
    pub Id: u32,
    pub Attributes: u32,
    pub FriendlyNameOffset: u32,
    pub BootFilePathOffset: u32,
    pub OsOptionsLength: u32,
    pub OsOptions: [u8; 1usize],
}
impl Default for BOOT_ENTRY {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for BOOT_ENTRY {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BOOT_ENTRY {{ OsOptions: {:?} }}", self.OsOptions)
    }
}
#[repr(C)]
pub struct BOOT_ENTRY_LIST {
    pub NextEntryOffset: u32,
    pub BootEntry: BOOT_ENTRY,
}
impl Default for BOOT_ENTRY_LIST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for BOOT_ENTRY_LIST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BOOT_ENTRY_LIST {{ BootEntry: {:?} }}", self.BootEntry)
    }
}
#[repr(C)]
pub struct BOOT_OPTIONS {
    pub Version: u32,
    pub Length: u32,
    pub Timeout: u32,
    pub CurrentBootEntryId: u32,
    pub NextBootEntryId: u32,
    pub HeadlessRedirection: [u16; 1usize],
}
impl Default for BOOT_OPTIONS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for BOOT_OPTIONS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "BOOT_OPTIONS {{ HeadlessRedirection: {:?} }}",
            self.HeadlessRedirection
        )
    }
}
#[repr(C)]
pub struct FILE_PATH {
    pub Version: u32,
    pub Length: u32,
    pub Type: u32,
    pub FilePath: [u8; 1usize],
}
impl Default for FILE_PATH {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for FILE_PATH {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FILE_PATH {{ FilePath: {:?} }}", self.FilePath)
    }
}
#[repr(C)]
pub struct EFI_DRIVER_ENTRY {
    pub Version: u32,
    pub Length: u32,
    pub Id: u32,
    pub FriendlyNameOffset: u32,
    pub DriverFilePathOffset: u32,
}
impl Default for EFI_DRIVER_ENTRY {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EFI_DRIVER_ENTRY {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EFI_DRIVER_ENTRY {{  }}")
    }
}
#[repr(C)]
pub struct EFI_DRIVER_ENTRY_LIST {
    pub NextEntryOffset: u32,
    pub DriverEntry: EFI_DRIVER_ENTRY,
}
impl Default for EFI_DRIVER_ENTRY_LIST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EFI_DRIVER_ENTRY_LIST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EFI_DRIVER_ENTRY_LIST {{ DriverEntry: {:?} }}",
            self.DriverEntry
        )
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtAddBootEntry(BootEntry: *mut BOOT_ENTRY, Id: *mut u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtDeleteBootEntry(Id: u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtModifyBootEntry(BootEntry: *mut BOOT_ENTRY) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtEnumerateBootEntries(
        Buffer: *mut std::ffi::c_void,
        BufferLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryBootEntryOrder(Ids: *mut u32, Count: *mut u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetBootEntryOrder(Ids: *mut u32, Count: u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryBootOptions(
        BootOptions: *mut BOOT_OPTIONS,
        BootOptionsLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetBootOptions(BootOptions: *mut BOOT_OPTIONS, FieldsToChange: u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtTranslateFilePath(
        InputFilePath: *mut FILE_PATH,
        OutputType: u32,
        OutputFilePath: *mut FILE_PATH,
        OutputFilePathLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtAddDriverEntry(DriverEntry: *mut EFI_DRIVER_ENTRY, Id: *mut u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtDeleteDriverEntry(Id: u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtModifyDriverEntry(DriverEntry: *mut EFI_DRIVER_ENTRY) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtEnumerateDriverEntries(
        Buffer: *mut std::ffi::c_void,
        BufferLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryDriverEntryOrder(Ids: *mut u32, Count: *mut u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetDriverEntryOrder(Ids: *mut u32, Count: u32) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FILTER_BOOT_OPTION_OPERATION {
    FilterBootOptionOperationOpenSystemStore = 0,
    FilterBootOptionOperationSetElement = 1,
    FilterBootOptionOperationDeleteElement = 2,
    FilterBootOptionOperationMax = 3,
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtFilterBootOption(
        FilterOperation: FILTER_BOOT_OPTION_OPERATION,
        ObjectType: u32,
        ElementType: u32,
        Data: *mut std::ffi::c_void,
        DataSize: u32,
    ) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EVENT_INFORMATION_CLASS {
    EventBasicInformation = 0,
}
#[repr(C)]
pub struct EVENT_BASIC_INFORMATION {
    pub EventType: EVENT_TYPE,
    pub EventState: i32,
}
impl Default for EVENT_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_BASIC_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EVENT_BASIC_INFORMATION {{  }}")
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateEvent(
        EventHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        EventType: EVENT_TYPE,
        InitialState: BOOLEAN,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtOpenEvent(
        EventHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetEvent(EventHandle: HANDLE, PreviousState: *mut i32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetEventBoostPriority(EventHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtClearEvent(EventHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtResetEvent(EventHandle: HANDLE, PreviousState: *mut i32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtPulseEvent(EventHandle: HANDLE, PreviousState: *mut i32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryEvent(
        EventHandle: HANDLE,
        EventInformationClass: EVENT_INFORMATION_CLASS,
        EventInformation: *mut std::ffi::c_void,
        EventInformationLength: u32,
        ReturnLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateEventPair(
        EventPairHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtOpenEventPair(
        EventPairHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetLowWaitHighEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetHighWaitLowEventPair(EventPairHandle: HANDLE) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MUTANT_INFORMATION_CLASS {
    MutantBasicInformation = 0,
    MutantOwnerInformation = 1,
}
#[repr(C)]
pub struct MUTANT_BASIC_INFORMATION {
    pub CurrentCount: i32,
    pub OwnedByCaller: BOOLEAN,
    pub AbandonedState: BOOLEAN,
}
impl Default for MUTANT_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for MUTANT_BASIC_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MUTANT_BASIC_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct MUTANT_OWNER_INFORMATION {
    pub ClientId: CLIENT_ID,
}
impl Default for MUTANT_OWNER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for MUTANT_OWNER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MUTANT_OWNER_INFORMATION {{  }}")
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateMutant(
        MutantHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        InitialOwner: BOOLEAN,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtOpenMutant(
        MutantHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtReleaseMutant(MutantHandle: HANDLE, PreviousCount: *mut i32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryMutant(
        MutantHandle: HANDLE,
        MutantInformationClass: MUTANT_INFORMATION_CLASS,
        MutantInformation: *mut std::ffi::c_void,
        MutantInformationLength: u32,
        ReturnLength: *mut u32,
    ) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SEMAPHORE_INFORMATION_CLASS {
    SemaphoreBasicInformation = 0,
}
#[repr(C)]
pub struct SEMAPHORE_BASIC_INFORMATION {
    pub CurrentCount: i32,
    pub MaximumCount: i32,
}
impl Default for SEMAPHORE_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SEMAPHORE_BASIC_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SEMAPHORE_BASIC_INFORMATION {{  }}")
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateSemaphore(
        SemaphoreHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        InitialCount: i32,
        MaximumCount: i32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtOpenSemaphore(
        SemaphoreHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtReleaseSemaphore(
        SemaphoreHandle: HANDLE,
        ReleaseCount: i32,
        PreviousCount: *mut i32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQuerySemaphore(
        SemaphoreHandle: HANDLE,
        SemaphoreInformationClass: SEMAPHORE_INFORMATION_CLASS,
        SemaphoreInformation: *mut std::ffi::c_void,
        SemaphoreInformationLength: u32,
        ReturnLength: *mut u32,
    ) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TIMER_INFORMATION_CLASS {
    TimerBasicInformation = 0,
}
#[repr(C)]
pub struct TIMER_BASIC_INFORMATION {
    pub RemainingTime: i64,
    pub TimerState: BOOLEAN,
}
impl Default for TIMER_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for TIMER_BASIC_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TIMER_BASIC_INFORMATION {{  }}")
    }
}
pub type PTIMER_APC_ROUTINE = std::option::Option<
    unsafe extern "system" fn(
        TimerContext: *mut std::ffi::c_void,
        TimerLowValue: u32,
        TimerHighValue: i32,
    ),
>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TIMER_SET_INFORMATION_CLASS {
    TimerSetCoalescableTimer = 0,
    MaxTimerInfoClass = 1,
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateTimer(
        TimerHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        TimerType: TIMER_TYPE,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtOpenTimer(
        TimerHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetTimer(
        TimerHandle: HANDLE,
        DueTime: *mut i64,
        TimerApcRoutine: PTIMER_APC_ROUTINE,
        TimerContext: *mut std::ffi::c_void,
        ResumeTimer: BOOLEAN,
        Period: i32,
        PreviousState: *mut BOOLEAN,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetTimerEx(
        TimerHandle: HANDLE,
        TimerSetInformationClass: TIMER_SET_INFORMATION_CLASS,
        TimerSetInformation: *mut std::ffi::c_void,
        TimerSetInformationLength: u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCancelTimer(TimerHandle: HANDLE, CurrentState: *mut BOOLEAN) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryTimer(
        TimerHandle: HANDLE,
        TimerInformationClass: TIMER_INFORMATION_CLASS,
        TimerInformation: *mut std::ffi::c_void,
        TimerInformationLength: u32,
        ReturnLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateIRTimer(TimerHandle: *mut HANDLE, DesiredAccess: u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetIRTimer(TimerHandle: HANDLE, DueTime: *mut i64) -> NTSTATUS;
}
#[repr(C)]
pub struct T2_SET_PARAMETERS {
    pub Version: u32,
    pub Reserved: u32,
    pub NoWakeTolerance: i64,
}
impl Default for T2_SET_PARAMETERS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for T2_SET_PARAMETERS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "T2_SET_PARAMETERS {{  }}")
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateTimer2(
        TimerHandle: *mut HANDLE,
        Reserved1: *mut std::ffi::c_void,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        Attributes: u32,
        DesiredAccess: u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetTimer2(
        TimerHandle: HANDLE,
        DueTime: *mut i64,
        Period: *mut i64,
        Parameters: *mut T2_SET_PARAMETERS,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCancelTimer2(TimerHandle: HANDLE, Parameters: *mut std::ffi::c_void) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateProfile(
        ProfileHandle: *mut HANDLE,
        Process: HANDLE,
        ProfileBase: *mut std::ffi::c_void,
        ProfileSize: usize,
        BucketSize: u32,
        Buffer: *mut u32,
        BufferSize: u32,
        ProfileSource: KPROFILE_SOURCE,
        Affinity: usize,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateProfileEx(
        ProfileHandle: *mut HANDLE,
        Process: HANDLE,
        ProfileBase: *mut std::ffi::c_void,
        ProfileSize: usize,
        BucketSize: u32,
        Buffer: *mut u32,
        BufferSize: u32,
        ProfileSource: KPROFILE_SOURCE,
        GroupCount: u16,
        GroupAffinity: *mut GROUP_AFFINITY,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtStartProfile(ProfileHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtStopProfile(ProfileHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryIntervalProfile(ProfileSource: KPROFILE_SOURCE, Interval: *mut u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetIntervalProfile(Interval: u32, Source: KPROFILE_SOURCE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateKeyedEvent(
        KeyedEventHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        Flags: u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtOpenKeyedEvent(
        KeyedEventHandle: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtReleaseKeyedEvent(
        KeyedEventHandle: HANDLE,
        KeyValue: *mut std::ffi::c_void,
        Alertable: BOOLEAN,
        Timeout: *mut i64,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtWaitForKeyedEvent(
        KeyedEventHandle: HANDLE,
        KeyValue: *mut std::ffi::c_void,
        Alertable: BOOLEAN,
        Timeout: *mut i64,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtUmsThreadYield(SchedulerParam: *mut std::ffi::c_void) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WNF_STATE_NAME_LIFETIME {
    WnfWellKnownStateName = 0,
    WnfPermanentStateName = 1,
    WnfPersistentStateName = 2,
    WnfTemporaryStateName = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WNF_STATE_NAME_INFORMATION {
    WnfInfoStateNameExist = 0,
    WnfInfoSubscribersPresent = 1,
    WnfInfoIsQuiescent = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WNF_DATA_SCOPE {
    WnfDataScopeSystem = 0,
    WnfDataScopeSession = 1,
    WnfDataScopeUser = 2,
    WnfDataScopeProcess = 3,
    WnfDataScopeMachine = 4,
    WnfDataScopePhysicalMachine = 5,
}
#[repr(C)]
pub struct WNF_TYPE_ID {
    pub TypeId: GUID,
}
impl Default for WNF_TYPE_ID {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for WNF_TYPE_ID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WNF_TYPE_ID {{  }}")
    }
}
#[repr(C)]
pub struct WNF_DELIVERY_DESCRIPTOR {
    pub SubscriptionId: u64,
    pub StateName: WNF_STATE_NAME,
    pub ChangeStamp: u32,
    pub StateDataSize: u32,
    pub EventMask: u32,
    pub TypeId: WNF_TYPE_ID,
    pub StateDataOffset: u32,
}
impl Default for WNF_DELIVERY_DESCRIPTOR {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for WNF_DELIVERY_DESCRIPTOR {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WNF_DELIVERY_DESCRIPTOR {{ StateName: {:?}, TypeId: {:?} }}",
            self.StateName, self.TypeId
        )
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateWnfStateName(
        StateName: *mut WNF_STATE_NAME,
        NameLifetime: WNF_STATE_NAME_LIFETIME,
        DataScope: WNF_DATA_SCOPE,
        PersistData: BOOLEAN,
        TypeId: *const WNF_TYPE_ID,
        MaximumStateSize: u32,
        SecurityDescriptor: *mut SECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtDeleteWnfStateName(StateName: *const WNF_STATE_NAME) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtUpdateWnfStateData(
        StateName: *const WNF_STATE_NAME,
        Buffer: *const std::os::raw::c_void,
        Length: u32,
        TypeId: *const WNF_TYPE_ID,
        ExplicitScope: *const std::os::raw::c_void,
        MatchingChangeStamp: u32,
        CheckStamp: u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtDeleteWnfStateData(
        StateName: *const WNF_STATE_NAME,
        ExplicitScope: *const std::os::raw::c_void,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryWnfStateData(
        StateName: *const WNF_STATE_NAME,
        TypeId: *const WNF_TYPE_ID,
        ExplicitScope: *const std::os::raw::c_void,
        ChangeStamp: *mut u32,
        Buffer: *mut std::ffi::c_void,
        BufferSize: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryWnfStateNameInformation(
        StateName: *const WNF_STATE_NAME,
        NameInfoClass: WNF_STATE_NAME_INFORMATION,
        ExplicitScope: *const std::os::raw::c_void,
        InfoBuffer: *mut std::ffi::c_void,
        InfoBufferSize: u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSubscribeWnfStateChange(
        StateName: *const WNF_STATE_NAME,
        ChangeStamp: u32,
        EventMask: u32,
        SubscriptionId: *mut u64,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtUnsubscribeWnfStateChange(StateName: *const WNF_STATE_NAME) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtGetCompleteWnfStateSubscription(
        OldDescriptorStateName: *mut WNF_STATE_NAME,
        OldSubscriptionId: *mut u64,
        OldDescriptorEventMask: u32,
        OldDescriptorStatus: u32,
        NewDeliveryDescriptor: *mut WNF_DELIVERY_DESCRIPTOR,
        DescriptorSize: u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetWnfProcessNotificationEvent(NotificationEvent: HANDLE) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WORKERFACTORYINFOCLASS {
    WorkerFactoryTimeout = 0,
    WorkerFactoryRetryTimeout = 1,
    WorkerFactoryIdleTimeout = 2,
    WorkerFactoryBindingCount = 3,
    WorkerFactoryThreadMinimum = 4,
    WorkerFactoryThreadMaximum = 5,
    WorkerFactoryPaused = 6,
    WorkerFactoryBasicInformation = 7,
    WorkerFactoryAdjustThreadGoal = 8,
    WorkerFactoryCallbackType = 9,
    WorkerFactoryStackInformation = 10,
    WorkerFactoryThreadBasePriority = 11,
    WorkerFactoryTimeoutWaiters = 12,
    WorkerFactoryFlags = 13,
    WorkerFactoryThreadSoftMaximum = 14,
    WorkerFactoryThreadCpuSets = 15,
    MaxWorkerFactoryInfoClass = 16,
}
#[repr(C)]
pub struct WORKER_FACTORY_BASIC_INFORMATION {
    pub Timeout: i64,
    pub RetryTimeout: i64,
    pub IdleTimeout: i64,
    pub Paused: BOOLEAN,
    pub TimerSet: BOOLEAN,
    pub QueuedToExWorker: BOOLEAN,
    pub MayCreate: BOOLEAN,
    pub CreateInProgress: BOOLEAN,
    pub InsertedIntoQueue: BOOLEAN,
    pub Shutdown: BOOLEAN,
    pub BindingCount: u32,
    pub ThreadMinimum: u32,
    pub ThreadMaximum: u32,
    pub PendingWorkerCount: u32,
    pub WaitingWorkerCount: u32,
    pub TotalWorkerCount: u32,
    pub ReleaseCount: u32,
    pub InfiniteWaitGoal: i64,
    pub StartRoutine: *mut std::ffi::c_void,
    pub StartParameter: *mut std::ffi::c_void,
    pub ProcessId: HANDLE,
    pub StackReserve: usize,
    pub StackCommit: usize,
    pub LastThreadCreationStatus: NTSTATUS,
}
impl Default for WORKER_FACTORY_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for WORKER_FACTORY_BASIC_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "WORKER_FACTORY_BASIC_INFORMATION {{  }}")
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtCreateWorkerFactory(
        WorkerFactoryHandleReturn: *mut HANDLE,
        DesiredAccess: u32,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        CompletionPortHandle: HANDLE,
        WorkerProcessHandle: HANDLE,
        StartRoutine: *mut std::ffi::c_void,
        StartParameter: *mut std::ffi::c_void,
        MaxThreadCount: u32,
        StackReserve: usize,
        StackCommit: usize,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryInformationWorkerFactory(
        WorkerFactoryHandle: HANDLE,
        WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
        WorkerFactoryInformation: *mut std::ffi::c_void,
        WorkerFactoryInformationLength: u32,
        ReturnLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetInformationWorkerFactory(
        WorkerFactoryHandle: HANDLE,
        WorkerFactoryInformationClass: WORKERFACTORYINFOCLASS,
        WorkerFactoryInformation: *mut std::ffi::c_void,
        WorkerFactoryInformationLength: u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtShutdownWorkerFactory(
        WorkerFactoryHandle: HANDLE,
        PendingWorkerCount: *mut i32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtReleaseWorkerFactoryWorker(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtWorkerFactoryWorkerReady(WorkerFactoryHandle: HANDLE) -> NTSTATUS;
}
#[repr(C)]
pub struct WORKER_FACTORY_DEFERRED_WORK {
    pub AlpcSendMessage: *mut PORT_MESSAGE,
    pub AlpcSendMessagePort: *mut std::ffi::c_void,
    pub AlpcSendMessageFlags: u32,
    pub Flags: u32,
}
impl Default for WORKER_FACTORY_DEFERRED_WORK {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for WORKER_FACTORY_DEFERRED_WORK {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "WORKER_FACTORY_DEFERRED_WORK {{ AlpcSendMessage: {:?} }}",
            self.AlpcSendMessage
        )
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtWaitForWorkViaWorkerFactory(
        WorkerFactoryHandle: HANDLE,
        MiniPackets: *mut FILE_IO_COMPLETION_INFORMATION,
        Count: u32,
        PacketsReturned: *mut u32,
        DeferredWork: *mut WORKER_FACTORY_DEFERRED_WORK,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQuerySystemTime(SystemTime: *mut i64) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetSystemTime(SystemTime: *mut i64, PreviousTime: *mut i64) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryTimerResolution(
        MaximumTime: *mut u32,
        MinimumTime: *mut u32,
        CurrentTime: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetTimerResolution(
        DesiredTime: u32,
        SetResolution: BOOLEAN,
        ActualTime: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryPerformanceCounter(
        PerformanceCounter: *mut i64,
        PerformanceFrequency: *mut i64,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryAuxiliaryCounterFrequency(AuxiliaryCounterFrequency: *mut i64) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtConvertBetweenAuxiliaryCounterAndPerformanceCounter(
        AuxiliaryCounterValue: *mut i64,
        PerformanceCounterValue: *mut i64,
        PerformanceOrAuxiliaryCounterValue: *mut i64,
        ConversionError: *mut i64,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtAllocateLocallyUniqueId(Luid: *mut LUID) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetUuidSeed(Seed: *mut i8) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtAllocateUuids(
        Time: *mut u64,
        Range: *mut u32,
        Sequence: *mut u32,
        Seed: *mut i8,
    ) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemProcessInformation = 5,
    SystemCallCountInformation = 6,
    SystemDeviceInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemFlagsInformation = 9,
    SystemCallTimeInformation = 10,
    SystemModuleInformation = 11,
    SystemLocksInformation = 12,
    SystemStackTraceInformation = 13,
    SystemPagedPoolInformation = 14,
    SystemNonPagedPoolInformation = 15,
    SystemHandleInformation = 16,
    SystemObjectInformation = 17,
    SystemPageFileInformation = 18,
    SystemVdmInstemulInformation = 19,
    SystemVdmBopInformation = 20,
    SystemFileCacheInformation = 21,
    SystemPoolTagInformation = 22,
    SystemInterruptInformation = 23,
    SystemDpcBehaviorInformation = 24,
    SystemFullMemoryInformation = 25,
    SystemLoadGdiDriverInformation = 26,
    SystemUnloadGdiDriverInformation = 27,
    SystemTimeAdjustmentInformation = 28,
    SystemSummaryMemoryInformation = 29,
    SystemMirrorMemoryInformation = 30,
    SystemPerformanceTraceInformation = 31,
    SystemObsolete0 = 32,
    SystemExceptionInformation = 33,
    SystemCrashDumpStateInformation = 34,
    SystemKernelDebuggerInformation = 35,
    SystemContextSwitchInformation = 36,
    SystemRegistryQuotaInformation = 37,
    SystemExtendServiceTableInformation = 38,
    SystemPrioritySeperation = 39,
    SystemVerifierAddDriverInformation = 40,
    SystemVerifierRemoveDriverInformation = 41,
    SystemProcessorIdleInformation = 42,
    SystemLegacyDriverInformation = 43,
    SystemCurrentTimeZoneInformation = 44,
    SystemLookasideInformation = 45,
    SystemTimeSlipNotification = 46,
    SystemSessionCreate = 47,
    SystemSessionDetach = 48,
    SystemSessionInformation = 49,
    SystemRangeStartInformation = 50,
    SystemVerifierInformation = 51,
    SystemVerifierThunkExtend = 52,
    SystemSessionProcessInformation = 53,
    SystemLoadGdiDriverInSystemSpace = 54,
    SystemNumaProcessorMap = 55,
    SystemPrefetcherInformation = 56,
    SystemExtendedProcessInformation = 57,
    SystemRecommendedSharedDataAlignment = 58,
    SystemComPlusPackage = 59,
    SystemNumaAvailableMemory = 60,
    SystemProcessorPowerInformation = 61,
    SystemEmulationBasicInformation = 62,
    SystemEmulationProcessorInformation = 63,
    SystemExtendedHandleInformation = 64,
    SystemLostDelayedWriteInformation = 65,
    SystemBigPoolInformation = 66,
    SystemSessionPoolTagInformation = 67,
    SystemSessionMappedViewInformation = 68,
    SystemHotpatchInformation = 69,
    SystemObjectSecurityMode = 70,
    SystemWatchdogTimerHandler = 71,
    SystemWatchdogTimerInformation = 72,
    SystemLogicalProcessorInformation = 73,
    SystemWow64SharedInformationObsolete = 74,
    SystemRegisterFirmwareTableInformationHandler = 75,
    SystemFirmwareTableInformation = 76,
    SystemModuleInformationEx = 77,
    SystemVerifierTriageInformation = 78,
    SystemSuperfetchInformation = 79,
    SystemMemoryListInformation = 80,
    SystemFileCacheInformationEx = 81,
    SystemThreadPriorityClientIdInformation = 82,
    SystemProcessorIdleCycleTimeInformation = 83,
    SystemVerifierCancellationInformation = 84,
    SystemProcessorPowerInformationEx = 85,
    SystemRefTraceInformation = 86,
    SystemSpecialPoolInformation = 87,
    SystemProcessIdInformation = 88,
    SystemErrorPortInformation = 89,
    SystemBootEnvironmentInformation = 90,
    SystemHypervisorInformation = 91,
    SystemVerifierInformationEx = 92,
    SystemTimeZoneInformation = 93,
    SystemImageFileExecutionOptionsInformation = 94,
    SystemCoverageInformation = 95,
    SystemPrefetchPatchInformation = 96,
    SystemVerifierFaultsInformation = 97,
    SystemSystemPartitionInformation = 98,
    SystemSystemDiskInformation = 99,
    SystemProcessorPerformanceDistribution = 100,
    SystemNumaProximityNodeInformation = 101,
    SystemDynamicTimeZoneInformation = 102,
    SystemCodeIntegrityInformation = 103,
    SystemProcessorMicrocodeUpdateInformation = 104,
    SystemProcessorBrandString = 105,
    SystemVirtualAddressInformation = 106,
    SystemLogicalProcessorAndGroupInformation = 107,
    SystemProcessorCycleTimeInformation = 108,
    SystemStoreInformation = 109,
    SystemRegistryAppendString = 110,
    SystemAitSamplingValue = 111,
    SystemVhdBootInformation = 112,
    SystemCpuQuotaInformation = 113,
    SystemNativeBasicInformation = 114,
    SystemErrorPortTimeouts = 115,
    SystemLowPriorityIoInformation = 116,
    SystemTpmBootEntropyInformation = 117,
    SystemVerifierCountersInformation = 118,
    SystemPagedPoolInformationEx = 119,
    SystemSystemPtesInformationEx = 120,
    SystemNodeDistanceInformation = 121,
    SystemAcpiAuditInformation = 122,
    SystemBasicPerformanceInformation = 123,
    SystemQueryPerformanceCounterInformation = 124,
    SystemSessionBigPoolInformation = 125,
    SystemBootGraphicsInformation = 126,
    SystemScrubPhysicalMemoryInformation = 127,
    SystemBadPageInformation = 128,
    SystemProcessorProfileControlArea = 129,
    SystemCombinePhysicalMemoryInformation = 130,
    SystemEntropyInterruptTimingInformation = 131,
    SystemConsoleInformation = 132,
    SystemPlatformBinaryInformation = 133,
    SystemPolicyInformation = 134,
    SystemHypervisorProcessorCountInformation = 135,
    SystemDeviceDataInformation = 136,
    SystemDeviceDataEnumerationInformation = 137,
    SystemMemoryTopologyInformation = 138,
    SystemMemoryChannelInformation = 139,
    SystemBootLogoInformation = 140,
    SystemProcessorPerformanceInformationEx = 141,
    SystemCriticalProcessErrorLogInformation = 142,
    SystemSecureBootPolicyInformation = 143,
    SystemPageFileInformationEx = 144,
    SystemSecureBootInformation = 145,
    SystemEntropyInterruptTimingRawInformation = 146,
    SystemPortableWorkspaceEfiLauncherInformation = 147,
    SystemFullProcessInformation = 148,
    SystemKernelDebuggerInformationEx = 149,
    SystemBootMetadataInformation = 150,
    SystemSoftRebootInformation = 151,
    SystemElamCertificateInformation = 152,
    SystemOfflineDumpConfigInformation = 153,
    SystemProcessorFeaturesInformation = 154,
    SystemRegistryReconciliationInformation = 155,
    SystemEdidInformation = 156,
    SystemManufacturingInformation = 157,
    SystemEnergyEstimationConfigInformation = 158,
    SystemHypervisorDetailInformation = 159,
    SystemProcessorCycleStatsInformation = 160,
    SystemVmGenerationCountInformation = 161,
    SystemTrustedPlatformModuleInformation = 162,
    SystemKernelDebuggerFlags = 163,
    SystemCodeIntegrityPolicyInformation = 164,
    SystemIsolatedUserModeInformation = 165,
    SystemHardwareSecurityTestInterfaceResultsInformation = 166,
    SystemSingleModuleInformation = 167,
    SystemAllowedCpuSetsInformation = 168,
    SystemVsmProtectionInformation = 169,
    SystemInterruptCpuSetsInformation = 170,
    SystemSecureBootPolicyFullInformation = 171,
    SystemCodeIntegrityPolicyFullInformation = 172,
    SystemAffinitizedInterruptProcessorInformation = 173,
    SystemRootSiloInformation = 174,
    SystemCpuSetInformation = 175,
    SystemCpuSetTagInformation = 176,
    SystemWin32WerStartCallout = 177,
    SystemSecureKernelProfileInformation = 178,
    SystemCodeIntegrityPlatformManifestInformation = 179,
    SystemInterruptSteeringInformation = 180,
    SystemSupportedProcessorArchitectures = 181,
    SystemMemoryUsageInformation = 182,
    SystemCodeIntegrityCertificateInformation = 183,
    SystemPhysicalMemoryInformation = 184,
    SystemControlFlowTransition = 185,
    SystemKernelDebuggingAllowed = 186,
    SystemActivityModerationExeState = 187,
    SystemActivityModerationUserSettings = 188,
    SystemCodeIntegrityPoliciesFullInformation = 189,
    SystemCodeIntegrityUnlockInformation = 190,
    SystemIntegrityQuotaInformation = 191,
    SystemFlushInformation = 192,
    SystemProcessorIdleMaskInformation = 193,
    SystemSecureDumpEncryptionInformation = 194,
    SystemWriteConstraintInformation = 195,
    SystemKernelVaShadowInformation = 196,
    SystemHypervisorSharedPageInformation = 197,
    SystemFirmwareBootPerformanceInformation = 198,
    SystemCodeIntegrityVerificationInformation = 199,
    SystemFirmwarePartitionInformation = 200,
    SystemSpeculationControlInformation = 201,
    SystemDmaGuardPolicyInformation = 202,
    SystemEnclaveLaunchControlInformation = 203,
    SystemWorkloadAllowedCpuSetsInformation = 204,
    SystemCodeIntegrityUnlockModeInformation = 205,
    SystemLeapSecondInformation = 206,
    SystemFlags2Information = 207,
    SystemSecurityModelInformation = 208,
    SystemCodeIntegritySyntheticCacheInformation = 209,
    SystemFeatureConfigurationInformation = 210,
    SystemFeatureConfigurationSectionInformation = 211,
    SystemFeatureUsageSubscriptionInformation = 212,
    SystemSecureSpeculationControlInformation = 213,
    SystemSpacesBootInformation = 214,
    SystemFwRamdiskInformation = 215,
    SystemWheaIpmiHardwareInformation = 216,
    SystemDifSetRuleClassInformation = 217,
    SystemDifClearRuleClassInformation = 218,
    SystemDifApplyPluginVerificationOnDriver = 219,
    SystemDifRemovePluginVerificationOnDriver = 220,
    SystemShadowStackInformation = 221,
    SystemBuildVersionInformation = 222,
    SystemPoolLimitInformation = 223,
    SystemCodeIntegrityAddDynamicStore = 224,
    SystemCodeIntegrityClearDynamicStores = 225,
    SystemDifPoolTrackingInformation = 226,
    SystemPoolZeroingInformation = 227,
    SystemDpcWatchdogInformation = 228,
    SystemDpcWatchdogInformation2 = 229,
    SystemSupportedProcessorArchitectures2 = 230,
    SystemSingleProcessorRelationshipInformation = 231,
    SystemXfgCheckFailureInformation = 232,
    SystemIommuStateInformation = 233,
    SystemHypervisorMinrootInformation = 234,
    SystemHypervisorBootPagesInformation = 235,
    SystemPointerAuthInformation = 236,
    SystemSecureKernelDebuggerInformation = 237,
    SystemOriginalImageFeatureInformation = 238,
    MaxSystemInfoClass = 239,
}
#[repr(C)]
pub struct SYSTEM_BASIC_INFORMATION {
    pub Reserved: u32,
    pub TimerResolution: u32,
    pub PageSize: u32,
    pub NumberOfPhysicalPages: u32,
    pub LowestPhysicalPageNumber: u32,
    pub HighestPhysicalPageNumber: u32,
    pub AllocationGranularity: u32,
    pub MinimumUserModeAddress: usize,
    pub MaximumUserModeAddress: usize,
    pub ActiveProcessorsAffinityMask: usize,
    pub NumberOfProcessors: i8,
}
impl Default for SYSTEM_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BASIC_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_BASIC_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_INFORMATION {
    pub ProcessorArchitecture: u16,
    pub ProcessorLevel: u16,
    pub ProcessorRevision: u16,
    pub MaximumProcessors: u16,
    pub ProcessorFeatureBits: u32,
}
impl Default for SYSTEM_PROCESSOR_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESSOR_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PERFORMANCE_INFORMATION {
    pub IdleProcessTime: i64,
    pub IoReadTransferCount: i64,
    pub IoWriteTransferCount: i64,
    pub IoOtherTransferCount: i64,
    pub IoReadOperationCount: u32,
    pub IoWriteOperationCount: u32,
    pub IoOtherOperationCount: u32,
    pub AvailablePages: u32,
    pub CommittedPages: u32,
    pub CommitLimit: u32,
    pub PeakCommitment: u32,
    pub PageFaultCount: u32,
    pub CopyOnWriteCount: u32,
    pub TransitionCount: u32,
    pub CacheTransitionCount: u32,
    pub DemandZeroCount: u32,
    pub PageReadCount: u32,
    pub PageReadIoCount: u32,
    pub CacheReadCount: u32,
    pub CacheIoCount: u32,
    pub DirtyPagesWriteCount: u32,
    pub DirtyWriteIoCount: u32,
    pub MappedPagesWriteCount: u32,
    pub MappedWriteIoCount: u32,
    pub PagedPoolPages: u32,
    pub NonPagedPoolPages: u32,
    pub PagedPoolAllocs: u32,
    pub PagedPoolFrees: u32,
    pub NonPagedPoolAllocs: u32,
    pub NonPagedPoolFrees: u32,
    pub FreeSystemPtes: u32,
    pub ResidentSystemCodePage: u32,
    pub TotalSystemDriverPages: u32,
    pub TotalSystemCodePages: u32,
    pub NonPagedPoolLookasideHits: u32,
    pub PagedPoolLookasideHits: u32,
    pub AvailablePagedPoolPages: u32,
    pub ResidentSystemCachePage: u32,
    pub ResidentPagedPoolPage: u32,
    pub ResidentSystemDriverPage: u32,
    pub CcFastReadNoWait: u32,
    pub CcFastReadWait: u32,
    pub CcFastReadResourceMiss: u32,
    pub CcFastReadNotPossible: u32,
    pub CcFastMdlReadNoWait: u32,
    pub CcFastMdlReadWait: u32,
    pub CcFastMdlReadResourceMiss: u32,
    pub CcFastMdlReadNotPossible: u32,
    pub CcMapDataNoWait: u32,
    pub CcMapDataWait: u32,
    pub CcMapDataNoWaitMiss: u32,
    pub CcMapDataWaitMiss: u32,
    pub CcPinMappedDataCount: u32,
    pub CcPinReadNoWait: u32,
    pub CcPinReadWait: u32,
    pub CcPinReadNoWaitMiss: u32,
    pub CcPinReadWaitMiss: u32,
    pub CcCopyReadNoWait: u32,
    pub CcCopyReadWait: u32,
    pub CcCopyReadNoWaitMiss: u32,
    pub CcCopyReadWaitMiss: u32,
    pub CcMdlReadNoWait: u32,
    pub CcMdlReadWait: u32,
    pub CcMdlReadNoWaitMiss: u32,
    pub CcMdlReadWaitMiss: u32,
    pub CcReadAheadIos: u32,
    pub CcLazyWriteIos: u32,
    pub CcLazyWritePages: u32,
    pub CcDataFlushes: u32,
    pub CcDataPages: u32,
    pub ContextSwitches: u32,
    pub FirstLevelTbFills: u32,
    pub SecondLevelTbFills: u32,
    pub SystemCalls: u32,
    pub CcTotalDirtyPages: u64,
    pub CcDirtyPageThreshold: u64,
    pub ResidentAvailablePages: i64,
    pub SharedCommittedPages: u64,
}
impl Default for SYSTEM_PERFORMANCE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PERFORMANCE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PERFORMANCE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_TIMEOFDAY_INFORMATION {
    pub BootTime: i64,
    pub CurrentTime: i64,
    pub TimeZoneBias: i64,
    pub TimeZoneId: u32,
    pub Reserved: u32,
    pub BootTimeBias: u64,
    pub SleepTimeBias: u64,
}
impl Default for SYSTEM_TIMEOFDAY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_TIMEOFDAY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_TIMEOFDAY_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_THREAD_INFORMATION {
    pub KernelTime: i64,
    pub UserTime: i64,
    pub CreateTime: i64,
    pub WaitTime: u32,
    pub StartAddress: *mut std::ffi::c_void,
    pub ClientId: CLIENT_ID,
    pub Priority: i32,
    pub BasePriority: i32,
    pub ContextSwitches: u32,
    pub ThreadState: KTHREAD_STATE,
    pub WaitReason: KWAIT_REASON,
}
impl Default for SYSTEM_THREAD_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_THREAD_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_THREAD_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_EXTENDED_THREAD_INFORMATION {
    pub ThreadInfo: SYSTEM_THREAD_INFORMATION,
    pub StackBase: *mut std::ffi::c_void,
    pub StackLimit: *mut std::ffi::c_void,
    pub Win32StartAddress: *mut std::ffi::c_void,
    pub TebBase: *mut TEB,
    pub Reserved2: usize,
    pub Reserved3: usize,
    pub Reserved4: usize,
}
impl Default for SYSTEM_EXTENDED_THREAD_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_EXTENDED_THREAD_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_EXTENDED_THREAD_INFORMATION {{ ThreadInfo: {:?}, TebBase: {:?} }}",
            self.ThreadInfo, self.TebBase
        )
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESS_INFORMATION {
    pub NextEntryOffset: u32,
    pub NumberOfThreads: u32,
    pub WorkingSetPrivateSize: i64,
    pub HardFaultCount: u32,
    pub NumberOfThreadsHighWatermark: u32,
    pub CycleTime: u64,
    pub CreateTime: i64,
    pub UserTime: i64,
    pub KernelTime: i64,
    pub ImageName: UNICODE_STRING,
    pub BasePriority: i32,
    pub UniqueProcessId: HANDLE,
    pub InheritedFromUniqueProcessId: HANDLE,
    pub HandleCount: u32,
    pub SessionId: u32,
    pub UniqueProcessKey: usize,
    pub PeakVirtualSize: usize,
    pub VirtualSize: usize,
    pub PageFaultCount: u32,
    pub PeakWorkingSetSize: usize,
    pub WorkingSetSize: usize,
    pub QuotaPeakPagedPoolUsage: usize,
    pub QuotaPagedPoolUsage: usize,
    pub QuotaPeakNonPagedPoolUsage: usize,
    pub QuotaNonPagedPoolUsage: usize,
    pub PagefileUsage: usize,
    pub PeakPagefileUsage: usize,
    pub PrivatePageCount: usize,
    pub ReadOperationCount: i64,
    pub WriteOperationCount: i64,
    pub OtherOperationCount: i64,
    pub ReadTransferCount: i64,
    pub WriteTransferCount: i64,
    pub OtherTransferCount: i64,
    pub Threads: [SYSTEM_THREAD_INFORMATION; 1usize],
}
impl Default for SYSTEM_PROCESS_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESS_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PROCESS_INFORMATION {{ Threads: {:?} }}",
            self.Threads
        )
    }
}
#[repr(C)]
pub struct SYSTEM_CALL_COUNT_INFORMATION {
    pub Length: u32,
    pub NumberOfTables: u32,
}
impl Default for SYSTEM_CALL_COUNT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CALL_COUNT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_CALL_COUNT_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_DEVICE_INFORMATION {
    pub NumberOfDisks: u32,
    pub NumberOfFloppies: u32,
    pub NumberOfCdRoms: u32,
    pub NumberOfTapes: u32,
    pub NumberOfSerialPorts: u32,
    pub NumberOfParallelPorts: u32,
}
impl Default for SYSTEM_DEVICE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_DEVICE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_DEVICE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    pub IdleTime: i64,
    pub KernelTime: i64,
    pub UserTime: i64,
    pub DpcTime: i64,
    pub InterruptTime: i64,
    pub InterruptCount: u32,
}
impl Default for SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_FLAGS_INFORMATION {
    pub Flags: u32,
}
impl Default for SYSTEM_FLAGS_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_FLAGS_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_FLAGS_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_CALL_TIME_INFORMATION {
    pub Length: u32,
    pub TotalCalls: u32,
    pub TimeOfCalls: [i64; 1usize],
}
impl Default for SYSTEM_CALL_TIME_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CALL_TIME_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_CALL_TIME_INFORMATION {{ TimeOfCalls: {:?} }}",
            self.TimeOfCalls
        )
    }
}
#[repr(C)]
pub struct RTL_PROCESS_LOCK_INFORMATION {
    pub Address: *mut std::ffi::c_void,
    pub Type: u16,
    pub CreatorBackTraceIndex: u16,
    pub OwningThread: HANDLE,
    pub LockCount: i32,
    pub ContentionCount: u32,
    pub EntryCount: u32,
    pub RecursionCount: i32,
    pub NumberOfWaitingShared: u32,
    pub NumberOfWaitingExclusive: u32,
}
impl Default for RTL_PROCESS_LOCK_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for RTL_PROCESS_LOCK_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RTL_PROCESS_LOCK_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct RTL_PROCESS_LOCKS {
    pub NumberOfLocks: u32,
    pub Locks: [RTL_PROCESS_LOCK_INFORMATION; 1usize],
}
impl Default for RTL_PROCESS_LOCKS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for RTL_PROCESS_LOCKS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RTL_PROCESS_LOCKS {{ Locks: {:?} }}", self.Locks)
    }
}
#[repr(C)]
pub struct RTL_PROCESS_BACKTRACE_INFORMATION {
    pub SymbolicBackTrace: *mut i8,
    pub TraceCount: u32,
    pub Index: u16,
    pub Depth: u16,
    pub BackTrace: [*mut std::ffi::c_void; 32usize],
}
impl Default for RTL_PROCESS_BACKTRACE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for RTL_PROCESS_BACKTRACE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "RTL_PROCESS_BACKTRACE_INFORMATION {{ BackTrace: {:?} }}",
            self.BackTrace
        )
    }
}
#[repr(C)]
pub struct RTL_PROCESS_BACKTRACES {
    pub CommittedMemory: u32,
    pub ReservedMemory: u32,
    pub NumberOfBackTraceLookups: u32,
    pub NumberOfBackTraces: u32,
    pub BackTraces: [RTL_PROCESS_BACKTRACE_INFORMATION; 1usize],
}
impl Default for RTL_PROCESS_BACKTRACES {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for RTL_PROCESS_BACKTRACES {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "RTL_PROCESS_BACKTRACES {{ BackTraces: {:?} }}",
            self.BackTraces
        )
    }
}
#[repr(C)]
pub struct SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    pub UniqueProcessId: u16,
    pub CreatorBackTraceIndex: u16,
    pub ObjectTypeIndex: u8,
    pub HandleAttributes: u8,
    pub HandleValue: u16,
    pub Object: *mut std::ffi::c_void,
    pub GrantedAccess: u32,
}
impl Default for SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_HANDLE_TABLE_ENTRY_INFO {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_HANDLE_INFORMATION {
    pub NumberOfHandles: u32,
    pub Handles: [SYSTEM_HANDLE_TABLE_ENTRY_INFO; 1usize],
}
impl Default for SYSTEM_HANDLE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HANDLE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_HANDLE_INFORMATION {{ Handles: {:?} }}",
            self.Handles
        )
    }
}
#[repr(C)]
pub struct SYSTEM_OBJECTTYPE_INFORMATION {
    pub NextEntryOffset: u32,
    pub NumberOfObjects: u32,
    pub NumberOfHandles: u32,
    pub TypeIndex: u32,
    pub InvalidAttributes: u32,
    pub GenericMapping: GENERIC_MAPPING,
    pub ValidAccessMask: u32,
    pub PoolType: u32,
    pub SecurityRequired: BOOLEAN,
    pub WaitableObject: BOOLEAN,
    pub TypeName: UNICODE_STRING,
}
impl Default for SYSTEM_OBJECTTYPE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_OBJECTTYPE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_OBJECTTYPE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_OBJECT_INFORMATION {
    pub NextEntryOffset: u32,
    pub Object: *mut std::ffi::c_void,
    pub CreatorUniqueProcess: HANDLE,
    pub CreatorBackTraceIndex: u16,
    pub Flags: u16,
    pub PointerCount: i32,
    pub HandleCount: i32,
    pub PagedPoolCharge: u32,
    pub NonPagedPoolCharge: u32,
    pub ExclusiveProcessId: HANDLE,
    pub SecurityDescriptor: *mut std::ffi::c_void,
    pub NameInfo: UNICODE_STRING,
}
impl Default for SYSTEM_OBJECT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_OBJECT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_OBJECT_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PAGEFILE_INFORMATION {
    pub NextEntryOffset: u32,
    pub TotalSize: u32,
    pub TotalInUse: u32,
    pub PeakUsage: u32,
    pub PageFileName: UNICODE_STRING,
}
impl Default for SYSTEM_PAGEFILE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PAGEFILE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PAGEFILE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_VDM_INSTEMUL_INFO {
    pub SegmentNotPresent: u32,
    pub VdmOpcode0F: u32,
    pub OpcodeESPrefix: u32,
    pub OpcodeCSPrefix: u32,
    pub OpcodeSSPrefix: u32,
    pub OpcodeDSPrefix: u32,
    pub OpcodeFSPrefix: u32,
    pub OpcodeGSPrefix: u32,
    pub OpcodeOPER32Prefix: u32,
    pub OpcodeADDR32Prefix: u32,
    pub OpcodeINSB: u32,
    pub OpcodeINSW: u32,
    pub OpcodeOUTSB: u32,
    pub OpcodeOUTSW: u32,
    pub OpcodePUSHF: u32,
    pub OpcodePOPF: u32,
    pub OpcodeINTnn: u32,
    pub OpcodeINTO: u32,
    pub OpcodeIRET: u32,
    pub OpcodeINBimm: u32,
    pub OpcodeINWimm: u32,
    pub OpcodeOUTBimm: u32,
    pub OpcodeOUTWimm: u32,
    pub OpcodeINB: u32,
    pub OpcodeINW: u32,
    pub OpcodeOUTB: u32,
    pub OpcodeOUTW: u32,
    pub OpcodeLOCKPrefix: u32,
    pub OpcodeREPNEPrefix: u32,
    pub OpcodeREPPrefix: u32,
    pub OpcodeHLT: u32,
    pub OpcodeCLI: u32,
    pub OpcodeSTI: u32,
    pub BopCount: u32,
}
impl Default for SYSTEM_VDM_INSTEMUL_INFO {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VDM_INSTEMUL_INFO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_VDM_INSTEMUL_INFO {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_FILECACHE_INFORMATION {
    pub CurrentSize: usize,
    pub PeakSize: usize,
    pub PageFaultCount: u32,
    pub MinimumWorkingSet: usize,
    pub MaximumWorkingSet: usize,
    pub CurrentSizeIncludingTransitionInPages: usize,
    pub PeakSizeIncludingTransitionInPages: usize,
    pub TransitionRePurposeCount: u32,
    pub Flags: u32,
}
impl Default for SYSTEM_FILECACHE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_FILECACHE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_FILECACHE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_BASIC_WORKING_SET_INFORMATION {
    pub CurrentSize: usize,
    pub PeakSize: usize,
    pub PageFaultCount: u32,
}
impl Default for SYSTEM_BASIC_WORKING_SET_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BASIC_WORKING_SET_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_BASIC_WORKING_SET_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_POOLTAG {
    pub Anonymous1: SYSTEM_POOLTAG_1,
    pub PagedAllocs: u32,
    pub PagedFrees: u32,
    pub PagedUsed: usize,
    pub NonPagedAllocs: u32,
    pub NonPagedFrees: u32,
    pub NonPagedUsed: usize,
}
#[repr(C)]
pub struct SYSTEM_POOLTAG_1 {
    pub Tag: UnionField<[u8; 4usize]>,
    pub TagUlong: UnionField<u32>,
    pub union_field: u32,
}
impl Default for SYSTEM_POOLTAG_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POOLTAG_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_POOLTAG_1 {{ union }}")
    }
}
impl Default for SYSTEM_POOLTAG {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POOLTAG {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_POOLTAG {{ Anonymous1: {:?} }}", self.Anonymous1)
    }
}
#[repr(C)]
pub struct SYSTEM_POOLTAG_INFORMATION {
    pub Count: u32,
    pub TagInfo: [SYSTEM_POOLTAG; 1usize],
}
impl Default for SYSTEM_POOLTAG_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POOLTAG_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_POOLTAG_INFORMATION {{ TagInfo: {:?} }}",
            self.TagInfo
        )
    }
}
#[repr(C)]
pub struct SYSTEM_INTERRUPT_INFORMATION {
    pub ContextSwitches: u32,
    pub DpcCount: u32,
    pub DpcRate: u32,
    pub TimeIncrement: u32,
    pub DpcBypassCount: u32,
    pub ApcBypassCount: u32,
}
impl Default for SYSTEM_INTERRUPT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_INTERRUPT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_INTERRUPT_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_DPC_BEHAVIOR_INFORMATION {
    pub Spare: u32,
    pub DpcQueueDepth: u32,
    pub MinimumDpcRate: u32,
    pub AdjustDpcThreshold: u32,
    pub IdealDpcRate: u32,
}
impl Default for SYSTEM_DPC_BEHAVIOR_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_DPC_BEHAVIOR_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_DPC_BEHAVIOR_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
    pub TimeAdjustment: u32,
    pub TimeIncrement: u32,
    pub Enable: BOOLEAN,
}
impl Default for SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_QUERY_TIME_ADJUST_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE {
    pub TimeAdjustment: u64,
    pub TimeIncrement: u64,
    pub Enable: BOOLEAN,
}
impl Default for SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_QUERY_TIME_ADJUST_INFORMATION_PRECISE {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_SET_TIME_ADJUST_INFORMATION {
    pub TimeAdjustment: u32,
    pub Enable: BOOLEAN,
}
impl Default for SYSTEM_SET_TIME_ADJUST_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SET_TIME_ADJUST_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SET_TIME_ADJUST_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE {
    pub TimeAdjustment: u64,
    pub Enable: BOOLEAN,
}
impl Default for SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SET_TIME_ADJUST_INFORMATION_PRECISE {{  }}")
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EVENT_TRACE_INFORMATION_CLASS {
    EventTraceKernelVersionInformation = 0,
    EventTraceGroupMaskInformation = 1,
    EventTracePerformanceInformation = 2,
    EventTraceTimeProfileInformation = 3,
    EventTraceSessionSecurityInformation = 4,
    EventTraceSpinlockInformation = 5,
    EventTraceStackTracingInformation = 6,
    EventTraceExecutiveResourceInformation = 7,
    EventTraceHeapTracingInformation = 8,
    EventTraceHeapSummaryTracingInformation = 9,
    EventTracePoolTagFilterInformation = 10,
    EventTracePebsTracingInformation = 11,
    EventTraceProfileConfigInformation = 12,
    EventTraceProfileSourceListInformation = 13,
    EventTraceProfileEventListInformation = 14,
    EventTraceProfileCounterListInformation = 15,
    EventTraceStackCachingInformation = 16,
    EventTraceObjectTypeFilterInformation = 17,
    EventTraceSoftRestartInformation = 18,
    EventTraceLastBranchConfigurationInformation = 19,
    EventTraceLastBranchEventListInformation = 20,
    EventTraceProfileSourceAddInformation = 21,
    EventTraceProfileSourceRemoveInformation = 22,
    EventTraceProcessorTraceConfigurationInformation = 23,
    EventTraceProcessorTraceEventListInformation = 24,
    EventTraceCoverageSamplerInformation = 25,
    EventTraceUnifiedStackCachingInformation = 26,
    MaxEventTraceInfoClass = 27,
}
#[repr(C)]
pub struct TRACE_ENABLE_FLAG_EXTENSION {
    pub Offset: u16,
    pub Length: u8,
    pub Flag: u8,
}
impl Default for TRACE_ENABLE_FLAG_EXTENSION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for TRACE_ENABLE_FLAG_EXTENSION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TRACE_ENABLE_FLAG_EXTENSION {{  }}")
    }
}
#[repr(C)]
pub struct TRACE_ENABLE_FLAG_EXT_HEADER {
    pub Length: u16,
    pub Items: u16,
}
impl Default for TRACE_ENABLE_FLAG_EXT_HEADER {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for TRACE_ENABLE_FLAG_EXT_HEADER {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TRACE_ENABLE_FLAG_EXT_HEADER {{  }}")
    }
}
#[repr(C)]
pub struct TRACE_ENABLE_FLAG_EXT_ITEM {
    pub Offset: u16,
    pub Type: u16,
}
impl Default for TRACE_ENABLE_FLAG_EXT_ITEM {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for TRACE_ENABLE_FLAG_EXT_ITEM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TRACE_ENABLE_FLAG_EXT_ITEM {{  }}")
    }
}
#[repr(C)]
pub struct ETW_STACK_CACHING_CONFIG {
    pub CacheSize: u32,
    pub BucketCount: u32,
}
impl Default for ETW_STACK_CACHING_CONFIG {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ETW_STACK_CACHING_CONFIG {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ETW_STACK_CACHING_CONFIG {{  }}")
    }
}
#[repr(C)]
pub struct PERFINFO_GROUPMASK {
    pub Masks: [u32; 8usize],
}
impl Default for PERFINFO_GROUPMASK {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PERFINFO_GROUPMASK {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PERFINFO_GROUPMASK {{ Masks: {:?} }}", self.Masks)
    }
}
#[repr(C)]
pub struct EVENT_TRACE_VERSION_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub EventTraceKernelVersion: u32,
}
impl Default for EVENT_TRACE_VERSION_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_VERSION_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_VERSION_INFORMATION {{ EventTraceInformationClass: {:?} }}",
            self.EventTraceInformationClass
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_GROUPMASK_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub TraceHandle: TRACEHANDLE,
    pub EventTraceGroupMasks: PERFINFO_GROUPMASK,
}
impl Default for EVENT_TRACE_GROUPMASK_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_GROUPMASK_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_GROUPMASK_INFORMATION {{ EventTraceInformationClass: {:?}, EventTraceGroupMasks: {:?} }}",
            self.EventTraceInformationClass, self.EventTraceGroupMasks
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_PERFORMANCE_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub LogfileBytesWritten: i64,
}
impl Default for EVENT_TRACE_PERFORMANCE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_PERFORMANCE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_PERFORMANCE_INFORMATION {{ EventTraceInformationClass: {:?} }}",
            self.EventTraceInformationClass
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_TIME_PROFILE_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub ProfileInterval: u32,
}
impl Default for EVENT_TRACE_TIME_PROFILE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_TIME_PROFILE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_TIME_PROFILE_INFORMATION {{ EventTraceInformationClass: {:?} }}",
            self.EventTraceInformationClass
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_SESSION_SECURITY_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub SecurityInformation: u32,
    pub TraceHandle: TRACEHANDLE,
    pub SecurityDescriptor: [u8; 1usize],
}
impl Default for EVENT_TRACE_SESSION_SECURITY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_SESSION_SECURITY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_SESSION_SECURITY_INFORMATION {{ EventTraceInformationClass: {:?}, SecurityDescriptor: {:?} }}",
            self.EventTraceInformationClass, self.SecurityDescriptor
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_SPINLOCK_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub SpinLockSpinThreshold: u32,
    pub SpinLockAcquireSampleRate: u32,
    pub SpinLockContentionSampleRate: u32,
    pub SpinLockHoldThreshold: u32,
}
impl Default for EVENT_TRACE_SPINLOCK_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_SPINLOCK_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_SPINLOCK_INFORMATION {{ EventTraceInformationClass: {:?} }}",
            self.EventTraceInformationClass
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_SYSTEM_EVENT_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub TraceHandle: TRACEHANDLE,
    pub HookId: [u32; 1usize],
}
impl Default for EVENT_TRACE_SYSTEM_EVENT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_SYSTEM_EVENT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_SYSTEM_EVENT_INFORMATION {{ EventTraceInformationClass: {:?}, HookId: {:?} }}",
            self.EventTraceInformationClass, self.HookId
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub ReleaseSamplingRate: u32,
    pub ContentionSamplingRate: u32,
    pub NumberOfExcessiveTimeouts: u32,
}
impl Default for EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_EXECUTIVE_RESOURCE_INFORMATION {{ EventTraceInformationClass: {:?} }}",
            self.EventTraceInformationClass
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_HEAP_TRACING_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub ProcessId: [u32; 1usize],
}
impl Default for EVENT_TRACE_HEAP_TRACING_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_HEAP_TRACING_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_HEAP_TRACING_INFORMATION {{ EventTraceInformationClass: {:?}, ProcessId: {:?} }}",
            self.EventTraceInformationClass, self.ProcessId
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_TAG_FILTER_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub TraceHandle: TRACEHANDLE,
    pub Filter: [u32; 1usize],
}
impl Default for EVENT_TRACE_TAG_FILTER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_TAG_FILTER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_TAG_FILTER_INFORMATION {{ EventTraceInformationClass: {:?}, Filter: {:?} }}",
            self.EventTraceInformationClass, self.Filter
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_PROFILE_COUNTER_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub TraceHandle: TRACEHANDLE,
    pub ProfileSource: [u32; 1usize],
}
impl Default for EVENT_TRACE_PROFILE_COUNTER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_PROFILE_COUNTER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_PROFILE_COUNTER_INFORMATION {{ EventTraceInformationClass: {:?}, ProfileSource: {:?} }}",
            self.EventTraceInformationClass, self.ProfileSource
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROFILE_SOURCE_INFO {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct EVENT_TRACE_PROFILE_LIST_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub Spare: u32,
    pub Profile: [*mut PROFILE_SOURCE_INFO; 1usize],
}
impl Default for EVENT_TRACE_PROFILE_LIST_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_PROFILE_LIST_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_PROFILE_LIST_INFORMATION {{ EventTraceInformationClass: {:?}, Profile: {:?} }}",
            self.EventTraceInformationClass, self.Profile
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_STACK_CACHING_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub TraceHandle: TRACEHANDLE,
    pub Enabled: BOOLEAN,
    pub Reserved: [u8; 3usize],
    pub CacheSize: u32,
    pub BucketCount: u32,
}
impl Default for EVENT_TRACE_STACK_CACHING_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_STACK_CACHING_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_STACK_CACHING_INFORMATION {{ EventTraceInformationClass: {:?}, Reserved: {:?} }}",
            self.EventTraceInformationClass, self.Reserved
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_SOFT_RESTART_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub TraceHandle: TRACEHANDLE,
    pub PersistTraceBuffers: BOOLEAN,
    pub FileName: [u16; 1usize],
}
impl Default for EVENT_TRACE_SOFT_RESTART_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_SOFT_RESTART_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_SOFT_RESTART_INFORMATION {{ EventTraceInformationClass: {:?}, FileName: {:?} }}",
            self.EventTraceInformationClass, self.FileName
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_PROFILE_ADD_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub PerfEvtEventSelect: BOOLEAN,
    pub PerfEvtUnitSelect: BOOLEAN,
    pub PerfEvtType: u32,
    pub CpuInfoHierarchy: [u32; 3usize],
    pub InitialInterval: u32,
    pub AllowsHalt: BOOLEAN,
    pub Persist: BOOLEAN,
    pub ProfileSourceDescription: [u16; 1usize],
}
impl Default for EVENT_TRACE_PROFILE_ADD_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_PROFILE_ADD_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_PROFILE_ADD_INFORMATION {{ EventTraceInformationClass: {:?}, CpuInfoHierarchy: {:?}, ProfileSourceDescription: {:?} }}",
            self.EventTraceInformationClass, self.CpuInfoHierarchy, self.ProfileSourceDescription
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_PROFILE_REMOVE_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub ProfileSource: KPROFILE_SOURCE,
    pub CpuInfoHierarchy: [u32; 3usize],
}
impl Default for EVENT_TRACE_PROFILE_REMOVE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_PROFILE_REMOVE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_PROFILE_REMOVE_INFORMATION {{ EventTraceInformationClass: {:?}, CpuInfoHierarchy: {:?} }}",
            self.EventTraceInformationClass, self.CpuInfoHierarchy
        )
    }
}
#[repr(C)]
pub struct EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION {
    pub EventTraceInformationClass: EVENT_TRACE_INFORMATION_CLASS,
    pub CoverageSamplerInformationClass: u8,
    pub MajorVersion: u8,
    pub MinorVersion: u8,
    pub Reserved: u8,
    pub SamplerHandle: HANDLE,
}
impl Default for EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EVENT_TRACE_COVERAGE_SAMPLER_INFORMATION {{ EventTraceInformationClass: {:?} }}",
            self.EventTraceInformationClass
        )
    }
}
#[repr(C)]
pub struct SYSTEM_EXCEPTION_INFORMATION {
    pub AlignmentFixupCount: u32,
    pub ExceptionDispatchCount: u32,
    pub FloatingEmulationCount: u32,
    pub ByteWordEmulationCount: u32,
}
impl Default for SYSTEM_EXCEPTION_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_EXCEPTION_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_EXCEPTION_INFORMATION {{  }}")
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS {
    SystemCrashDumpDisable = 0,
    SystemCrashDumpReconfigure = 1,
    SystemCrashDumpInitializationComplete = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SYSTEM_CRASH_DUMP_STATE_INFORMATION {
    pub CrashDumpConfigurationClass: SYSTEM_CRASH_DUMP_CONFIGURATION_CLASS,
}
impl Default for SYSTEM_CRASH_DUMP_STATE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[repr(C)]
pub struct SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    pub KernelDebuggerEnabled: BOOLEAN,
    pub KernelDebuggerNotPresent: BOOLEAN,
}
impl Default for SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_KERNEL_DEBUGGER_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_CONTEXT_SWITCH_INFORMATION {
    pub ContextSwitches: u32,
    pub FindAny: u32,
    pub FindLast: u32,
    pub FindIdeal: u32,
    pub IdleAny: u32,
    pub IdleCurrent: u32,
    pub IdleLast: u32,
    pub IdleIdeal: u32,
    pub PreemptAny: u32,
    pub PreemptCurrent: u32,
    pub PreemptLast: u32,
    pub SwitchToIdle: u32,
}
impl Default for SYSTEM_CONTEXT_SWITCH_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CONTEXT_SWITCH_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_CONTEXT_SWITCH_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_REGISTRY_QUOTA_INFORMATION {
    pub RegistryQuotaAllowed: u32,
    pub RegistryQuotaUsed: u32,
    pub PagedPoolSize: usize,
}
impl Default for SYSTEM_REGISTRY_QUOTA_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_REGISTRY_QUOTA_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_REGISTRY_QUOTA_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_IDLE_INFORMATION {
    pub IdleTime: u64,
    pub C1Time: u64,
    pub C2Time: u64,
    pub C3Time: u64,
    pub C1Transitions: u32,
    pub C2Transitions: u32,
    pub C3Transitions: u32,
    pub Padding: u32,
}
impl Default for SYSTEM_PROCESSOR_IDLE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_IDLE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESSOR_IDLE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_LEGACY_DRIVER_INFORMATION {
    pub VetoType: u32,
    pub VetoList: UNICODE_STRING,
}
impl Default for SYSTEM_LEGACY_DRIVER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_LEGACY_DRIVER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_LEGACY_DRIVER_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_LOOKASIDE_INFORMATION {
    pub CurrentDepth: u16,
    pub MaximumDepth: u16,
    pub TotalAllocates: u32,
    pub AllocateMisses: u32,
    pub TotalFrees: u32,
    pub FreeMisses: u32,
    pub Type: u32,
    pub Tag: u32,
    pub Size: u32,
}
impl Default for SYSTEM_LOOKASIDE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_LOOKASIDE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_LOOKASIDE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_RANGE_START_INFORMATION {
    pub SystemRangeStart: usize,
}
impl Default for SYSTEM_RANGE_START_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_RANGE_START_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_RANGE_START_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_VERIFIER_INFORMATION_LEGACY {
    pub NextEntryOffset: u32,
    pub Level: u32,
    pub DriverName: UNICODE_STRING,
    pub RaiseIrqls: u32,
    pub AcquireSpinLocks: u32,
    pub SynchronizeExecutions: u32,
    pub AllocationsAttempted: u32,
    pub AllocationsSucceeded: u32,
    pub AllocationsSucceededSpecialPool: u32,
    pub AllocationsWithNoTag: u32,
    pub TrimRequests: u32,
    pub Trims: u32,
    pub AllocationsFailed: u32,
    pub AllocationsFailedDeliberately: u32,
    pub Loads: u32,
    pub Unloads: u32,
    pub UnTrackedPool: u32,
    pub CurrentPagedPoolAllocations: u32,
    pub CurrentNonPagedPoolAllocations: u32,
    pub PeakPagedPoolAllocations: u32,
    pub PeakNonPagedPoolAllocations: u32,
    pub PagedPoolUsageInBytes: usize,
    pub NonPagedPoolUsageInBytes: usize,
    pub PeakPagedPoolUsageInBytes: usize,
    pub PeakNonPagedPoolUsageInBytes: usize,
}
impl Default for SYSTEM_VERIFIER_INFORMATION_LEGACY {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VERIFIER_INFORMATION_LEGACY {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_VERIFIER_INFORMATION_LEGACY {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_VERIFIER_INFORMATION {
    pub NextEntryOffset: u32,
    pub Level: u32,
    pub RuleClasses: [u32; 2usize],
    pub TriageContext: u32,
    pub AreAllDriversBeingVerified: u32,
    pub DriverName: UNICODE_STRING,
    pub RaiseIrqls: u32,
    pub AcquireSpinLocks: u32,
    pub SynchronizeExecutions: u32,
    pub AllocationsAttempted: u32,
    pub AllocationsSucceeded: u32,
    pub AllocationsSucceededSpecialPool: u32,
    pub AllocationsWithNoTag: u32,
    pub TrimRequests: u32,
    pub Trims: u32,
    pub AllocationsFailed: u32,
    pub AllocationsFailedDeliberately: u32,
    pub Loads: u32,
    pub Unloads: u32,
    pub UnTrackedPool: u32,
    pub CurrentPagedPoolAllocations: u32,
    pub CurrentNonPagedPoolAllocations: u32,
    pub PeakPagedPoolAllocations: u32,
    pub PeakNonPagedPoolAllocations: u32,
    pub PagedPoolUsageInBytes: usize,
    pub NonPagedPoolUsageInBytes: usize,
    pub PeakPagedPoolUsageInBytes: usize,
    pub PeakNonPagedPoolUsageInBytes: usize,
}
impl Default for SYSTEM_VERIFIER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VERIFIER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_VERIFIER_INFORMATION {{ RuleClasses: {:?} }}",
            self.RuleClasses
        )
    }
}
#[repr(C)]
pub struct SYSTEM_SESSION_PROCESS_INFORMATION {
    pub SessionId: u32,
    pub SizeOfBuf: u32,
    pub Buffer: *mut std::ffi::c_void,
}
impl Default for SYSTEM_SESSION_PROCESS_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SESSION_PROCESS_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SESSION_PROCESS_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_GDI_DRIVER_INFORMATION {
    pub DriverName: UNICODE_STRING,
    pub ImageAddress: *mut std::ffi::c_void,
    pub SectionPointer: *mut std::ffi::c_void,
    pub EntryPoint: *mut std::ffi::c_void,
    pub ExportSectionPointer: *mut IMAGE_EXPORT_DIRECTORY,
    pub ImageLength: u32,
}
impl Default for SYSTEM_GDI_DRIVER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_GDI_DRIVER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_GDI_DRIVER_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_NUMA_INFORMATION {
    pub HighestNodeNumber: u32,
    pub Reserved: u32,
    pub Anonymous1: SYSTEM_NUMA_INFORMATION_1,
}
#[repr(C)]
pub struct SYSTEM_NUMA_INFORMATION_1 {
    pub ActiveProcessorsGroupAffinity: UnionField<[GROUP_AFFINITY; 64usize]>,
    pub AvailableMemory: UnionField<[u64; 64usize]>,
    pub Pad: UnionField<[u64; 128usize]>,
    pub union_field: [u64; 128usize],
}
impl Default for SYSTEM_NUMA_INFORMATION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_NUMA_INFORMATION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_NUMA_INFORMATION_1 {{ union }}")
    }
}
impl Default for SYSTEM_NUMA_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_NUMA_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_NUMA_INFORMATION {{ Anonymous1: {:?} }}",
            self.Anonymous1
        )
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_POWER_INFORMATION {
    pub CurrentFrequency: u8,
    pub ThermalLimitFrequency: u8,
    pub ConstantThrottleFrequency: u8,
    pub DegradedThrottleFrequency: u8,
    pub LastBusyFrequency: u8,
    pub LastC3Frequency: u8,
    pub LastAdjustedBusyFrequency: u8,
    pub ProcessorMinThrottle: u8,
    pub ProcessorMaxThrottle: u8,
    pub NumberOfFrequencies: u32,
    pub PromotionCount: u32,
    pub DemotionCount: u32,
    pub ErrorCount: u32,
    pub RetryCount: u32,
    pub CurrentFrequencyTime: u64,
    pub CurrentProcessorTime: u64,
    pub CurrentProcessorIdleTime: u64,
    pub LastProcessorTime: u64,
    pub LastProcessorIdleTime: u64,
    pub Energy: u64,
}
impl Default for SYSTEM_PROCESSOR_POWER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_POWER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESSOR_POWER_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    pub Object: *mut std::ffi::c_void,
    pub UniqueProcessId: usize,
    pub HandleValue: usize,
    pub GrantedAccess: u32,
    pub CreatorBackTraceIndex: u16,
    pub ObjectTypeIndex: u16,
    pub HandleAttributes: u32,
    pub Reserved: u32,
}
impl Default for SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_HANDLE_INFORMATION_EX {
    pub NumberOfHandles: usize,
    pub Reserved: usize,
    pub Handles: [SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX; 1usize],
}
impl Default for SYSTEM_HANDLE_INFORMATION_EX {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HANDLE_INFORMATION_EX {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_HANDLE_INFORMATION_EX {{ Handles: {:?} }}",
            self.Handles
        )
    }
}
#[repr(C)]
pub struct SYSTEM_BIGPOOL_ENTRY {
    pub Anonymous1: SYSTEM_BIGPOOL_ENTRY_1,
    pub SizeInBytes: usize,
    pub Anonymous2: SYSTEM_BIGPOOL_ENTRY_2,
}
#[repr(C)]
pub struct SYSTEM_BIGPOOL_ENTRY_1 {
    pub VirtualAddress: UnionField<*mut std::ffi::c_void>,
    _bitfield_align_1: [u8; 0],
    _bitfield_1: UnionField<BitfieldUnit<[u8; 1usize]>>,
    pub union_field: u64,
}
impl Default for SYSTEM_BIGPOOL_ENTRY_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BIGPOOL_ENTRY_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_BIGPOOL_ENTRY_1 {{ union }}")
    }
}
impl SYSTEM_BIGPOOL_ENTRY_1 {
    #[inline]
    pub fn NonPaged(&self) -> usize {
        unsafe { std::mem::transmute(self._bitfield_1.as_ref().get(0usize, 1u8)) }
    }
    #[inline]
    pub fn set_NonPaged(&mut self, val: usize) {
        unsafe {
            let val: u64 = std::mem::transmute(val);
            self._bitfield_1.as_mut().set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(NonPaged: usize) -> BitfieldUnit<[u8; 1usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 1usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, {
            let NonPaged: u64 = unsafe { std::mem::transmute(NonPaged) };
            NonPaged as u64
        });
        bitfield_unit
    }
}
#[repr(C)]
pub struct SYSTEM_BIGPOOL_ENTRY_2 {
    pub Tag: UnionField<[u8; 4usize]>,
    pub TagUlong: UnionField<u32>,
    pub union_field: u32,
}
impl Default for SYSTEM_BIGPOOL_ENTRY_2 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BIGPOOL_ENTRY_2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_BIGPOOL_ENTRY_2 {{ union }}")
    }
}
impl Default for SYSTEM_BIGPOOL_ENTRY {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BIGPOOL_ENTRY {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_BIGPOOL_ENTRY {{ Anonymous1: {:?}, Anonymous2: {:?} }}",
            self.Anonymous1, self.Anonymous2
        )
    }
}
#[repr(C)]
pub struct SYSTEM_BIGPOOL_INFORMATION {
    pub Count: u32,
    pub AllocatedInfo: [SYSTEM_BIGPOOL_ENTRY; 1usize],
}
impl Default for SYSTEM_BIGPOOL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BIGPOOL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_BIGPOOL_INFORMATION {{ AllocatedInfo: {:?} }}",
            self.AllocatedInfo
        )
    }
}
#[repr(C)]
pub struct SYSTEM_POOL_ENTRY {
    pub Allocated: BOOLEAN,
    pub Spare0: BOOLEAN,
    pub AllocatorBackTraceIndex: u16,
    pub Size: u32,
    pub Anonymous1: SYSTEM_POOL_ENTRY_1,
}
#[repr(C)]
pub struct SYSTEM_POOL_ENTRY_1 {
    pub Tag: UnionField<[u8; 4usize]>,
    pub TagUlong: UnionField<u32>,
    pub ProcessChargedQuota: UnionField<*mut std::ffi::c_void>,
    pub union_field: u64,
}
impl Default for SYSTEM_POOL_ENTRY_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POOL_ENTRY_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_POOL_ENTRY_1 {{ union }}")
    }
}
impl Default for SYSTEM_POOL_ENTRY {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POOL_ENTRY {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_POOL_ENTRY {{ Anonymous1: {:?} }}",
            self.Anonymous1
        )
    }
}
#[repr(C)]
pub struct SYSTEM_POOL_INFORMATION {
    pub TotalSize: usize,
    pub FirstEntry: *mut std::ffi::c_void,
    pub EntryOverhead: u16,
    pub PoolTagPresent: BOOLEAN,
    pub Spare0: BOOLEAN,
    pub NumberOfEntries: u32,
    pub Entries: [SYSTEM_POOL_ENTRY; 1usize],
}
impl Default for SYSTEM_POOL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POOL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_POOL_INFORMATION {{ Entries: {:?} }}",
            self.Entries
        )
    }
}
#[repr(C)]
pub struct SYSTEM_SESSION_POOLTAG_INFORMATION {
    pub NextEntryOffset: usize,
    pub SessionId: u32,
    pub Count: u32,
    pub TagInfo: [SYSTEM_POOLTAG; 1usize],
}
impl Default for SYSTEM_SESSION_POOLTAG_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SESSION_POOLTAG_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SESSION_POOLTAG_INFORMATION {{ TagInfo: {:?} }}",
            self.TagInfo
        )
    }
}
#[repr(C)]
pub struct SYSTEM_SESSION_MAPPED_VIEW_INFORMATION {
    pub NextEntryOffset: usize,
    pub SessionId: u32,
    pub ViewFailures: u32,
    pub NumberOfBytesAvailable: usize,
    pub NumberOfBytesAvailableContiguous: usize,
}
impl Default for SYSTEM_SESSION_MAPPED_VIEW_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SESSION_MAPPED_VIEW_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SESSION_MAPPED_VIEW_INFORMATION {{  }}")
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WATCHDOG_HANDLER_ACTION {
    WdActionSetTimeoutValue = 0,
    WdActionQueryTimeoutValue = 1,
    WdActionResetTimer = 2,
    WdActionStopTimer = 3,
    WdActionStartTimer = 4,
    WdActionSetTriggerAction = 5,
    WdActionQueryTriggerAction = 6,
    WdActionQueryState = 7,
}
pub type PSYSTEM_WATCHDOG_HANDLER = std::option::Option<
    unsafe extern "system" fn(
        Action: WATCHDOG_HANDLER_ACTION,
        Context: *mut std::ffi::c_void,
        DataValue: *mut u32,
        NoLocks: BOOLEAN,
    ) -> NTSTATUS,
>;
#[repr(C)]
pub struct SYSTEM_WATCHDOG_HANDLER_INFORMATION {
    pub WdHandler: PSYSTEM_WATCHDOG_HANDLER,
    pub Context: *mut std::ffi::c_void,
}
impl Default for SYSTEM_WATCHDOG_HANDLER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_WATCHDOG_HANDLER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_WATCHDOG_HANDLER_INFORMATION {{ WdHandler: {:?} }}",
            self.WdHandler
        )
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum WATCHDOG_INFORMATION_CLASS {
    WdInfoTimeoutValue = 0,
    WdInfoResetTimer = 1,
    WdInfoStopTimer = 2,
    WdInfoStartTimer = 3,
    WdInfoTriggerAction = 4,
    WdInfoState = 5,
    WdInfoTriggerReset = 6,
    WdInfoNop = 7,
    WdInfoGeneratedLastReset = 8,
    WdInfoInvalid = 9,
}
#[repr(C)]
pub struct SYSTEM_WATCHDOG_TIMER_INFORMATION {
    pub WdInfoClass: WATCHDOG_INFORMATION_CLASS,
    pub DataValue: u32,
}
impl Default for SYSTEM_WATCHDOG_TIMER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_WATCHDOG_TIMER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_WATCHDOG_TIMER_INFORMATION {{ WdInfoClass: {:?} }}",
            self.WdInfoClass
        )
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_FIRMWARE_TABLE_ACTION {
    SystemFirmwareTableEnumerate = 0,
    SystemFirmwareTableGet = 1,
    SystemFirmwareTableMax = 2,
}
pub type PFNFTH = std::option::Option<
    unsafe extern "system" fn(
        SystemFirmwareTableInfo: *mut SYSTEM_FIRMWARE_TABLE_INFORMATION,
    ) -> NTSTATUS,
>;
#[repr(C)]
pub struct SYSTEM_MEMORY_LIST_INFORMATION {
    pub ZeroPageCount: usize,
    pub FreePageCount: usize,
    pub ModifiedPageCount: usize,
    pub ModifiedNoWritePageCount: usize,
    pub BadPageCount: usize,
    pub PageCountByPriority: [usize; 8usize],
    pub RepurposedPagesByPriority: [usize; 8usize],
    pub ModifiedPageCountPageFile: usize,
}
impl Default for SYSTEM_MEMORY_LIST_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_MEMORY_LIST_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_MEMORY_LIST_INFORMATION {{ PageCountByPriority: {:?}, RepurposedPagesByPriority: {:?} }}",
            self.PageCountByPriority, self.RepurposedPagesByPriority
        )
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_MEMORY_LIST_COMMAND {
    MemoryCaptureAccessedBits = 0,
    MemoryCaptureAndResetAccessedBits = 1,
    MemoryEmptyWorkingSets = 2,
    MemoryFlushModifiedList = 3,
    MemoryPurgeStandbyList = 4,
    MemoryPurgeLowPriorityStandbyList = 5,
    MemoryCommandMax = 6,
}
#[repr(C)]
pub struct SYSTEM_THREAD_CID_PRIORITY_INFORMATION {
    pub ClientId: CLIENT_ID,
    pub Priority: i32,
}
impl Default for SYSTEM_THREAD_CID_PRIORITY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_THREAD_CID_PRIORITY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_THREAD_CID_PRIORITY_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION {
    pub CycleTime: u64,
}
impl Default for SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_VERIFIER_ISSUE {
    pub IssueType: u64,
    pub Address: *mut std::ffi::c_void,
    pub Parameters: [u64; 2usize],
}
impl Default for SYSTEM_VERIFIER_ISSUE {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VERIFIER_ISSUE {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_VERIFIER_ISSUE {{ Parameters: {:?} }}",
            self.Parameters
        )
    }
}
#[repr(C)]
pub struct SYSTEM_VERIFIER_CANCELLATION_INFORMATION {
    pub CancelProbability: u32,
    pub CancelThreshold: u32,
    pub CompletionThreshold: u32,
    pub CancellationVerifierDisabled: u32,
    pub AvailableIssues: u32,
    pub Issues: [SYSTEM_VERIFIER_ISSUE; 128usize],
}
impl Default for SYSTEM_VERIFIER_CANCELLATION_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VERIFIER_CANCELLATION_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_VERIFIER_CANCELLATION_INFORMATION {{ Issues: {:?} }}",
            self.Issues
        )
    }
}
#[repr(C)]
pub struct SYSTEM_REF_TRACE_INFORMATION {
    pub TraceEnable: BOOLEAN,
    pub TracePermanent: BOOLEAN,
    pub TraceProcessName: UNICODE_STRING,
    pub TracePoolTags: UNICODE_STRING,
}
impl Default for SYSTEM_REF_TRACE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_REF_TRACE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_REF_TRACE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_SPECIAL_POOL_INFORMATION {
    pub PoolTag: u32,
    pub Flags: u32,
}
impl Default for SYSTEM_SPECIAL_POOL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SPECIAL_POOL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SPECIAL_POOL_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESS_ID_INFORMATION {
    pub ProcessId: HANDLE,
    pub ImageName: UNICODE_STRING,
}
impl Default for SYSTEM_PROCESS_ID_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESS_ID_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESS_ID_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_HYPERVISOR_QUERY_INFORMATION {
    pub HypervisorConnected: BOOLEAN,
    pub HypervisorDebuggingEnabled: BOOLEAN,
    pub HypervisorPresent: BOOLEAN,
    pub Spare0: [BOOLEAN; 5usize],
    pub EnabledEnlightenments: u64,
}
impl Default for SYSTEM_HYPERVISOR_QUERY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HYPERVISOR_QUERY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_HYPERVISOR_QUERY_INFORMATION {{ Spare0: {:?} }}",
            self.Spare0
        )
    }
}
#[repr(C)]
pub struct SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    pub BootIdentifier: GUID,
    pub FirmwareType: FIRMWARE_TYPE,
    pub Anonymous1: SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1,
}
#[repr(C)]
pub struct SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1 {
    pub BootFlags: UnionField<u64>,
    pub Anonymous1: UnionField<SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1_1>,
    pub union_field: u64,
}
#[repr(C)]
#[repr(align(8))]
pub struct SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1_1 {
    _bitfield_align_1: [u8; 0],
    _bitfield_1: BitfieldUnit<[u8; 2usize]>,
    pub padding_0: [u16; 3usize],
}
impl Default for SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1_1 {{ DbgMenuOsSelection : {:?}, DbgHiberBoot : {:?}, DbgSoftBoot : {:?}, DbgMeasuredLaunch : {:?}, DbgMeasuredLaunchCapable : {:?}, DbgSystemHiveReplace : {:?}, DbgMeasuredLaunchSmmProtections : {:?}, DbgMeasuredLaunchSmmLevel : {:?} }}",
            self.DbgMenuOsSelection(),
            self.DbgHiberBoot(),
            self.DbgSoftBoot(),
            self.DbgMeasuredLaunch(),
            self.DbgMeasuredLaunchCapable(),
            self.DbgSystemHiveReplace(),
            self.DbgMeasuredLaunchSmmProtections(),
            self.DbgMeasuredLaunchSmmLevel()
        )
    }
}
impl SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1_1 {
    #[inline]
    pub fn DbgMenuOsSelection(&self) -> u64 {
        self._bitfield_1.get(0usize, 1u8)
    }
    #[inline]
    pub fn set_DbgMenuOsSelection(&mut self, val: u64) {
        self._bitfield_1.set(0usize, 1u8, val)
    }
    #[inline]
    pub fn DbgHiberBoot(&self) -> u64 {
        self._bitfield_1.get(1usize, 1u8)
    }
    #[inline]
    pub fn set_DbgHiberBoot(&mut self, val: u64) {
        self._bitfield_1.set(1usize, 1u8, val)
    }
    #[inline]
    pub fn DbgSoftBoot(&self) -> u64 {
        self._bitfield_1.get(2usize, 1u8)
    }
    #[inline]
    pub fn set_DbgSoftBoot(&mut self, val: u64) {
        self._bitfield_1.set(2usize, 1u8, val)
    }
    #[inline]
    pub fn DbgMeasuredLaunch(&self) -> u64 {
        self._bitfield_1.get(3usize, 1u8)
    }
    #[inline]
    pub fn set_DbgMeasuredLaunch(&mut self, val: u64) {
        self._bitfield_1.set(3usize, 1u8, val)
    }
    #[inline]
    pub fn DbgMeasuredLaunchCapable(&self) -> u64 {
        self._bitfield_1.get(4usize, 1u8)
    }
    #[inline]
    pub fn set_DbgMeasuredLaunchCapable(&mut self, val: u64) {
        self._bitfield_1.set(4usize, 1u8, val)
    }
    #[inline]
    pub fn DbgSystemHiveReplace(&self) -> u64 {
        self._bitfield_1.get(5usize, 1u8)
    }
    #[inline]
    pub fn set_DbgSystemHiveReplace(&mut self, val: u64) {
        self._bitfield_1.set(5usize, 1u8, val)
    }
    #[inline]
    pub fn DbgMeasuredLaunchSmmProtections(&self) -> u64 {
        self._bitfield_1.get(6usize, 1u8)
    }
    #[inline]
    pub fn set_DbgMeasuredLaunchSmmProtections(&mut self, val: u64) {
        self._bitfield_1.set(6usize, 1u8, val)
    }
    #[inline]
    pub fn DbgMeasuredLaunchSmmLevel(&self) -> u64 {
        self._bitfield_1.get(7usize, 7u8)
    }
    #[inline]
    pub fn set_DbgMeasuredLaunchSmmLevel(&mut self, val: u64) {
        self._bitfield_1.set(7usize, 7u8, val)
    }
    #[inline]
    pub fn new_bitfield_1(
        DbgMenuOsSelection: u64,
        DbgHiberBoot: u64,
        DbgSoftBoot: u64,
        DbgMeasuredLaunch: u64,
        DbgMeasuredLaunchCapable: u64,
        DbgSystemHiveReplace: u64,
        DbgMeasuredLaunchSmmProtections: u64,
        DbgMeasuredLaunchSmmLevel: u64,
    ) -> BitfieldUnit<[u8; 2usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 2usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, DbgMenuOsSelection);
        bitfield_unit.set(1usize, 1u8, DbgHiberBoot);
        bitfield_unit.set(2usize, 1u8, DbgSoftBoot);
        bitfield_unit.set(3usize, 1u8, DbgMeasuredLaunch);
        bitfield_unit.set(4usize, 1u8, DbgMeasuredLaunchCapable);
        bitfield_unit.set(5usize, 1u8, DbgSystemHiveReplace);
        bitfield_unit.set(6usize, 1u8, DbgMeasuredLaunchSmmProtections);
        bitfield_unit.set(7usize, 7u8, DbgMeasuredLaunchSmmLevel);
        bitfield_unit
    }
}
impl Default for SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_BOOT_ENVIRONMENT_INFORMATION_1 {{ union }}")
    }
}
impl Default for SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_BOOT_ENVIRONMENT_INFORMATION {{ Anonymous1: {:?} }}",
            self.Anonymous1
        )
    }
}
#[repr(C)]
pub struct SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION {
    pub FlagsToEnable: u32,
    pub FlagsToDisable: u32,
}
impl Default for SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION {{  }}")
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum COVERAGE_REQUEST_CODES {
    CoverageAllModules = 0,
    CoverageSearchByHash = 1,
    CoverageSearchByName = 2,
}
#[repr(C)]
pub struct COVERAGE_MODULE_REQUEST {
    pub RequestType: COVERAGE_REQUEST_CODES,
    pub SearchInfo: COVERAGE_MODULE_REQUEST_1,
}
#[repr(C)]
pub struct COVERAGE_MODULE_REQUEST_1 {
    pub MD5Hash: UnionField<[u8; 16usize]>,
    pub ModuleName: UnionField<UNICODE_STRING>,
    pub union_field: [u64; 2usize],
}
impl Default for COVERAGE_MODULE_REQUEST_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for COVERAGE_MODULE_REQUEST_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "COVERAGE_MODULE_REQUEST_1 {{ union }}")
    }
}
impl Default for COVERAGE_MODULE_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for COVERAGE_MODULE_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "COVERAGE_MODULE_REQUEST {{ RequestType: {:?}, SearchInfo: {:?} }}",
            self.RequestType, self.SearchInfo
        )
    }
}
#[repr(C)]
pub struct COVERAGE_MODULE_INFO {
    pub ModuleInfoSize: u32,
    pub IsBinaryLoaded: u32,
    pub ModulePathName: UNICODE_STRING,
    pub CoverageSectionSize: u32,
    pub CoverageSection: [u8; 1usize],
}
impl Default for COVERAGE_MODULE_INFO {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for COVERAGE_MODULE_INFO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "COVERAGE_MODULE_INFO {{ CoverageSection: {:?} }}",
            self.CoverageSection
        )
    }
}
#[repr(C)]
pub struct COVERAGE_MODULES {
    pub ListAndReset: u32,
    pub NumberOfModules: u32,
    pub ModuleRequestInfo: COVERAGE_MODULE_REQUEST,
    pub Modules: [COVERAGE_MODULE_INFO; 1usize],
}
impl Default for COVERAGE_MODULES {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for COVERAGE_MODULES {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "COVERAGE_MODULES {{ ModuleRequestInfo: {:?}, Modules: {:?} }}",
            self.ModuleRequestInfo, self.Modules
        )
    }
}
#[repr(C)]
pub struct SYSTEM_PREFETCH_PATCH_INFORMATION {
    pub PrefetchPatchCount: u32,
}
impl Default for SYSTEM_PREFETCH_PATCH_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PREFETCH_PATCH_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PREFETCH_PATCH_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_VERIFIER_FAULTS_INFORMATION {
    pub Probability: u32,
    pub MaxProbability: u32,
    pub PoolTags: UNICODE_STRING,
    pub Applications: UNICODE_STRING,
}
impl Default for SYSTEM_VERIFIER_FAULTS_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VERIFIER_FAULTS_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_VERIFIER_FAULTS_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_VERIFIER_INFORMATION_EX {
    pub VerifyMode: u32,
    pub OptionChanges: u32,
    pub PreviousBucketName: UNICODE_STRING,
    pub IrpCancelTimeoutMsec: u32,
    pub VerifierExtensionEnabled: u32,
    pub Reserved: [u32; 1usize],
}
impl Default for SYSTEM_VERIFIER_INFORMATION_EX {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VERIFIER_INFORMATION_EX {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_VERIFIER_INFORMATION_EX {{ Reserved: {:?} }}",
            self.Reserved
        )
    }
}
#[repr(C)]
pub struct SYSTEM_SYSTEM_PARTITION_INFORMATION {
    pub SystemPartition: UNICODE_STRING,
}
impl Default for SYSTEM_SYSTEM_PARTITION_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SYSTEM_PARTITION_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SYSTEM_PARTITION_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_SYSTEM_DISK_INFORMATION {
    pub SystemDisk: UNICODE_STRING,
}
impl Default for SYSTEM_SYSTEM_DISK_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SYSTEM_DISK_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SYSTEM_DISK_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_NUMA_PROXIMITY_MAP {
    pub NodeProximityId: u32,
    pub NodeNumber: u16,
}
impl Default for SYSTEM_NUMA_PROXIMITY_MAP {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_NUMA_PROXIMITY_MAP {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_NUMA_PROXIMITY_MAP {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT {
    pub Hits: u64,
    pub PercentFrequency: u8,
}
impl Default for SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 {
    pub Hits: u32,
    pub PercentFrequency: u8,
}
impl Default for SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT_WIN8 {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION {
    pub ProcessorNumber: u32,
    pub StateCount: u32,
    pub States: [SYSTEM_PROCESSOR_PERFORMANCE_HITCOUNT; 1usize],
}
impl Default for SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PROCESSOR_PERFORMANCE_STATE_DISTRIBUTION {{ States: {:?} }}",
            self.States
        )
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION {
    pub ProcessorCount: u32,
    pub Offsets: [u32; 1usize],
}
impl Default for SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION {{ Offsets: {:?} }}",
            self.Offsets
        )
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION {
    pub Operation: u32,
}
impl Default for SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION {{  }}")
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_VA_TYPE {
    SystemVaTypeAll = 0,
    SystemVaTypeNonPagedPool = 1,
    SystemVaTypePagedPool = 2,
    SystemVaTypeSystemCache = 3,
    SystemVaTypeSystemPtes = 4,
    SystemVaTypeSessionSpace = 5,
    SystemVaTypeMax = 6,
}
#[repr(C)]
pub struct SYSTEM_VA_LIST_INFORMATION {
    pub VirtualSize: usize,
    pub VirtualPeak: usize,
    pub VirtualLimit: usize,
    pub AllocationFailures: usize,
}
impl Default for SYSTEM_VA_LIST_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VA_LIST_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_VA_LIST_INFORMATION {{  }}")
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum STORE_INFORMATION_CLASS {
    StorePageRequest = 1,
    StoreStatsRequest = 2,
    StoreCreateRequest = 3,
    StoreDeleteRequest = 4,
    StoreListRequest = 5,
    Available1 = 6,
    StoreEmptyRequest = 7,
    CacheListRequest = 8,
    CacheCreateRequest = 9,
    CacheDeleteRequest = 10,
    CacheStoreCreateRequest = 11,
    CacheStoreDeleteRequest = 12,
    CacheStatsRequest = 13,
    Available2 = 14,
    RegistrationRequest = 15,
    GlobalCacheStatsRequest = 16,
    StoreResizeRequest = 17,
    CacheStoreResizeRequest = 18,
    SmConfigRequest = 19,
    StoreHighMemoryPriorityRequest = 20,
    SystemStoreTrimRequest = 21,
    MemCompressionInfoRequest = 22,
    ProcessStoreInfoRequest = 23,
    StoreInformationMax = 24,
}
#[repr(C)]
pub struct SYSTEM_STORE_INFORMATION {
    pub Version: u32,
    pub StoreInformationClass: STORE_INFORMATION_CLASS,
    pub Data: *mut std::ffi::c_void,
    pub Length: u32,
}
impl Default for SYSTEM_STORE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_STORE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_STORE_INFORMATION {{ StoreInformationClass: {:?} }}",
            self.StoreInformationClass
        )
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ST_STATS_LEVEL {
    StStatsLevelBasic = 0,
    StStatsLevelIoStats = 1,
    StStatsLevelRegionSpace = 2,
    StStatsLevelSpaceBitmap = 3,
    StStatsLevelMax = 4,
}
#[repr(C)]
pub struct SM_STATS_REQUEST {
    _bitfield_align_1: [u16; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub BufferSize: u32,
    pub Buffer: *mut std::ffi::c_void,
}
impl Default for SM_STATS_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STATS_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_STATS_REQUEST {{ Version : {:?}, DetailLevel : {:?}, StoreId : {:?} }}",
            self.Version(),
            self.DetailLevel(),
            self.StoreId()
        )
    }
}
impl SM_STATS_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn DetailLevel(&self) -> u32 {
        self._bitfield_1.get(8usize, 8u8) as u32
    }
    #[inline]
    pub fn set_DetailLevel(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 8u8, val as u64)
    }
    #[inline]
    pub fn StoreId(&self) -> u32 {
        self._bitfield_1.get(16usize, 16u8) as u32
    }
    #[inline]
    pub fn set_StoreId(&mut self, val: u32) {
        self._bitfield_1.set(16usize, 16u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        Version: u32,
        DetailLevel: u32,
        StoreId: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 8u8, DetailLevel as u64);
        bitfield_unit.set(16usize, 16u8, StoreId as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct ST_DATA_MGR_STATS {
    pub RegionCount: u32,
    pub PagesStored: u32,
    pub UniquePagesStored: u32,
    pub LazyCleanupRegionCount: u32,
    pub Space: [ST_DATA_MGR_STATS_1; 8usize],
}
#[repr(C)]
pub struct ST_DATA_MGR_STATS_1 {
    pub RegionsInUse: u32,
    pub SpaceUsed: u32,
}
impl Default for ST_DATA_MGR_STATS_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_DATA_MGR_STATS_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ST_DATA_MGR_STATS_1 {{  }}")
    }
}
impl Default for ST_DATA_MGR_STATS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_DATA_MGR_STATS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ST_DATA_MGR_STATS {{ Space: {:?} }}", self.Space)
    }
}
#[repr(C)]
pub struct ST_IO_STATS_PERIOD {
    pub PageCounts: [u32; 5usize],
}
impl Default for ST_IO_STATS_PERIOD {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_IO_STATS_PERIOD {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ST_IO_STATS_PERIOD {{ PageCounts: {:?} }}",
            self.PageCounts
        )
    }
}
#[repr(C)]
pub struct ST_IO_STATS {
    pub PeriodCount: u32,
    pub Periods: [ST_IO_STATS_PERIOD; 64usize],
}
impl Default for ST_IO_STATS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_IO_STATS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ST_IO_STATS {{ Periods: {:?} }}", self.Periods)
    }
}
#[repr(C)]
pub struct ST_READ_LATENCY_BUCKET {
    pub LatencyUs: u32,
    pub Count: u32,
}
impl Default for ST_READ_LATENCY_BUCKET {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_READ_LATENCY_BUCKET {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ST_READ_LATENCY_BUCKET {{  }}")
    }
}
#[repr(C)]
pub struct ST_READ_LATENCY_STATS {
    pub Buckets: [ST_READ_LATENCY_BUCKET; 8usize],
}
impl Default for ST_READ_LATENCY_STATS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_READ_LATENCY_STATS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ST_READ_LATENCY_STATS {{ Buckets: {:?} }}", self.Buckets)
    }
}
#[repr(C)]
pub struct ST_STATS_REGION_INFO {
    pub SpaceUsed: u16,
    pub Priority: u8,
    pub Spare: u8,
}
impl Default for ST_STATS_REGION_INFO {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_STATS_REGION_INFO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ST_STATS_REGION_INFO {{  }}")
    }
}
#[repr(C)]
pub struct ST_STATS_SPACE_BITMAP {
    pub CompressedBytes: usize,
    pub BytesPerBit: u32,
    pub StoreBitmap: [u8; 1usize],
}
impl Default for ST_STATS_SPACE_BITMAP {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_STATS_SPACE_BITMAP {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ST_STATS_SPACE_BITMAP {{ StoreBitmap: {:?} }}",
            self.StoreBitmap
        )
    }
}
#[repr(C)]
pub struct ST_STATS {
    _bitfield_align_1: [u16; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub Size: u32,
    pub CompressionFormat: u16,
    pub Spare: u16,
    pub Basic: ST_STATS_1,
    pub Io: ST_STATS_2,
}
#[repr(C)]
pub struct ST_STATS_1 {
    pub RegionSize: u32,
    pub RegionCount: u32,
    pub RegionCountMax: u32,
    pub Granularity: u32,
    pub UserData: ST_DATA_MGR_STATS,
    pub Metadata: ST_DATA_MGR_STATS,
}
impl Default for ST_STATS_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_STATS_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ST_STATS_1 {{ UserData: {:?}, Metadata: {:?} }}",
            self.UserData, self.Metadata
        )
    }
}
#[repr(C)]
pub struct ST_STATS_2 {
    pub IoStats: ST_IO_STATS,
    pub ReadLatencyStats: ST_READ_LATENCY_STATS,
}
impl Default for ST_STATS_2 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_STATS_2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ST_STATS_2 {{ IoStats: {:?}, ReadLatencyStats: {:?} }}",
            self.IoStats, self.ReadLatencyStats
        )
    }
}
impl Default for ST_STATS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ST_STATS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ST_STATS {{ Version : {:?}, Level : {:?}, StoreType : {:?}, NoDuplication : {:?}, NoCompression : {:?}, EncryptionStrength : {:?}, VirtualRegions : {:?}, Spare0 : {:?}, Basic: {:?}, Io: {:?} }}",
            self.Version(),
            self.Level(),
            self.StoreType(),
            self.NoDuplication(),
            self.NoCompression(),
            self.EncryptionStrength(),
            self.VirtualRegions(),
            self.Spare0(),
            self.Basic,
            self.Io
        )
    }
}
impl ST_STATS {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Level(&self) -> u32 {
        self._bitfield_1.get(8usize, 4u8) as u32
    }
    #[inline]
    pub fn set_Level(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 4u8, val as u64)
    }
    #[inline]
    pub fn StoreType(&self) -> u32 {
        self._bitfield_1.get(12usize, 4u8) as u32
    }
    #[inline]
    pub fn set_StoreType(&mut self, val: u32) {
        self._bitfield_1.set(12usize, 4u8, val as u64)
    }
    #[inline]
    pub fn NoDuplication(&self) -> u32 {
        self._bitfield_1.get(16usize, 1u8) as u32
    }
    #[inline]
    pub fn set_NoDuplication(&mut self, val: u32) {
        self._bitfield_1.set(16usize, 1u8, val as u64)
    }
    #[inline]
    pub fn NoCompression(&self) -> u32 {
        self._bitfield_1.get(17usize, 1u8) as u32
    }
    #[inline]
    pub fn set_NoCompression(&mut self, val: u32) {
        self._bitfield_1.set(17usize, 1u8, val as u64)
    }
    #[inline]
    pub fn EncryptionStrength(&self) -> u32 {
        self._bitfield_1.get(18usize, 12u8) as u32
    }
    #[inline]
    pub fn set_EncryptionStrength(&mut self, val: u32) {
        self._bitfield_1.set(18usize, 12u8, val as u64)
    }
    #[inline]
    pub fn VirtualRegions(&self) -> u32 {
        self._bitfield_1.get(30usize, 1u8) as u32
    }
    #[inline]
    pub fn set_VirtualRegions(&mut self, val: u32) {
        self._bitfield_1.set(30usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare0(&self) -> u32 {
        self._bitfield_1.get(31usize, 1u8) as u32
    }
    #[inline]
    pub fn set_Spare0(&mut self, val: u32) {
        self._bitfield_1.set(31usize, 1u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        Version: u32,
        Level: u32,
        StoreType: u32,
        NoDuplication: u32,
        NoCompression: u32,
        EncryptionStrength: u32,
        VirtualRegions: u32,
        Spare0: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 4u8, Level as u64);
        bitfield_unit.set(12usize, 4u8, StoreType as u64);
        bitfield_unit.set(16usize, 1u8, NoDuplication as u64);
        bitfield_unit.set(17usize, 1u8, NoCompression as u64);
        bitfield_unit.set(18usize, 12u8, EncryptionStrength as u64);
        bitfield_unit.set(30usize, 1u8, VirtualRegions as u64);
        bitfield_unit.set(31usize, 1u8, Spare0 as u64);
        bitfield_unit
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SM_STORE_TYPE {
    StoreTypeInMemory = 0,
    StoreTypeFile = 1,
    StoreTypeMax = 2,
}
#[repr(C)]
pub struct SM_STORE_BASIC_PARAMS {
    pub Anonymous1: SM_STORE_BASIC_PARAMS_1,
    pub Granularity: u32,
    pub RegionSize: u32,
    pub RegionCountMax: u32,
}
#[repr(C)]
pub struct SM_STORE_BASIC_PARAMS_1 {
    pub Anonymous1: UnionField<SM_STORE_BASIC_PARAMS_1_1>,
    pub StoreFlags: UnionField<u32>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SM_STORE_BASIC_PARAMS_1_1 {
    _bitfield_align_1: [u16; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SM_STORE_BASIC_PARAMS_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STORE_BASIC_PARAMS_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_STORE_BASIC_PARAMS_1_1 {{ StoreType : {:?}, NoDuplication : {:?}, FailNoCompression : {:?}, NoCompression : {:?}, NoEncryption : {:?}, NoEvictOnAdd : {:?}, PerformsFileIo : {:?}, VdlNotSet : {:?}, UseIntermediateAddBuffer : {:?}, CompressNoHuff : {:?}, LockActiveRegions : {:?}, VirtualRegions : {:?}, Spare : {:?} }}",
            self.StoreType(),
            self.NoDuplication(),
            self.FailNoCompression(),
            self.NoCompression(),
            self.NoEncryption(),
            self.NoEvictOnAdd(),
            self.PerformsFileIo(),
            self.VdlNotSet(),
            self.UseIntermediateAddBuffer(),
            self.CompressNoHuff(),
            self.LockActiveRegions(),
            self.VirtualRegions(),
            self.Spare()
        )
    }
}
impl SM_STORE_BASIC_PARAMS_1_1 {
    #[inline]
    pub fn StoreType(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_StoreType(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn NoDuplication(&self) -> u32 {
        self._bitfield_1.get(8usize, 1u8) as u32
    }
    #[inline]
    pub fn set_NoDuplication(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 1u8, val as u64)
    }
    #[inline]
    pub fn FailNoCompression(&self) -> u32 {
        self._bitfield_1.get(9usize, 1u8) as u32
    }
    #[inline]
    pub fn set_FailNoCompression(&mut self, val: u32) {
        self._bitfield_1.set(9usize, 1u8, val as u64)
    }
    #[inline]
    pub fn NoCompression(&self) -> u32 {
        self._bitfield_1.get(10usize, 1u8) as u32
    }
    #[inline]
    pub fn set_NoCompression(&mut self, val: u32) {
        self._bitfield_1.set(10usize, 1u8, val as u64)
    }
    #[inline]
    pub fn NoEncryption(&self) -> u32 {
        self._bitfield_1.get(11usize, 1u8) as u32
    }
    #[inline]
    pub fn set_NoEncryption(&mut self, val: u32) {
        self._bitfield_1.set(11usize, 1u8, val as u64)
    }
    #[inline]
    pub fn NoEvictOnAdd(&self) -> u32 {
        self._bitfield_1.get(12usize, 1u8) as u32
    }
    #[inline]
    pub fn set_NoEvictOnAdd(&mut self, val: u32) {
        self._bitfield_1.set(12usize, 1u8, val as u64)
    }
    #[inline]
    pub fn PerformsFileIo(&self) -> u32 {
        self._bitfield_1.get(13usize, 1u8) as u32
    }
    #[inline]
    pub fn set_PerformsFileIo(&mut self, val: u32) {
        self._bitfield_1.set(13usize, 1u8, val as u64)
    }
    #[inline]
    pub fn VdlNotSet(&self) -> u32 {
        self._bitfield_1.get(14usize, 1u8) as u32
    }
    #[inline]
    pub fn set_VdlNotSet(&mut self, val: u32) {
        self._bitfield_1.set(14usize, 1u8, val as u64)
    }
    #[inline]
    pub fn UseIntermediateAddBuffer(&self) -> u32 {
        self._bitfield_1.get(15usize, 1u8) as u32
    }
    #[inline]
    pub fn set_UseIntermediateAddBuffer(&mut self, val: u32) {
        self._bitfield_1.set(15usize, 1u8, val as u64)
    }
    #[inline]
    pub fn CompressNoHuff(&self) -> u32 {
        self._bitfield_1.get(16usize, 1u8) as u32
    }
    #[inline]
    pub fn set_CompressNoHuff(&mut self, val: u32) {
        self._bitfield_1.set(16usize, 1u8, val as u64)
    }
    #[inline]
    pub fn LockActiveRegions(&self) -> u32 {
        self._bitfield_1.get(17usize, 1u8) as u32
    }
    #[inline]
    pub fn set_LockActiveRegions(&mut self, val: u32) {
        self._bitfield_1.set(17usize, 1u8, val as u64)
    }
    #[inline]
    pub fn VirtualRegions(&self) -> u32 {
        self._bitfield_1.get(18usize, 1u8) as u32
    }
    #[inline]
    pub fn set_VirtualRegions(&mut self, val: u32) {
        self._bitfield_1.set(18usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(19usize, 13u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(19usize, 13u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        StoreType: u32,
        NoDuplication: u32,
        FailNoCompression: u32,
        NoCompression: u32,
        NoEncryption: u32,
        NoEvictOnAdd: u32,
        PerformsFileIo: u32,
        VdlNotSet: u32,
        UseIntermediateAddBuffer: u32,
        CompressNoHuff: u32,
        LockActiveRegions: u32,
        VirtualRegions: u32,
        Spare: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, StoreType as u64);
        bitfield_unit.set(8usize, 1u8, NoDuplication as u64);
        bitfield_unit.set(9usize, 1u8, FailNoCompression as u64);
        bitfield_unit.set(10usize, 1u8, NoCompression as u64);
        bitfield_unit.set(11usize, 1u8, NoEncryption as u64);
        bitfield_unit.set(12usize, 1u8, NoEvictOnAdd as u64);
        bitfield_unit.set(13usize, 1u8, PerformsFileIo as u64);
        bitfield_unit.set(14usize, 1u8, VdlNotSet as u64);
        bitfield_unit.set(15usize, 1u8, UseIntermediateAddBuffer as u64);
        bitfield_unit.set(16usize, 1u8, CompressNoHuff as u64);
        bitfield_unit.set(17usize, 1u8, LockActiveRegions as u64);
        bitfield_unit.set(18usize, 1u8, VirtualRegions as u64);
        bitfield_unit.set(19usize, 13u8, Spare as u64);
        bitfield_unit
    }
}
impl Default for SM_STORE_BASIC_PARAMS_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STORE_BASIC_PARAMS_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SM_STORE_BASIC_PARAMS_1 {{ union }}")
    }
}
impl Default for SM_STORE_BASIC_PARAMS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STORE_BASIC_PARAMS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_STORE_BASIC_PARAMS {{ Anonymous1: {:?} }}",
            self.Anonymous1
        )
    }
}
#[repr(C)]
pub struct SMKM_REGION_EXTENT {
    pub RegionCount: u32,
    pub ByteOffset: usize,
}
impl Default for SMKM_REGION_EXTENT {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMKM_REGION_EXTENT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SMKM_REGION_EXTENT {{  }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FILE_OBJECT {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DEVICE_OBJECT {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRP {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct SMKM_FILE_INFO {
    pub FileHandle: HANDLE,
    pub FileObject: *mut FILE_OBJECT,
    pub VolumeFileObject: *mut FILE_OBJECT,
    pub VolumeDeviceObject: *mut DEVICE_OBJECT,
    pub VolumePnpHandle: HANDLE,
    pub UsageNotificationIrp: *mut IRP,
    pub Extents: *mut SMKM_REGION_EXTENT,
    pub ExtentCount: u32,
}
impl Default for SMKM_FILE_INFO {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMKM_FILE_INFO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMKM_FILE_INFO {{ FileObject: {:?}, VolumeFileObject: {:?}, VolumeDeviceObject: {:?}, UsageNotificationIrp: {:?}, Extents: {:?} }}",
            self.FileObject,
            self.VolumeFileObject,
            self.VolumeDeviceObject,
            self.UsageNotificationIrp,
            self.Extents
        )
    }
}
#[repr(C)]
pub struct SM_STORE_CACHE_BACKED_PARAMS {
    pub SectorSize: u32,
    pub EncryptionKey: *mut i8,
    pub EncryptionKeySize: u32,
    pub FileInfo: *mut SMKM_FILE_INFO,
    pub EtaContext: *mut std::ffi::c_void,
    pub StoreRegionBitmap: *mut RTL_BITMAP,
}
impl Default for SM_STORE_CACHE_BACKED_PARAMS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STORE_CACHE_BACKED_PARAMS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_STORE_CACHE_BACKED_PARAMS {{ FileInfo: {:?}, StoreRegionBitmap: {:?} }}",
            self.FileInfo, self.StoreRegionBitmap
        )
    }
}
#[repr(C)]
pub struct SM_STORE_PARAMETERS {
    pub Store: SM_STORE_BASIC_PARAMS,
    pub Priority: u32,
    pub Flags: u32,
    pub CacheBacked: SM_STORE_CACHE_BACKED_PARAMS,
}
impl Default for SM_STORE_PARAMETERS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STORE_PARAMETERS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_STORE_PARAMETERS {{ Store: {:?}, CacheBacked: {:?} }}",
            self.Store, self.CacheBacked
        )
    }
}
#[repr(C)]
pub struct SM_CREATE_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub Params: SM_STORE_PARAMETERS,
    pub StoreId: u32,
}
impl Default for SM_CREATE_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_CREATE_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_CREATE_REQUEST {{ Version : {:?}, AcquireReference : {:?}, KeyedStore : {:?}, Spare : {:?}, Params: {:?} }}",
            self.Version(),
            self.AcquireReference(),
            self.KeyedStore(),
            self.Spare(),
            self.Params
        )
    }
}
impl SM_CREATE_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn AcquireReference(&self) -> u32 {
        self._bitfield_1.get(8usize, 1u8) as u32
    }
    #[inline]
    pub fn set_AcquireReference(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 1u8, val as u64)
    }
    #[inline]
    pub fn KeyedStore(&self) -> u32 {
        self._bitfield_1.get(9usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KeyedStore(&mut self, val: u32) {
        self._bitfield_1.set(9usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(10usize, 22u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(10usize, 22u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        Version: u32,
        AcquireReference: u32,
        KeyedStore: u32,
        Spare: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 1u8, AcquireReference as u64);
        bitfield_unit.set(9usize, 1u8, KeyedStore as u64);
        bitfield_unit.set(10usize, 22u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SM_DELETE_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub StoreId: u32,
}
impl Default for SM_DELETE_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_DELETE_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_DELETE_REQUEST {{ Version : {:?}, Spare : {:?} }}",
            self.Version(),
            self.Spare()
        )
    }
}
impl SM_DELETE_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(8usize, 24u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 24u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 24u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SM_STORE_LIST_REQUEST {
    _bitfield_align_1: [u16; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub StoreId: [u32; 32usize],
}
impl Default for SM_STORE_LIST_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STORE_LIST_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_STORE_LIST_REQUEST {{ Version : {:?}, StoreCount : {:?}, ExtendedRequest : {:?}, Spare : {:?}, StoreId: {:?} }}",
            self.Version(),
            self.StoreCount(),
            self.ExtendedRequest(),
            self.Spare(),
            self.StoreId
        )
    }
}
impl SM_STORE_LIST_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn StoreCount(&self) -> u32 {
        self._bitfield_1.get(8usize, 8u8) as u32
    }
    #[inline]
    pub fn set_StoreCount(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 8u8, val as u64)
    }
    #[inline]
    pub fn ExtendedRequest(&self) -> u32 {
        self._bitfield_1.get(16usize, 1u8) as u32
    }
    #[inline]
    pub fn set_ExtendedRequest(&mut self, val: u32) {
        self._bitfield_1.set(16usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(17usize, 15u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(17usize, 15u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        Version: u32,
        StoreCount: u32,
        ExtendedRequest: u32,
        Spare: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 8u8, StoreCount as u64);
        bitfield_unit.set(16usize, 1u8, ExtendedRequest as u64);
        bitfield_unit.set(17usize, 15u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SM_STORE_LIST_REQUEST_EX {
    pub Request: SM_STORE_LIST_REQUEST,
    pub NameBuffer: [[u16; 64usize]; 32usize],
}
impl Default for SM_STORE_LIST_REQUEST_EX {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STORE_LIST_REQUEST_EX {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_STORE_LIST_REQUEST_EX {{ Request: {:?}, NameBuffer: {:?} }}",
            self.Request, self.NameBuffer
        )
    }
}
#[repr(C)]
pub struct SMC_CACHE_LIST_REQUEST {
    _bitfield_align_1: [u16; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub CacheId: [u32; 16usize],
}
impl Default for SMC_CACHE_LIST_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_CACHE_LIST_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_CACHE_LIST_REQUEST {{ Version : {:?}, CacheCount : {:?}, Spare : {:?}, CacheId: {:?} }}",
            self.Version(),
            self.CacheCount(),
            self.Spare(),
            self.CacheId
        )
    }
}
impl SMC_CACHE_LIST_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn CacheCount(&self) -> u32 {
        self._bitfield_1.get(8usize, 8u8) as u32
    }
    #[inline]
    pub fn set_CacheCount(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(16usize, 16u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(16usize, 16u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, CacheCount: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 8u8, CacheCount as u64);
        bitfield_unit.set(16usize, 16u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SMC_CACHE_PARAMETERS {
    pub CacheFileSize: usize,
    pub StoreAlignment: u32,
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub CacheFlags: u32,
    pub Priority: u32,
}
impl Default for SMC_CACHE_PARAMETERS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_CACHE_PARAMETERS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_CACHE_PARAMETERS {{ PerformsFileIo : {:?}, VdlNotSet : {:?}, Spare : {:?} }}",
            self.PerformsFileIo(),
            self.VdlNotSet(),
            self.Spare()
        )
    }
}
impl SMC_CACHE_PARAMETERS {
    #[inline]
    pub fn PerformsFileIo(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_PerformsFileIo(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn VdlNotSet(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_VdlNotSet(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(2usize, 30u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(2usize, 30u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        PerformsFileIo: u32,
        VdlNotSet: u32,
        Spare: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, PerformsFileIo as u64);
        bitfield_unit.set(1usize, 1u8, VdlNotSet as u64);
        bitfield_unit.set(2usize, 30u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SMC_CACHE_CREATE_PARAMETERS {
    pub CacheParameters: SMC_CACHE_PARAMETERS,
    pub TemplateFilePath: [u16; 512usize],
}
impl Default for SMC_CACHE_CREATE_PARAMETERS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_CACHE_CREATE_PARAMETERS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_CACHE_CREATE_PARAMETERS {{ CacheParameters: {:?}, TemplateFilePath: {:?} }}",
            self.CacheParameters, self.TemplateFilePath
        )
    }
}
#[repr(C)]
pub struct SMC_CACHE_CREATE_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub CacheId: u32,
    pub CacheCreateParams: SMC_CACHE_CREATE_PARAMETERS,
}
impl Default for SMC_CACHE_CREATE_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_CACHE_CREATE_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_CACHE_CREATE_REQUEST {{ Version : {:?}, Spare : {:?}, CacheCreateParams: {:?} }}",
            self.Version(),
            self.Spare(),
            self.CacheCreateParams
        )
    }
}
impl SMC_CACHE_CREATE_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(8usize, 24u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 24u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 24u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SMC_CACHE_DELETE_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub CacheId: u32,
}
impl Default for SMC_CACHE_DELETE_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_CACHE_DELETE_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_CACHE_DELETE_REQUEST {{ Version : {:?}, Spare : {:?} }}",
            self.Version(),
            self.Spare()
        )
    }
}
impl SMC_CACHE_DELETE_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(8usize, 24u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 24u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 24u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SM_STORE_MANAGER_TYPE {
    SmStoreManagerTypePhysical = 0,
    SmStoreManagerTypeVirtual = 1,
    SmStoreManagerTypeMax = 2,
}
#[repr(C)]
pub struct SMC_STORE_CREATE_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub StoreParams: SM_STORE_BASIC_PARAMS,
    pub CacheId: u32,
    pub StoreManagerType: SM_STORE_MANAGER_TYPE,
    pub StoreId: u32,
}
impl Default for SMC_STORE_CREATE_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_STORE_CREATE_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_STORE_CREATE_REQUEST {{ Version : {:?}, Spare : {:?}, StoreParams: {:?}, StoreManagerType: {:?} }}",
            self.Version(),
            self.Spare(),
            self.StoreParams,
            self.StoreManagerType
        )
    }
}
impl SMC_STORE_CREATE_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(8usize, 24u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 24u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 24u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SMC_STORE_DELETE_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub CacheId: u32,
    pub StoreManagerType: SM_STORE_MANAGER_TYPE,
    pub StoreId: u32,
}
impl Default for SMC_STORE_DELETE_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_STORE_DELETE_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_STORE_DELETE_REQUEST {{ Version : {:?}, Spare : {:?}, StoreManagerType: {:?} }}",
            self.Version(),
            self.Spare(),
            self.StoreManagerType
        )
    }
}
impl SMC_STORE_DELETE_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(8usize, 24u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 24u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 24u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SMC_CACHE_STATS {
    pub TotalFileSize: usize,
    pub StoreCount: u32,
    pub RegionCount: u32,
    pub RegionSizeBytes: u32,
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub StoreIds: [u32; 16usize],
    pub PhysicalStoreBitmap: u32,
    pub Priority: u32,
    pub TemplateFilePath: [u16; 512usize],
}
impl Default for SMC_CACHE_STATS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_CACHE_STATS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_CACHE_STATS {{ FileCount : {:?}, PerformsFileIo : {:?}, Spare : {:?}, StoreIds: {:?}, TemplateFilePath: {:?} }}",
            self.FileCount(),
            self.PerformsFileIo(),
            self.Spare(),
            self.StoreIds,
            self.TemplateFilePath
        )
    }
}
impl SMC_CACHE_STATS {
    #[inline]
    pub fn FileCount(&self) -> u32 {
        self._bitfield_1.get(0usize, 6u8) as u32
    }
    #[inline]
    pub fn set_FileCount(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 6u8, val as u64)
    }
    #[inline]
    pub fn PerformsFileIo(&self) -> u32 {
        self._bitfield_1.get(6usize, 1u8) as u32
    }
    #[inline]
    pub fn set_PerformsFileIo(&mut self, val: u32) {
        self._bitfield_1.set(6usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(7usize, 25u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(7usize, 25u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        FileCount: u32,
        PerformsFileIo: u32,
        Spare: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 6u8, FileCount as u64);
        bitfield_unit.set(6usize, 1u8, PerformsFileIo as u64);
        bitfield_unit.set(7usize, 25u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SMC_CACHE_STATS_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub CacheId: u32,
    pub CacheStats: SMC_CACHE_STATS,
}
impl Default for SMC_CACHE_STATS_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_CACHE_STATS_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_CACHE_STATS_REQUEST {{ Version : {:?}, NoFilePath : {:?}, Spare : {:?}, CacheStats: {:?} }}",
            self.Version(),
            self.NoFilePath(),
            self.Spare(),
            self.CacheStats
        )
    }
}
impl SMC_CACHE_STATS_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn NoFilePath(&self) -> u32 {
        self._bitfield_1.get(8usize, 1u8) as u32
    }
    #[inline]
    pub fn set_NoFilePath(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(9usize, 23u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(9usize, 23u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, NoFilePath: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 1u8, NoFilePath as u64);
        bitfield_unit.set(9usize, 23u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SM_REGISTRATION_INFO {
    pub CachesUpdatedEvent: HANDLE,
}
impl Default for SM_REGISTRATION_INFO {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_REGISTRATION_INFO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SM_REGISTRATION_INFO {{  }}")
    }
}
#[repr(C)]
pub struct SM_REGISTRATION_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub RegInfo: SM_REGISTRATION_INFO,
}
impl Default for SM_REGISTRATION_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_REGISTRATION_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_REGISTRATION_REQUEST {{ Version : {:?}, Spare : {:?}, RegInfo: {:?} }}",
            self.Version(),
            self.Spare(),
            self.RegInfo
        )
    }
}
impl SM_REGISTRATION_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(8usize, 24u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 24u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 24u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SM_STORE_RESIZE_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub StoreId: u32,
    pub NumberOfRegions: u32,
    pub RegionBitmap: *mut RTL_BITMAP,
}
impl Default for SM_STORE_RESIZE_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STORE_RESIZE_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_STORE_RESIZE_REQUEST {{ Version : {:?}, AddRegions : {:?}, Spare : {:?}, RegionBitmap: {:?} }}",
            self.Version(),
            self.AddRegions(),
            self.Spare(),
            self.RegionBitmap
        )
    }
}
impl SM_STORE_RESIZE_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn AddRegions(&self) -> u32 {
        self._bitfield_1.get(8usize, 1u8) as u32
    }
    #[inline]
    pub fn set_AddRegions(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(9usize, 23u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(9usize, 23u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, AddRegions: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 1u8, AddRegions as u64);
        bitfield_unit.set(9usize, 23u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SMC_STORE_RESIZE_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub CacheId: u32,
    pub StoreId: u32,
    pub StoreManagerType: SM_STORE_MANAGER_TYPE,
    pub RegionCount: u32,
}
impl Default for SMC_STORE_RESIZE_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SMC_STORE_RESIZE_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SMC_STORE_RESIZE_REQUEST {{ Version : {:?}, AddRegions : {:?}, Spare : {:?}, StoreManagerType: {:?} }}",
            self.Version(),
            self.AddRegions(),
            self.Spare(),
            self.StoreManagerType
        )
    }
}
impl SMC_STORE_RESIZE_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn AddRegions(&self) -> u32 {
        self._bitfield_1.get(8usize, 1u8) as u32
    }
    #[inline]
    pub fn set_AddRegions(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(9usize, 23u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(9usize, 23u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, AddRegions: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 1u8, AddRegions as u64);
        bitfield_unit.set(9usize, 23u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SM_CONFIG_TYPE {
    SmConfigDirtyPageCompression = 0,
    SmConfigAsyncInswap = 1,
    SmConfigPrefetchSeekThreshold = 2,
    SmConfigTypeMax = 3,
}
#[repr(C)]
pub struct SM_CONFIG_REQUEST {
    _bitfield_align_1: [u16; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub ConfigValue: u32,
}
impl Default for SM_CONFIG_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_CONFIG_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_CONFIG_REQUEST {{ Version : {:?}, Spare : {:?}, ConfigType : {:?} }}",
            self.Version(),
            self.Spare(),
            self.ConfigType()
        )
    }
}
impl SM_CONFIG_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(8usize, 16u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 16u8, val as u64)
    }
    #[inline]
    pub fn ConfigType(&self) -> u32 {
        self._bitfield_1.get(24usize, 8u8) as u32
    }
    #[inline]
    pub fn set_ConfigType(&mut self, val: u32) {
        self._bitfield_1.set(24usize, 8u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, Spare: u32, ConfigType: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 16u8, Spare as u64);
        bitfield_unit.set(24usize, 8u8, ConfigType as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub ProcessHandle: HANDLE,
}
impl Default for SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_STORE_HIGH_MEM_PRIORITY_REQUEST {{ Version : {:?}, SetHighMemoryPriority : {:?}, Spare : {:?} }}",
            self.Version(),
            self.SetHighMemoryPriority(),
            self.Spare()
        )
    }
}
impl SM_STORE_HIGH_MEM_PRIORITY_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn SetHighMemoryPriority(&self) -> u32 {
        self._bitfield_1.get(8usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SetHighMemoryPriority(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(9usize, 23u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(9usize, 23u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        Version: u32,
        SetHighMemoryPriority: u32,
        Spare: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 1u8, SetHighMemoryPriority as u64);
        bitfield_unit.set(9usize, 23u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SM_SYSTEM_STORE_TRIM_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub PagesToTrim: usize,
}
impl Default for SM_SYSTEM_STORE_TRIM_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_SYSTEM_STORE_TRIM_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_SYSTEM_STORE_TRIM_REQUEST {{ Version : {:?}, Spare : {:?} }}",
            self.Version(),
            self.Spare()
        )
    }
}
impl SM_SYSTEM_STORE_TRIM_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(8usize, 24u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 24u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 24u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SM_MEM_COMPRESSION_INFO_REQUEST {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
    pub CompressionPid: u32,
    pub WorkingSetSize: u32,
    pub TotalDataCompressed: usize,
    pub TotalCompressedSize: usize,
    pub TotalUniqueDataCompressed: usize,
}
impl Default for SM_MEM_COMPRESSION_INFO_REQUEST {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SM_MEM_COMPRESSION_INFO_REQUEST {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SM_MEM_COMPRESSION_INFO_REQUEST {{ Version : {:?}, Spare : {:?} }}",
            self.Version(),
            self.Spare()
        )
    }
}
impl SM_MEM_COMPRESSION_INFO_REQUEST {
    #[inline]
    pub fn Version(&self) -> u32 {
        self._bitfield_1.get(0usize, 8u8) as u32
    }
    #[inline]
    pub fn set_Version(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 8u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(8usize, 24u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 24u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Version: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 8u8, Version as u64);
        bitfield_unit.set(8usize, 24u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS {
    pub KeyHandle: HANDLE,
    pub ValueNamePointer: *mut UNICODE_STRING,
    pub RequiredLengthPointer: *mut u32,
    pub Buffer: *mut u8,
    pub BufferLength: u32,
    pub Type: u32,
    pub AppendBuffer: *mut u8,
    pub AppendBufferLength: u32,
    pub CreateIfDoesntExist: BOOLEAN,
    pub TruncateExistingValue: BOOLEAN,
}
impl Default for SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_VHD_BOOT_INFORMATION {
    pub OsDiskIsVhd: BOOLEAN,
    pub OsVhdFilePathOffset: u32,
    pub OsVhdParentVolume: [u16; 1usize],
}
impl Default for SYSTEM_VHD_BOOT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VHD_BOOT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_VHD_BOOT_INFORMATION {{ OsVhdParentVolume: {:?} }}",
            self.OsVhdParentVolume
        )
    }
}
#[repr(C)]
pub struct PS_CPU_QUOTA_QUERY_ENTRY {
    pub SessionId: u32,
    pub Weight: u32,
}
impl Default for PS_CPU_QUOTA_QUERY_ENTRY {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PS_CPU_QUOTA_QUERY_ENTRY {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PS_CPU_QUOTA_QUERY_ENTRY {{  }}")
    }
}
#[repr(C)]
pub struct PS_CPU_QUOTA_QUERY_INFORMATION {
    pub SessionCount: u32,
    pub SessionInformation: [PS_CPU_QUOTA_QUERY_ENTRY; 1usize],
}
impl Default for PS_CPU_QUOTA_QUERY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PS_CPU_QUOTA_QUERY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PS_CPU_QUOTA_QUERY_INFORMATION {{ SessionInformation: {:?} }}",
            self.SessionInformation
        )
    }
}
#[repr(C)]
pub struct SYSTEM_ERROR_PORT_TIMEOUTS {
    pub StartTimeout: u32,
    pub CommTimeout: u32,
}
impl Default for SYSTEM_ERROR_PORT_TIMEOUTS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ERROR_PORT_TIMEOUTS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_ERROR_PORT_TIMEOUTS {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_LOW_PRIORITY_IO_INFORMATION {
    pub LowPriReadOperations: u32,
    pub LowPriWriteOperations: u32,
    pub KernelBumpedToNormalOperations: u32,
    pub LowPriPagingReadOperations: u32,
    pub KernelPagingReadsBumpedToNormal: u32,
    pub LowPriPagingWriteOperations: u32,
    pub KernelPagingWritesBumpedToNormal: u32,
    pub BoostedIrpCount: u32,
    pub BoostedPagingIrpCount: u32,
    pub BlanketBoostCount: u32,
}
impl Default for SYSTEM_LOW_PRIORITY_IO_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_LOW_PRIORITY_IO_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_LOW_PRIORITY_IO_INFORMATION {{  }}")
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TPM_BOOT_ENTROPY_RESULT_CODE {
    TpmBootEntropyStructureUninitialized = 0,
    TpmBootEntropyDisabledByPolicy = 1,
    TpmBootEntropyNoTpmFound = 2,
    TpmBootEntropyTpmError = 3,
    TpmBootEntropySuccess = 4,
}
#[repr(C)]
pub struct TPM_BOOT_ENTROPY_NT_RESULT {
    pub Policy: u64,
    pub ResultCode: TPM_BOOT_ENTROPY_RESULT_CODE,
    pub ResultStatus: NTSTATUS,
    pub Time: u64,
    pub EntropyLength: u32,
    pub EntropyData: [u8; 40usize],
}
impl Default for TPM_BOOT_ENTROPY_NT_RESULT {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for TPM_BOOT_ENTROPY_NT_RESULT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "TPM_BOOT_ENTROPY_NT_RESULT {{ ResultCode: {:?}, EntropyData: {:?} }}",
            self.ResultCode, self.EntropyData
        )
    }
}
#[repr(C)]
pub struct SYSTEM_VERIFIER_COUNTERS_INFORMATION {
    pub Legacy: SYSTEM_VERIFIER_INFORMATION,
    pub RaiseIrqls: u32,
    pub AcquireSpinLocks: u32,
    pub SynchronizeExecutions: u32,
    pub AllocationsWithNoTag: u32,
    pub AllocationsFailed: u32,
    pub AllocationsFailedDeliberately: u32,
    pub LockedBytes: usize,
    pub PeakLockedBytes: usize,
    pub MappedLockedBytes: usize,
    pub PeakMappedLockedBytes: usize,
    pub MappedIoSpaceBytes: usize,
    pub PeakMappedIoSpaceBytes: usize,
    pub PagesForMdlBytes: usize,
    pub PeakPagesForMdlBytes: usize,
    pub ContiguousMemoryBytes: usize,
    pub PeakContiguousMemoryBytes: usize,
    pub ExecutePoolTypes: u32,
    pub ExecutePageProtections: u32,
    pub ExecutePageMappings: u32,
    pub ExecuteWriteSections: u32,
    pub SectionAlignmentFailures: u32,
    pub UnsupportedRelocs: u32,
    pub IATInExecutableSection: u32,
}
impl Default for SYSTEM_VERIFIER_COUNTERS_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VERIFIER_COUNTERS_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_VERIFIER_COUNTERS_INFORMATION {{ Legacy: {:?} }}",
            self.Legacy
        )
    }
}
#[repr(C)]
pub struct SYSTEM_ACPI_AUDIT_INFORMATION {
    pub RsdpCount: u32,
    _bitfield_align_1: [u8; 0],
    _bitfield_1: BitfieldUnit<[u8; 1usize]>,
    pub padding_0: [u8; 3usize],
}
impl Default for SYSTEM_ACPI_AUDIT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ACPI_AUDIT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_ACPI_AUDIT_INFORMATION {{ SameRsdt : {:?}, SlicPresent : {:?}, SlicDifferent : {:?} }}",
            self.SameRsdt(),
            self.SlicPresent(),
            self.SlicDifferent()
        )
    }
}
impl SYSTEM_ACPI_AUDIT_INFORMATION {
    #[inline]
    pub fn SameRsdt(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SameRsdt(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SlicPresent(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SlicPresent(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SlicDifferent(&self) -> u32 {
        self._bitfield_1.get(2usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SlicDifferent(&mut self, val: u32) {
        self._bitfield_1.set(2usize, 1u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        SameRsdt: u32,
        SlicPresent: u32,
        SlicDifferent: u32,
    ) -> BitfieldUnit<[u8; 1usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 1usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, SameRsdt as u64);
        bitfield_unit.set(1usize, 1u8, SlicPresent as u64);
        bitfield_unit.set(2usize, 1u8, SlicDifferent as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SYSTEM_BASIC_PERFORMANCE_INFORMATION {
    pub AvailablePages: usize,
    pub CommittedPages: usize,
    pub CommitLimit: usize,
    pub PeakCommitment: usize,
}
impl Default for SYSTEM_BASIC_PERFORMANCE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BASIC_PERFORMANCE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_BASIC_PERFORMANCE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct QUERY_PERFORMANCE_COUNTER_FLAGS {
    pub Anonymous1: QUERY_PERFORMANCE_COUNTER_FLAGS_1,
}
#[repr(C)]
pub struct QUERY_PERFORMANCE_COUNTER_FLAGS_1 {
    pub Anonymous1: UnionField<QUERY_PERFORMANCE_COUNTER_FLAGS_1_1>,
    pub ul: UnionField<u32>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct QUERY_PERFORMANCE_COUNTER_FLAGS_1_1 {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for QUERY_PERFORMANCE_COUNTER_FLAGS_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for QUERY_PERFORMANCE_COUNTER_FLAGS_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "QUERY_PERFORMANCE_COUNTER_FLAGS_1_1 {{ KernelTransition : {:?}, Reserved : {:?} }}",
            self.KernelTransition(),
            self.Reserved()
        )
    }
}
impl QUERY_PERFORMANCE_COUNTER_FLAGS_1_1 {
    #[inline]
    pub fn KernelTransition(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KernelTransition(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(1usize, 31u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 31u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(KernelTransition: u32, Reserved: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, KernelTransition as u64);
        bitfield_unit.set(1usize, 31u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for QUERY_PERFORMANCE_COUNTER_FLAGS_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for QUERY_PERFORMANCE_COUNTER_FLAGS_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "QUERY_PERFORMANCE_COUNTER_FLAGS_1 {{ union }}")
    }
}
impl Default for QUERY_PERFORMANCE_COUNTER_FLAGS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for QUERY_PERFORMANCE_COUNTER_FLAGS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "QUERY_PERFORMANCE_COUNTER_FLAGS {{ Anonymous1: {:?} }}",
            self.Anonymous1
        )
    }
}
#[repr(C)]
pub struct SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION {
    pub Version: u32,
    pub Flags: QUERY_PERFORMANCE_COUNTER_FLAGS,
    pub ValidFlags: QUERY_PERFORMANCE_COUNTER_FLAGS,
}
impl Default for SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION {{ Flags: {:?}, ValidFlags: {:?} }}",
            self.Flags, self.ValidFlags
        )
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_PIXEL_FORMAT {
    SystemPixelFormatUnknown = 0,
    SystemPixelFormatR8G8B8 = 1,
    SystemPixelFormatR8G8B8X8 = 2,
    SystemPixelFormatB8G8R8 = 3,
    SystemPixelFormatB8G8R8X8 = 4,
}
#[repr(C)]
pub struct SYSTEM_BOOT_GRAPHICS_INFORMATION {
    pub FrameBuffer: i64,
    pub Width: u32,
    pub Height: u32,
    pub PixelStride: u32,
    pub Flags: u32,
    pub Format: SYSTEM_PIXEL_FORMAT,
    pub DisplayRotation: u32,
}
impl Default for SYSTEM_BOOT_GRAPHICS_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BOOT_GRAPHICS_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_BOOT_GRAPHICS_INFORMATION {{ Format: {:?} }}",
            self.Format
        )
    }
}
#[repr(C)]
pub struct MEMORY_SCRUB_INFORMATION {
    pub Handle: HANDLE,
    pub PagesScrubbed: u32,
}
impl Default for MEMORY_SCRUB_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for MEMORY_SCRUB_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MEMORY_SCRUB_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct PEBS_DS_SAVE_AREA32 {
    pub BtsBufferBase: u32,
    pub BtsIndex: u32,
    pub BtsAbsoluteMaximum: u32,
    pub BtsInterruptThreshold: u32,
    pub PebsBufferBase: u32,
    pub PebsIndex: u32,
    pub PebsAbsoluteMaximum: u32,
    pub PebsInterruptThreshold: u32,
    pub PebsGpCounterReset: [u32; 8usize],
    pub PebsFixedCounterReset: [u32; 4usize],
}
impl Default for PEBS_DS_SAVE_AREA32 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PEBS_DS_SAVE_AREA32 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PEBS_DS_SAVE_AREA32 {{ PebsGpCounterReset: {:?}, PebsFixedCounterReset: {:?} }}",
            self.PebsGpCounterReset, self.PebsFixedCounterReset
        )
    }
}
#[repr(C)]
pub struct PEBS_DS_SAVE_AREA64 {
    pub BtsBufferBase: u64,
    pub BtsIndex: u64,
    pub BtsAbsoluteMaximum: u64,
    pub BtsInterruptThreshold: u64,
    pub PebsBufferBase: u64,
    pub PebsIndex: u64,
    pub PebsAbsoluteMaximum: u64,
    pub PebsInterruptThreshold: u64,
    pub PebsGpCounterReset: [u64; 8usize],
    pub PebsFixedCounterReset: [u64; 4usize],
}
impl Default for PEBS_DS_SAVE_AREA64 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PEBS_DS_SAVE_AREA64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PEBS_DS_SAVE_AREA64 {{ PebsGpCounterReset: {:?}, PebsFixedCounterReset: {:?} }}",
            self.PebsGpCounterReset, self.PebsFixedCounterReset
        )
    }
}
#[repr(C)]
pub struct PEBS_DS_SAVE_AREA {
    pub As32Bit: UnionField<PEBS_DS_SAVE_AREA32>,
    pub As64Bit: UnionField<PEBS_DS_SAVE_AREA64>,
    pub union_field: [u64; 20usize],
}
impl Default for PEBS_DS_SAVE_AREA {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PEBS_DS_SAVE_AREA {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PEBS_DS_SAVE_AREA {{ union }}")
    }
}
#[repr(C)]
pub struct PROCESSOR_PROFILE_CONTROL_AREA {
    pub PebsDsSaveArea: PEBS_DS_SAVE_AREA,
}
impl Default for PROCESSOR_PROFILE_CONTROL_AREA {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESSOR_PROFILE_CONTROL_AREA {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PROCESSOR_PROFILE_CONTROL_AREA {{ PebsDsSaveArea: {:?} }}",
            self.PebsDsSaveArea
        )
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA {
    pub ProcessorProfileControlArea: PROCESSOR_PROFILE_CONTROL_AREA,
    pub Allocate: BOOLEAN,
}
impl Default for SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA {{ ProcessorProfileControlArea: {:?} }}",
            self.ProcessorProfileControlArea
        )
    }
}
#[repr(C)]
pub struct MEMORY_COMBINE_INFORMATION {
    pub Handle: HANDLE,
    pub PagesCombined: usize,
}
impl Default for MEMORY_COMBINE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for MEMORY_COMBINE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MEMORY_COMBINE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct MEMORY_COMBINE_INFORMATION_EX {
    pub Handle: HANDLE,
    pub PagesCombined: usize,
    pub Flags: u32,
}
impl Default for MEMORY_COMBINE_INFORMATION_EX {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for MEMORY_COMBINE_INFORMATION_EX {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MEMORY_COMBINE_INFORMATION_EX {{  }}")
    }
}
#[repr(C)]
pub struct MEMORY_COMBINE_INFORMATION_EX2 {
    pub Handle: HANDLE,
    pub PagesCombined: usize,
    pub Flags: u32,
    pub ProcessHandle: HANDLE,
}
impl Default for MEMORY_COMBINE_INFORMATION_EX2 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for MEMORY_COMBINE_INFORMATION_EX2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MEMORY_COMBINE_INFORMATION_EX2 {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_ENTROPY_TIMING_INFORMATION {
    pub EntropyRoutine:
        std::option::Option<unsafe extern "system" fn(arg1: *mut std::ffi::c_void, arg2: u32)>,
    pub InitializationRoutine: std::option::Option<
        unsafe extern "system" fn(
            arg1: *mut std::ffi::c_void,
            arg2: u32,
            arg3: *mut std::ffi::c_void,
        ),
    >,
    pub InitializationContext: *mut std::ffi::c_void,
}
impl Default for SYSTEM_ENTROPY_TIMING_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ENTROPY_TIMING_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_ENTROPY_TIMING_INFORMATION {{ EntropyRoutine: {:?}, InitializationRoutine: {:?} }}",
            self.EntropyRoutine, self.InitializationRoutine
        )
    }
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_CONSOLE_INFORMATION {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSTEM_CONSOLE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CONSOLE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_CONSOLE_INFORMATION {{ DriverLoaded : {:?}, Spare : {:?} }}",
            self.DriverLoaded(),
            self.Spare()
        )
    }
}
impl SYSTEM_CONSOLE_INFORMATION {
    #[inline]
    pub fn DriverLoaded(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_DriverLoaded(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(1usize, 31u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 31u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(DriverLoaded: u32, Spare: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, DriverLoaded as u64);
        bitfield_unit.set(1usize, 31u8, Spare as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SYSTEM_PLATFORM_BINARY_INFORMATION {
    pub PhysicalAddress: u64,
    pub HandoffBuffer: *mut std::ffi::c_void,
    pub CommandLineBuffer: *mut std::ffi::c_void,
    pub HandoffBufferSize: u32,
    pub CommandLineBufferSize: u32,
}
impl Default for SYSTEM_PLATFORM_BINARY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PLATFORM_BINARY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PLATFORM_BINARY_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_POLICY_INFORMATION {
    pub InputData: *mut std::ffi::c_void,
    pub OutputData: *mut std::ffi::c_void,
    pub InputDataSize: u32,
    pub OutputDataSize: u32,
    pub Version: u32,
}
impl Default for SYSTEM_POLICY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POLICY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_POLICY_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION {
    pub NumberOfLogicalProcessors: u32,
    pub NumberOfCores: u32,
}
impl Default for SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_DEVICE_DATA_INFORMATION {
    pub DeviceId: UNICODE_STRING,
    pub DataName: UNICODE_STRING,
    pub DataType: u32,
    pub DataBufferLength: u32,
    pub DataBuffer: *mut std::ffi::c_void,
}
impl Default for SYSTEM_DEVICE_DATA_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_DEVICE_DATA_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_DEVICE_DATA_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct PHYSICAL_CHANNEL_RUN {
    pub NodeNumber: u32,
    pub ChannelNumber: u32,
    pub BasePage: u64,
    pub PageCount: u64,
    pub Flags: u32,
}
impl Default for PHYSICAL_CHANNEL_RUN {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PHYSICAL_CHANNEL_RUN {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PHYSICAL_CHANNEL_RUN {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_MEMORY_TOPOLOGY_INFORMATION {
    pub NumberOfRuns: u64,
    pub NumberOfNodes: u32,
    pub NumberOfChannels: u32,
    pub Run: [PHYSICAL_CHANNEL_RUN; 1usize],
}
impl Default for SYSTEM_MEMORY_TOPOLOGY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_MEMORY_TOPOLOGY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_MEMORY_TOPOLOGY_INFORMATION {{ Run: {:?} }}",
            self.Run
        )
    }
}
#[repr(C)]
pub struct SYSTEM_MEMORY_CHANNEL_INFORMATION {
    pub ChannelNumber: u32,
    pub ChannelHeatIndex: u32,
    pub TotalPageCount: u64,
    pub ZeroPageCount: u64,
    pub FreePageCount: u64,
    pub StandbyPageCount: u64,
}
impl Default for SYSTEM_MEMORY_CHANNEL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_MEMORY_CHANNEL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_MEMORY_CHANNEL_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_BOOT_LOGO_INFORMATION {
    pub Flags: u32,
    pub BitmapOffset: u32,
}
impl Default for SYSTEM_BOOT_LOGO_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BOOT_LOGO_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_BOOT_LOGO_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX {
    pub IdleTime: i64,
    pub KernelTime: i64,
    pub UserTime: i64,
    pub DpcTime: i64,
    pub InterruptTime: i64,
    pub InterruptCount: u32,
    pub Spare0: u32,
    pub AvailableTime: i64,
    pub Spare1: i64,
    pub Spare2: i64,
}
impl Default for SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_SECUREBOOT_POLICY_INFORMATION {
    pub PolicyPublisher: GUID,
    pub PolicyVersion: u32,
    pub PolicyOptions: u32,
}
impl Default for SYSTEM_SECUREBOOT_POLICY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SECUREBOOT_POLICY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SECUREBOOT_POLICY_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PAGEFILE_INFORMATION_EX {
    pub Anonymous1: SYSTEM_PAGEFILE_INFORMATION_EX_1,
    pub MinimumSize: u32,
    pub MaximumSize: u32,
}
#[repr(C)]
pub struct SYSTEM_PAGEFILE_INFORMATION_EX_1 {
    pub Info: UnionField<SYSTEM_PAGEFILE_INFORMATION>,
    pub Anonymous1: UnionField<SYSTEM_PAGEFILE_INFORMATION_EX_1_1>,
    pub union_field: [u64; 4usize],
}
#[repr(C)]
pub struct SYSTEM_PAGEFILE_INFORMATION_EX_1_1 {
    pub NextEntryOffset: u32,
    pub TotalSize: u32,
    pub TotalInUse: u32,
    pub PeakUsage: u32,
    pub PageFileName: UNICODE_STRING,
}
impl Default for SYSTEM_PAGEFILE_INFORMATION_EX_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PAGEFILE_INFORMATION_EX_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PAGEFILE_INFORMATION_EX_1_1 {{  }}")
    }
}
impl Default for SYSTEM_PAGEFILE_INFORMATION_EX_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PAGEFILE_INFORMATION_EX_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PAGEFILE_INFORMATION_EX_1 {{ union }}")
    }
}
impl Default for SYSTEM_PAGEFILE_INFORMATION_EX {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PAGEFILE_INFORMATION_EX {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PAGEFILE_INFORMATION_EX {{ Anonymous1: {:?} }}",
            self.Anonymous1
        )
    }
}
#[repr(C)]
pub struct SYSTEM_SECUREBOOT_INFORMATION {
    pub SecureBootEnabled: BOOLEAN,
    pub SecureBootCapable: BOOLEAN,
}
impl Default for SYSTEM_SECUREBOOT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SECUREBOOT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SECUREBOOT_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct PROCESS_DISK_COUNTERS {
    pub BytesRead: u64,
    pub BytesWritten: u64,
    pub ReadOperationCount: u64,
    pub WriteOperationCount: u64,
    pub FlushOperationCount: u64,
}
impl Default for PROCESS_DISK_COUNTERS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_DISK_COUNTERS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PROCESS_DISK_COUNTERS {{  }}")
    }
}
#[repr(C)]
pub struct ENERGY_STATE_DURATION {
    pub Value: UnionField<u64>,
    pub Anonymous1: UnionField<ENERGY_STATE_DURATION_1>,
    pub union_field: u64,
}
#[repr(C)]
pub struct ENERGY_STATE_DURATION_1 {
    pub LastChangeTime: u32,
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for ENERGY_STATE_DURATION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ENERGY_STATE_DURATION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ENERGY_STATE_DURATION_1 {{ Duration : {:?}, IsInState : {:?} }}",
            self.Duration(),
            self.IsInState()
        )
    }
}
impl ENERGY_STATE_DURATION_1 {
    #[inline]
    pub fn Duration(&self) -> u32 {
        self._bitfield_1.get(0usize, 31u8) as u32
    }
    #[inline]
    pub fn set_Duration(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 31u8, val as u64)
    }
    #[inline]
    pub fn IsInState(&self) -> u32 {
        self._bitfield_1.get(31usize, 1u8) as u32
    }
    #[inline]
    pub fn set_IsInState(&mut self, val: u32) {
        self._bitfield_1.set(31usize, 1u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Duration: u32, IsInState: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 31u8, Duration as u64);
        bitfield_unit.set(31usize, 1u8, IsInState as u64);
        bitfield_unit
    }
}
impl Default for ENERGY_STATE_DURATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ENERGY_STATE_DURATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ENERGY_STATE_DURATION {{ union }}")
    }
}
#[repr(C)]
pub struct PROCESS_ENERGY_VALUES {
    pub Cycles: [[u64; 2usize]; 4usize],
    pub DiskEnergy: u64,
    pub NetworkTailEnergy: u64,
    pub MBBTailEnergy: u64,
    pub NetworkTxRxBytes: u64,
    pub MBBTxRxBytes: u64,
    pub Anonymous1: PROCESS_ENERGY_VALUES_1,
    pub CompositionRendered: u32,
    pub CompositionDirtyGenerated: u32,
    pub CompositionDirtyPropagated: u32,
    pub Reserved1: u32,
    pub AttributedCycles: [[u64; 2usize]; 4usize],
    pub WorkOnBehalfCycles: [[u64; 2usize]; 4usize],
}
#[repr(C)]
pub struct PROCESS_ENERGY_VALUES_1 {
    pub Durations: UnionField<[ENERGY_STATE_DURATION; 3usize]>,
    pub Anonymous1: UnionField<PROCESS_ENERGY_VALUES_1_1>,
    pub union_field: [u64; 3usize],
}
#[repr(C)]
pub struct PROCESS_ENERGY_VALUES_1_1 {
    pub ForegroundDuration: ENERGY_STATE_DURATION,
    pub DesktopVisibleDuration: ENERGY_STATE_DURATION,
    pub PSMForegroundDuration: ENERGY_STATE_DURATION,
}
impl Default for PROCESS_ENERGY_VALUES_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_ENERGY_VALUES_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PROCESS_ENERGY_VALUES_1_1 {{ ForegroundDuration: {:?}, DesktopVisibleDuration: {:?}, PSMForegroundDuration: {:?} }}",
            self.ForegroundDuration, self.DesktopVisibleDuration, self.PSMForegroundDuration
        )
    }
}
impl Default for PROCESS_ENERGY_VALUES_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_ENERGY_VALUES_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PROCESS_ENERGY_VALUES_1 {{ union }}")
    }
}
impl Default for PROCESS_ENERGY_VALUES {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_ENERGY_VALUES {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PROCESS_ENERGY_VALUES {{ Cycles: {:?}, Anonymous1: {:?}, AttributedCycles: {:?}, WorkOnBehalfCycles: {:?} }}",
            self.Cycles, self.Anonymous1, self.AttributedCycles, self.WorkOnBehalfCycles
        )
    }
}
#[repr(C)]
pub struct TIMELINE_BITMAP {
    pub Value: UnionField<u64>,
    pub Anonymous1: UnionField<TIMELINE_BITMAP_1>,
    pub union_field: u64,
}
#[repr(C)]
pub struct TIMELINE_BITMAP_1 {
    pub EndTime: u32,
    pub Bitmap: u32,
}
impl Default for TIMELINE_BITMAP_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for TIMELINE_BITMAP_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TIMELINE_BITMAP_1 {{  }}")
    }
}
impl Default for TIMELINE_BITMAP {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for TIMELINE_BITMAP {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TIMELINE_BITMAP {{ union }}")
    }
}
#[repr(C)]
pub struct PROCESS_ENERGY_VALUES_EXTENSION {
    pub Anonymous1: PROCESS_ENERGY_VALUES_EXTENSION_1,
    pub Anonymous2: PROCESS_ENERGY_VALUES_EXTENSION_2,
    pub KeyboardInput: u32,
    pub MouseInput: u32,
}
#[repr(C)]
pub struct PROCESS_ENERGY_VALUES_EXTENSION_1 {
    pub Timelines: UnionField<[TIMELINE_BITMAP; 14usize]>,
    pub Anonymous1: UnionField<PROCESS_ENERGY_VALUES_EXTENSION_1_1>,
    pub union_field: [u64; 14usize],
}
#[repr(C)]
pub struct PROCESS_ENERGY_VALUES_EXTENSION_1_1 {
    pub CpuTimeline: TIMELINE_BITMAP,
    pub DiskTimeline: TIMELINE_BITMAP,
    pub NetworkTimeline: TIMELINE_BITMAP,
    pub MBBTimeline: TIMELINE_BITMAP,
    pub ForegroundTimeline: TIMELINE_BITMAP,
    pub DesktopVisibleTimeline: TIMELINE_BITMAP,
    pub CompositionRenderedTimeline: TIMELINE_BITMAP,
    pub CompositionDirtyGeneratedTimeline: TIMELINE_BITMAP,
    pub CompositionDirtyPropagatedTimeline: TIMELINE_BITMAP,
    pub InputTimeline: TIMELINE_BITMAP,
    pub AudioInTimeline: TIMELINE_BITMAP,
    pub AudioOutTimeline: TIMELINE_BITMAP,
    pub DisplayRequiredTimeline: TIMELINE_BITMAP,
    pub KeyboardInputTimeline: TIMELINE_BITMAP,
}
impl Default for PROCESS_ENERGY_VALUES_EXTENSION_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_ENERGY_VALUES_EXTENSION_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PROCESS_ENERGY_VALUES_EXTENSION_1_1 {{ CpuTimeline: {:?}, DiskTimeline: {:?}, NetworkTimeline: {:?}, MBBTimeline: {:?}, ForegroundTimeline: {:?}, DesktopVisibleTimeline: {:?}, CompositionRenderedTimeline: {:?}, CompositionDirtyGeneratedTimeline: {:?}, CompositionDirtyPropagatedTimeline: {:?}, InputTimeline: {:?}, AudioInTimeline: {:?}, AudioOutTimeline: {:?}, DisplayRequiredTimeline: {:?}, KeyboardInputTimeline: {:?} }}",
            self.CpuTimeline,
            self.DiskTimeline,
            self.NetworkTimeline,
            self.MBBTimeline,
            self.ForegroundTimeline,
            self.DesktopVisibleTimeline,
            self.CompositionRenderedTimeline,
            self.CompositionDirtyGeneratedTimeline,
            self.CompositionDirtyPropagatedTimeline,
            self.InputTimeline,
            self.AudioInTimeline,
            self.AudioOutTimeline,
            self.DisplayRequiredTimeline,
            self.KeyboardInputTimeline
        )
    }
}
impl Default for PROCESS_ENERGY_VALUES_EXTENSION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_ENERGY_VALUES_EXTENSION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PROCESS_ENERGY_VALUES_EXTENSION_1 {{ union }}")
    }
}
#[repr(C)]
pub struct PROCESS_ENERGY_VALUES_EXTENSION_2 {
    pub Durations: UnionField<[ENERGY_STATE_DURATION; 5usize]>,
    pub Anonymous1: UnionField<PROCESS_ENERGY_VALUES_EXTENSION_2_1>,
    pub union_field: [u64; 5usize],
}
#[repr(C)]
pub struct PROCESS_ENERGY_VALUES_EXTENSION_2_1 {
    pub InputDuration: ENERGY_STATE_DURATION,
    pub AudioInDuration: ENERGY_STATE_DURATION,
    pub AudioOutDuration: ENERGY_STATE_DURATION,
    pub DisplayRequiredDuration: ENERGY_STATE_DURATION,
    pub PSMBackgroundDuration: ENERGY_STATE_DURATION,
}
impl Default for PROCESS_ENERGY_VALUES_EXTENSION_2_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_ENERGY_VALUES_EXTENSION_2_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PROCESS_ENERGY_VALUES_EXTENSION_2_1 {{ InputDuration: {:?}, AudioInDuration: {:?}, AudioOutDuration: {:?}, DisplayRequiredDuration: {:?}, PSMBackgroundDuration: {:?} }}",
            self.InputDuration,
            self.AudioInDuration,
            self.AudioOutDuration,
            self.DisplayRequiredDuration,
            self.PSMBackgroundDuration
        )
    }
}
impl Default for PROCESS_ENERGY_VALUES_EXTENSION_2 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_ENERGY_VALUES_EXTENSION_2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PROCESS_ENERGY_VALUES_EXTENSION_2 {{ union }}")
    }
}
impl Default for PROCESS_ENERGY_VALUES_EXTENSION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_ENERGY_VALUES_EXTENSION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PROCESS_ENERGY_VALUES_EXTENSION {{ Anonymous1: {:?}, Anonymous2: {:?} }}",
            self.Anonymous1, self.Anonymous2
        )
    }
}
#[repr(C)]
pub struct PROCESS_EXTENDED_ENERGY_VALUES {
    pub Base: PROCESS_ENERGY_VALUES,
    pub Extension: PROCESS_ENERGY_VALUES_EXTENSION,
}
impl Default for PROCESS_EXTENDED_ENERGY_VALUES {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for PROCESS_EXTENDED_ENERGY_VALUES {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PROCESS_EXTENDED_ENERGY_VALUES {{ Base: {:?}, Extension: {:?} }}",
            self.Base, self.Extension
        )
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_PROCESS_CLASSIFICATION {
    SystemProcessClassificationNormal = 0,
    SystemProcessClassificationSystem = 1,
    SystemProcessClassificationSecureSystem = 2,
    SystemProcessClassificationMemCompression = 3,
    SystemProcessClassificationRegistry = 4,
    SystemProcessClassificationMaximum = 5,
}
#[repr(C)]
pub struct SYSTEM_PROCESS_INFORMATION_EXTENSION {
    pub DiskCounters: PROCESS_DISK_COUNTERS,
    pub ContextSwitches: u64,
    pub Anonymous1: SYSTEM_PROCESS_INFORMATION_EXTENSION_1,
    pub UserSidOffset: u32,
    pub PackageFullNameOffset: u32,
    pub EnergyValues: PROCESS_ENERGY_VALUES,
    pub AppIdOffset: u32,
    pub SharedCommitCharge: usize,
    pub JobObjectId: u32,
    pub SpareUlong: u32,
    pub ProcessSequenceNumber: u64,
}
#[repr(C)]
pub struct SYSTEM_PROCESS_INFORMATION_EXTENSION_1 {
    pub Flags: UnionField<u32>,
    pub Anonymous1: UnionField<SYSTEM_PROCESS_INFORMATION_EXTENSION_1_1>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_PROCESS_INFORMATION_EXTENSION_1_1 {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSTEM_PROCESS_INFORMATION_EXTENSION_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESS_INFORMATION_EXTENSION_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PROCESS_INFORMATION_EXTENSION_1_1 {{ HasStrongId : {:?}, Classification : {:?}, BackgroundActivityModerated : {:?}, Spare : {:?} }}",
            self.HasStrongId(),
            self.Classification(),
            self.BackgroundActivityModerated(),
            self.Spare()
        )
    }
}
impl SYSTEM_PROCESS_INFORMATION_EXTENSION_1_1 {
    #[inline]
    pub fn HasStrongId(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_HasStrongId(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Classification(&self) -> u32 {
        self._bitfield_1.get(1usize, 4u8) as u32
    }
    #[inline]
    pub fn set_Classification(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 4u8, val as u64)
    }
    #[inline]
    pub fn BackgroundActivityModerated(&self) -> u32 {
        self._bitfield_1.get(5usize, 1u8) as u32
    }
    #[inline]
    pub fn set_BackgroundActivityModerated(&mut self, val: u32) {
        self._bitfield_1.set(5usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Spare(&self) -> u32 {
        self._bitfield_1.get(6usize, 26u8) as u32
    }
    #[inline]
    pub fn set_Spare(&mut self, val: u32) {
        self._bitfield_1.set(6usize, 26u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        HasStrongId: u32,
        Classification: u32,
        BackgroundActivityModerated: u32,
        Spare: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, HasStrongId as u64);
        bitfield_unit.set(1usize, 4u8, Classification as u64);
        bitfield_unit.set(5usize, 1u8, BackgroundActivityModerated as u64);
        bitfield_unit.set(6usize, 26u8, Spare as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_PROCESS_INFORMATION_EXTENSION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESS_INFORMATION_EXTENSION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PROCESS_INFORMATION_EXTENSION_1 {{ union }}")
    }
}
impl Default for SYSTEM_PROCESS_INFORMATION_EXTENSION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESS_INFORMATION_EXTENSION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PROCESS_INFORMATION_EXTENSION {{ DiskCounters: {:?}, Anonymous1: {:?}, EnergyValues: {:?} }}",
            self.DiskCounters, self.Anonymous1, self.EnergyValues
        )
    }
}
#[repr(C)]
pub struct SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION {
    pub EfiLauncherEnabled: BOOLEAN,
}
impl Default for SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION {{  }}"
        )
    }
}
#[repr(C)]
pub struct SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
    pub DebuggerAllowed: BOOLEAN,
    pub DebuggerEnabled: BOOLEAN,
    pub DebuggerPresent: BOOLEAN,
}
impl Default for SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_ELAM_CERTIFICATE_INFORMATION {
    pub ElamDriverFile: HANDLE,
}
impl Default for SYSTEM_ELAM_CERTIFICATE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ELAM_CERTIFICATE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_ELAM_CERTIFICATE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {
    pub Version: u32,
    pub AbnormalResetOccurred: u32,
    pub OfflineMemoryDumpCapable: u32,
    pub ResetDataAddress: i64,
    pub ResetDataSize: u32,
}
impl Default for OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2 {{  }}")
    }
}
#[repr(C)]
pub struct OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 {
    pub Version: u32,
    pub AbnormalResetOccurred: u32,
    pub OfflineMemoryDumpCapable: u32,
}
impl Default for OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V1 {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_FEATURES_INFORMATION {
    pub ProcessorFeatureBits: u64,
    pub Reserved: [u64; 3usize],
}
impl Default for SYSTEM_PROCESSOR_FEATURES_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_FEATURES_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PROCESSOR_FEATURES_INFORMATION {{ Reserved: {:?} }}",
            self.Reserved
        )
    }
}
#[repr(C)]
pub struct SYSTEM_EDID_INFORMATION {
    pub Edid: [u8; 128usize],
}
impl Default for SYSTEM_EDID_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_EDID_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_EDID_INFORMATION {{ Edid: {:?} }}", self.Edid)
    }
}
#[repr(C)]
pub struct SYSTEM_MANUFACTURING_INFORMATION {
    pub Options: u32,
    pub ProfileName: UNICODE_STRING,
}
impl Default for SYSTEM_MANUFACTURING_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_MANUFACTURING_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_MANUFACTURING_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION {
    pub Enabled: BOOLEAN,
}
impl Default for SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct HV_DETAILS {
    pub Data: [u32; 4usize],
}
impl Default for HV_DETAILS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for HV_DETAILS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HV_DETAILS {{ Data: {:?} }}", self.Data)
    }
}
#[repr(C)]
pub struct SYSTEM_HYPERVISOR_DETAIL_INFORMATION {
    pub HvVendorAndMaxFunction: HV_DETAILS,
    pub HypervisorInterface: HV_DETAILS,
    pub HypervisorVersion: HV_DETAILS,
    pub HvFeatures: HV_DETAILS,
    pub HwFeatures: HV_DETAILS,
    pub EnlightenmentInfo: HV_DETAILS,
    pub ImplementationLimits: HV_DETAILS,
}
impl Default for SYSTEM_HYPERVISOR_DETAIL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HYPERVISOR_DETAIL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_HYPERVISOR_DETAIL_INFORMATION {{ HvVendorAndMaxFunction: {:?}, HypervisorInterface: {:?}, HypervisorVersion: {:?}, HvFeatures: {:?}, HwFeatures: {:?}, EnlightenmentInfo: {:?}, ImplementationLimits: {:?} }}",
            self.HvVendorAndMaxFunction,
            self.HypervisorInterface,
            self.HypervisorVersion,
            self.HvFeatures,
            self.HwFeatures,
            self.EnlightenmentInfo,
            self.ImplementationLimits
        )
    }
}
#[repr(C)]
pub struct SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION {
    pub Cycles: [[u64; 2usize]; 4usize],
}
impl Default for SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION {{ Cycles: {:?} }}",
            self.Cycles
        )
    }
}
#[repr(C)]
pub struct SYSTEM_TPM_INFORMATION {
    pub Flags: u32,
}
impl Default for SYSTEM_TPM_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_TPM_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_TPM_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_VSM_PROTECTION_INFORMATION {
    pub DmaProtectionsAvailable: BOOLEAN,
    pub DmaProtectionsInUse: BOOLEAN,
    pub HardwareMbecAvailable: BOOLEAN,
    pub ApicVirtualizationAvailable: BOOLEAN,
}
impl Default for SYSTEM_VSM_PROTECTION_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_VSM_PROTECTION_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_VSM_PROTECTION_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_KERNEL_DEBUGGER_FLAGS {
    pub KernelDebuggerIgnoreUmExceptions: BOOLEAN,
}
impl Default for SYSTEM_KERNEL_DEBUGGER_FLAGS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_KERNEL_DEBUGGER_FLAGS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_KERNEL_DEBUGGER_FLAGS {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_CODEINTEGRITYPOLICY_INFORMATION {
    pub Options: u32,
    pub HVCIOptions: u32,
    pub Version: u64,
    pub PolicyGuid: GUID,
}
impl Default for SYSTEM_CODEINTEGRITYPOLICY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CODEINTEGRITYPOLICY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_CODEINTEGRITYPOLICY_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_ISOLATED_USER_MODE_INFORMATION {
    _bitfield_align_1: [u8; 0],
    _bitfield_1: BitfieldUnit<[u8; 2usize]>,
    pub Spare0: [BOOLEAN; 6usize],
    pub Spare1: u64,
}
impl Default for SYSTEM_ISOLATED_USER_MODE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ISOLATED_USER_MODE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_ISOLATED_USER_MODE_INFORMATION {{ SecureKernelRunning : {:?}, HvciEnabled : {:?}, HvciStrictMode : {:?}, DebugEnabled : {:?}, FirmwarePageProtection : {:?}, EncryptionKeyAvailable : {:?}, SpareFlags : {:?}, TrustletRunning : {:?}, HvciDisableAllowed : {:?}, SpareFlags2 : {:?}, Spare0: {:?} }}",
            self.SecureKernelRunning(),
            self.HvciEnabled(),
            self.HvciStrictMode(),
            self.DebugEnabled(),
            self.FirmwarePageProtection(),
            self.EncryptionKeyAvailable(),
            self.SpareFlags(),
            self.TrustletRunning(),
            self.HvciDisableAllowed(),
            self.SpareFlags2(),
            self.Spare0
        )
    }
}
impl SYSTEM_ISOLATED_USER_MODE_INFORMATION {
    #[inline]
    pub fn SecureKernelRunning(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SecureKernelRunning(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HvciEnabled(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HvciEnabled(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HvciStrictMode(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HvciStrictMode(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DebugEnabled(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DebugEnabled(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FirmwarePageProtection(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FirmwarePageProtection(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EncryptionKeyAvailable(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EncryptionKeyAvailable(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareFlags(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SpareFlags(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TrustletRunning(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TrustletRunning(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HvciDisableAllowed(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HvciDisableAllowed(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpareFlags2(&self) -> BOOLEAN {
        unsafe { std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_SpareFlags2(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SecureKernelRunning: BOOLEAN,
        HvciEnabled: BOOLEAN,
        HvciStrictMode: BOOLEAN,
        DebugEnabled: BOOLEAN,
        FirmwarePageProtection: BOOLEAN,
        EncryptionKeyAvailable: BOOLEAN,
        SpareFlags: BOOLEAN,
        TrustletRunning: BOOLEAN,
        HvciDisableAllowed: BOOLEAN,
        SpareFlags2: BOOLEAN,
    ) -> BitfieldUnit<[u8; 2usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 2usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, {
            let SecureKernelRunning: u8 = unsafe { std::mem::transmute(SecureKernelRunning) };
            SecureKernelRunning as u64
        });
        bitfield_unit.set(1usize, 1u8, {
            let HvciEnabled: u8 = unsafe { std::mem::transmute(HvciEnabled) };
            HvciEnabled as u64
        });
        bitfield_unit.set(2usize, 1u8, {
            let HvciStrictMode: u8 = unsafe { std::mem::transmute(HvciStrictMode) };
            HvciStrictMode as u64
        });
        bitfield_unit.set(3usize, 1u8, {
            let DebugEnabled: u8 = unsafe { std::mem::transmute(DebugEnabled) };
            DebugEnabled as u64
        });
        bitfield_unit.set(4usize, 1u8, {
            let FirmwarePageProtection: u8 = unsafe { std::mem::transmute(FirmwarePageProtection) };
            FirmwarePageProtection as u64
        });
        bitfield_unit.set(5usize, 1u8, {
            let EncryptionKeyAvailable: u8 = unsafe { std::mem::transmute(EncryptionKeyAvailable) };
            EncryptionKeyAvailable as u64
        });
        bitfield_unit.set(6usize, 2u8, {
            let SpareFlags: u8 = unsafe { std::mem::transmute(SpareFlags) };
            SpareFlags as u64
        });
        bitfield_unit.set(8usize, 1u8, {
            let TrustletRunning: u8 = unsafe { std::mem::transmute(TrustletRunning) };
            TrustletRunning as u64
        });
        bitfield_unit.set(9usize, 1u8, {
            let HvciDisableAllowed: u8 = unsafe { std::mem::transmute(HvciDisableAllowed) };
            HvciDisableAllowed as u64
        });
        bitfield_unit.set(10usize, 6u8, {
            let SpareFlags2: u8 = unsafe { std::mem::transmute(SpareFlags2) };
            SpareFlags2 as u64
        });
        bitfield_unit
    }
}
#[repr(C)]
pub struct SYSTEM_SINGLE_MODULE_INFORMATION {
    pub TargetModuleAddress: *mut std::ffi::c_void,
    pub ExInfo: RTL_PROCESS_MODULE_INFORMATION_EX,
}
impl Default for SYSTEM_SINGLE_MODULE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SINGLE_MODULE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SINGLE_MODULE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_INTERRUPT_CPU_SET_INFORMATION {
    pub Gsiv: u32,
    pub Group: u16,
    pub CpuSets: u64,
}
impl Default for SYSTEM_INTERRUPT_CPU_SET_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_INTERRUPT_CPU_SET_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_INTERRUPT_CPU_SET_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
    pub PolicyInformation: SYSTEM_SECUREBOOT_POLICY_INFORMATION,
    pub PolicySize: u32,
    pub Policy: [u8; 1usize],
}
impl Default for SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {{ PolicyInformation: {:?}, Policy: {:?} }}",
            self.PolicyInformation, self.Policy
        )
    }
}
#[repr(C)]
pub struct SYSTEM_ROOT_SILO_INFORMATION {
    pub NumberOfSilos: u32,
    pub SiloIdList: [u32; 1usize],
}
impl Default for SYSTEM_ROOT_SILO_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ROOT_SILO_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_ROOT_SILO_INFORMATION {{ SiloIdList: {:?} }}",
            self.SiloIdList
        )
    }
}
#[repr(C)]
pub struct SYSTEM_CPU_SET_TAG_INFORMATION {
    pub Tag: u64,
    pub CpuSets: [u64; 1usize],
}
impl Default for SYSTEM_CPU_SET_TAG_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CPU_SET_TAG_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_CPU_SET_TAG_INFORMATION {{ CpuSets: {:?} }}",
            self.CpuSets
        )
    }
}
#[repr(C)]
pub struct SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION {
    pub ExtentCount: u32,
    pub ValidStructureSize: u32,
    pub NextExtentIndex: u32,
    pub ExtentRestart: u32,
    pub CycleCount: u32,
    pub TimeoutCount: u32,
    pub CycleTime: u64,
    pub CycleTimeMax: u64,
    pub ExtentTime: u64,
    pub ExtentTimeIndex: u32,
    pub ExtentTimeMaxIndex: u32,
    pub ExtentTimeMax: u64,
    pub HyperFlushTimeMax: u64,
    pub TranslateVaTimeMax: u64,
    pub DebugExemptionCount: u64,
    pub TbHitCount: u64,
    pub TbMissCount: u64,
    pub VinaPendingYield: u64,
    pub HashCycles: u64,
    pub HistogramOffset: u32,
    pub HistogramBuckets: u32,
    pub HistogramShift: u32,
    pub Reserved1: u32,
    pub PageNotPresentCount: u64,
}
impl Default for SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION {{  }}"
        )
    }
}
#[repr(C)]
pub struct SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION {
    pub PlatformManifestSize: u32,
    pub PlatformManifest: [u8; 1usize],
}
impl Default for SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION {{ PlatformManifest: {:?} }}",
            self.PlatformManifest
        )
    }
}
#[repr(C)]
pub struct SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT {
    pub Gsiv: u32,
    pub ControllerInterrupt: u8,
    pub EdgeInterrupt: u8,
    pub IsPrimaryInterrupt: u8,
    pub TargetAffinity: GROUP_AFFINITY,
}
impl Default for SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT {
    pub AsULONG: UnionField<u32>,
    pub Anonymous1: UnionField<SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT_1>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT_1 {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT_1 {{ Enabled : {:?}, Reserved : {:?} }}",
            self.Enabled(),
            self.Reserved()
        )
    }
}
impl SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT_1 {
    #[inline]
    pub fn Enabled(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_Enabled(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(1usize, 31u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 31u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(Enabled: u32, Reserved: u32) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, Enabled as u64);
        bitfield_unit.set(1usize, 31u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT {{ union }}"
        )
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    _bitfield_align_1: [u16; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION {
    #[inline]
    pub fn Machine(&self) -> u32 {
        self._bitfield_1.get(0usize, 16u8) as u32
    }
    #[inline]
    pub fn set_Machine(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 16u8, val as u64)
    }
    #[inline]
    pub fn KernelMode(&self) -> u32 {
        self._bitfield_1.get(16usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KernelMode(&mut self, val: u32) {
        self._bitfield_1.set(16usize, 1u8, val as u64)
    }
    #[inline]
    pub fn UserMode(&self) -> u32 {
        self._bitfield_1.get(17usize, 1u8) as u32
    }
    #[inline]
    pub fn set_UserMode(&mut self, val: u32) {
        self._bitfield_1.set(17usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Native(&self) -> u32 {
        self._bitfield_1.get(18usize, 1u8) as u32
    }
    #[inline]
    pub fn set_Native(&mut self, val: u32) {
        self._bitfield_1.set(18usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Process(&self) -> u32 {
        self._bitfield_1.get(19usize, 1u8) as u32
    }
    #[inline]
    pub fn set_Process(&mut self, val: u32) {
        self._bitfield_1.set(19usize, 1u8, val as u64)
    }
    #[inline]
    pub fn WoW64Container(&self) -> u32 {
        self._bitfield_1.get(20usize, 1u8) as u32
    }
    #[inline]
    pub fn set_WoW64Container(&mut self, val: u32) {
        self._bitfield_1.set(20usize, 1u8, val as u64)
    }
    #[inline]
    pub fn ReservedZero0(&self) -> u32 {
        self._bitfield_1.get(21usize, 11u8) as u32
    }
    #[inline]
    pub fn set_ReservedZero0(&mut self, val: u32) {
        self._bitfield_1.set(21usize, 11u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        Machine: u32,
        KernelMode: u32,
        UserMode: u32,
        Native: u32,
        Process: u32,
        WoW64Container: u32,
        ReservedZero0: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 16u8, Machine as u64);
        bitfield_unit.set(16usize, 1u8, KernelMode as u64);
        bitfield_unit.set(17usize, 1u8, UserMode as u64);
        bitfield_unit.set(18usize, 1u8, Native as u64);
        bitfield_unit.set(19usize, 1u8, Process as u64);
        bitfield_unit.set(20usize, 1u8, WoW64Container as u64);
        bitfield_unit.set(21usize, 11u8, ReservedZero0 as u64);
        bitfield_unit
    }
}
#[repr(C)]
pub struct SYSTEM_MEMORY_USAGE_INFORMATION {
    pub TotalPhysicalBytes: u64,
    pub AvailableBytes: u64,
    pub ResidentAvailableBytes: i64,
    pub CommittedBytes: u64,
    pub SharedCommittedBytes: u64,
    pub CommitLimitBytes: u64,
    pub PeakCommitmentBytes: u64,
}
impl Default for SYSTEM_MEMORY_USAGE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_MEMORY_USAGE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_MEMORY_USAGE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION {
    pub ImageFile: HANDLE,
    pub Type: u32,
}
impl Default for SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_PHYSICAL_MEMORY_INFORMATION {
    pub TotalPhysicalBytes: u64,
    pub LowestPhysicalAddress: u64,
    pub HighestPhysicalAddress: u64,
}
impl Default for SYSTEM_PHYSICAL_MEMORY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_PHYSICAL_MEMORY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_PHYSICAL_MEMORY_INFORMATION {{  }}")
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_ACTIVITY_MODERATION_STATE {
    SystemActivityModerationStateSystemManaged = 0,
    SystemActivityModerationStateUserManagedAllowThrottling = 1,
    SystemActivityModerationStateUserManagedDisableThrottling = 2,
    MaxSystemActivityModerationState = 3,
}
#[repr(C)]
pub struct SYSTEM_ACTIVITY_MODERATION_EXE_STATE {
    pub ExePathNt: UNICODE_STRING,
    pub ModerationState: SYSTEM_ACTIVITY_MODERATION_STATE,
}
impl Default for SYSTEM_ACTIVITY_MODERATION_EXE_STATE {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ACTIVITY_MODERATION_EXE_STATE {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_ACTIVITY_MODERATION_EXE_STATE {{ ModerationState: {:?} }}",
            self.ModerationState
        )
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_ACTIVITY_MODERATION_APP_TYPE {
    SystemActivityModerationAppTypeClassic = 0,
    SystemActivityModerationAppTypePackaged = 1,
    MaxSystemActivityModerationAppType = 2,
}
#[repr(C)]
pub struct SYSTEM_ACTIVITY_MODERATION_INFO {
    pub Identifier: UNICODE_STRING,
    pub ModerationState: SYSTEM_ACTIVITY_MODERATION_STATE,
    pub AppType: SYSTEM_ACTIVITY_MODERATION_APP_TYPE,
}
impl Default for SYSTEM_ACTIVITY_MODERATION_INFO {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ACTIVITY_MODERATION_INFO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_ACTIVITY_MODERATION_INFO {{ ModerationState: {:?}, AppType: {:?} }}",
            self.ModerationState, self.AppType
        )
    }
}
#[repr(C)]
pub struct SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS {
    pub UserKeyHandle: HANDLE,
}
impl Default for SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION {
    pub Anonymous1: SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1,
    pub UnlockId: [u8; 32usize],
}
#[repr(C)]
pub struct SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1 {
    pub Flags: UnionField<u32>,
    pub Anonymous1: UnionField<SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1_1>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1_1 {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1_1 {{ Locked : {:?}, UnlockApplied : {:?}, UnlockIdValid : {:?}, Reserved : {:?} }}",
            self.Locked(),
            self.UnlockApplied(),
            self.UnlockIdValid(),
            self.Reserved()
        )
    }
}
impl SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1_1 {
    #[inline]
    pub fn Locked(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_Locked(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn UnlockApplied(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_UnlockApplied(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn UnlockIdValid(&self) -> u32 {
        self._bitfield_1.get(2usize, 1u8) as u32
    }
    #[inline]
    pub fn set_UnlockIdValid(&mut self, val: u32) {
        self._bitfield_1.set(2usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(3usize, 29u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(3usize, 29u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        Locked: u32,
        UnlockApplied: u32,
        UnlockIdValid: u32,
        Reserved: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, Locked as u64);
        bitfield_unit.set(1usize, 1u8, UnlockApplied as u64);
        bitfield_unit.set(2usize, 1u8, UnlockIdValid as u64);
        bitfield_unit.set(3usize, 29u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION_1 {{ union }}")
    }
}
impl Default for SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION {{ Anonymous1: {:?}, UnlockId: {:?} }}",
            self.Anonymous1, self.UnlockId
        )
    }
}
#[repr(C)]
pub struct SYSTEM_FLUSH_INFORMATION {
    pub SupportedFlushMethods: u32,
    pub ProcessorCacheFlushSize: u32,
    pub SystemFlushCapabilities: u64,
    pub Reserved: [u64; 2usize],
}
impl Default for SYSTEM_FLUSH_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_FLUSH_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_FLUSH_INFORMATION {{ Reserved: {:?} }}",
            self.Reserved
        )
    }
}
#[repr(C)]
pub struct SYSTEM_WRITE_CONSTRAINT_INFORMATION {
    pub WriteConstraintPolicy: u32,
    pub Reserved: u32,
}
impl Default for SYSTEM_WRITE_CONSTRAINT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_WRITE_CONSTRAINT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_WRITE_CONSTRAINT_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
    pub Anonymous1: SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1,
}
#[repr(C)]
pub struct SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1 {
    pub KvaShadowFlags: UnionField<u32>,
    pub Anonymous1: UnionField<SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1_1>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1_1 {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1_1 {{ KvaShadowEnabled : {:?}, KvaShadowUserGlobal : {:?}, KvaShadowPcid : {:?}, KvaShadowInvpcid : {:?}, KvaShadowRequired : {:?}, KvaShadowRequiredAvailable : {:?}, InvalidPteBit : {:?}, L1DataCacheFlushSupported : {:?}, L1TerminalFaultMitigationPresent : {:?}, Reserved : {:?} }}",
            self.KvaShadowEnabled(),
            self.KvaShadowUserGlobal(),
            self.KvaShadowPcid(),
            self.KvaShadowInvpcid(),
            self.KvaShadowRequired(),
            self.KvaShadowRequiredAvailable(),
            self.InvalidPteBit(),
            self.L1DataCacheFlushSupported(),
            self.L1TerminalFaultMitigationPresent(),
            self.Reserved()
        )
    }
}
impl SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1_1 {
    #[inline]
    pub fn KvaShadowEnabled(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KvaShadowEnabled(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn KvaShadowUserGlobal(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KvaShadowUserGlobal(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn KvaShadowPcid(&self) -> u32 {
        self._bitfield_1.get(2usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KvaShadowPcid(&mut self, val: u32) {
        self._bitfield_1.set(2usize, 1u8, val as u64)
    }
    #[inline]
    pub fn KvaShadowInvpcid(&self) -> u32 {
        self._bitfield_1.get(3usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KvaShadowInvpcid(&mut self, val: u32) {
        self._bitfield_1.set(3usize, 1u8, val as u64)
    }
    #[inline]
    pub fn KvaShadowRequired(&self) -> u32 {
        self._bitfield_1.get(4usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KvaShadowRequired(&mut self, val: u32) {
        self._bitfield_1.set(4usize, 1u8, val as u64)
    }
    #[inline]
    pub fn KvaShadowRequiredAvailable(&self) -> u32 {
        self._bitfield_1.get(5usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KvaShadowRequiredAvailable(&mut self, val: u32) {
        self._bitfield_1.set(5usize, 1u8, val as u64)
    }
    #[inline]
    pub fn InvalidPteBit(&self) -> u32 {
        self._bitfield_1.get(6usize, 6u8) as u32
    }
    #[inline]
    pub fn set_InvalidPteBit(&mut self, val: u32) {
        self._bitfield_1.set(6usize, 6u8, val as u64)
    }
    #[inline]
    pub fn L1DataCacheFlushSupported(&self) -> u32 {
        self._bitfield_1.get(12usize, 1u8) as u32
    }
    #[inline]
    pub fn set_L1DataCacheFlushSupported(&mut self, val: u32) {
        self._bitfield_1.set(12usize, 1u8, val as u64)
    }
    #[inline]
    pub fn L1TerminalFaultMitigationPresent(&self) -> u32 {
        self._bitfield_1.get(13usize, 1u8) as u32
    }
    #[inline]
    pub fn set_L1TerminalFaultMitigationPresent(&mut self, val: u32) {
        self._bitfield_1.set(13usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(14usize, 18u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(14usize, 18u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        KvaShadowEnabled: u32,
        KvaShadowUserGlobal: u32,
        KvaShadowPcid: u32,
        KvaShadowInvpcid: u32,
        KvaShadowRequired: u32,
        KvaShadowRequiredAvailable: u32,
        InvalidPteBit: u32,
        L1DataCacheFlushSupported: u32,
        L1TerminalFaultMitigationPresent: u32,
        Reserved: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, KvaShadowEnabled as u64);
        bitfield_unit.set(1usize, 1u8, KvaShadowUserGlobal as u64);
        bitfield_unit.set(2usize, 1u8, KvaShadowPcid as u64);
        bitfield_unit.set(3usize, 1u8, KvaShadowInvpcid as u64);
        bitfield_unit.set(4usize, 1u8, KvaShadowRequired as u64);
        bitfield_unit.set(5usize, 1u8, KvaShadowRequiredAvailable as u64);
        bitfield_unit.set(6usize, 6u8, InvalidPteBit as u64);
        bitfield_unit.set(12usize, 1u8, L1DataCacheFlushSupported as u64);
        bitfield_unit.set(13usize, 1u8, L1TerminalFaultMitigationPresent as u64);
        bitfield_unit.set(14usize, 18u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_KERNEL_VA_SHADOW_INFORMATION_1 {{ union }}")
    }
}
impl Default for SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_KERNEL_VA_SHADOW_INFORMATION {{ Anonymous1: {:?} }}",
            self.Anonymous1
        )
    }
}
#[repr(C)]
pub struct SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION {
    pub FileHandle: HANDLE,
    pub ImageSize: u32,
    pub Image: *mut std::ffi::c_void,
}
impl Default for SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION {
    pub HypervisorSharedUserVa: *mut std::ffi::c_void,
}
impl Default for SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_FIRMWARE_PARTITION_INFORMATION {
    pub FirmwarePartition: UNICODE_STRING,
}
impl Default for SYSTEM_FIRMWARE_PARTITION_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_FIRMWARE_PARTITION_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_FIRMWARE_PARTITION_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_SPECULATION_CONTROL_INFORMATION {
    pub SpeculationControlFlags: SYSTEM_SPECULATION_CONTROL_INFORMATION_1,
    pub SpeculationControlFlags2: SYSTEM_SPECULATION_CONTROL_INFORMATION_2,
}
#[repr(C)]
pub struct SYSTEM_SPECULATION_CONTROL_INFORMATION_1 {
    pub Flags: UnionField<u32>,
    pub Anonymous1: UnionField<SYSTEM_SPECULATION_CONTROL_INFORMATION_1_1>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_SPECULATION_CONTROL_INFORMATION_1_1 {
    _bitfield_align_1: [u8; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSTEM_SPECULATION_CONTROL_INFORMATION_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SPECULATION_CONTROL_INFORMATION_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SPECULATION_CONTROL_INFORMATION_1_1 {{ BpbEnabled : {:?}, BpbDisabledSystemPolicy : {:?}, BpbDisabledNoHardwareSupport : {:?}, SpecCtrlEnumerated : {:?}, SpecCmdEnumerated : {:?}, IbrsPresent : {:?}, StibpPresent : {:?}, SmepPresent : {:?}, SpeculativeStoreBypassDisableAvailable : {:?}, SpeculativeStoreBypassDisableSupported : {:?}, SpeculativeStoreBypassDisabledSystemWide : {:?}, SpeculativeStoreBypassDisabledKernel : {:?}, SpeculativeStoreBypassDisableRequired : {:?}, BpbDisabledKernelToUser : {:?}, SpecCtrlRetpolineEnabled : {:?}, SpecCtrlImportOptimizationEnabled : {:?}, EnhancedIbrs : {:?}, HvL1tfStatusAvailable : {:?}, HvL1tfProcessorNotAffected : {:?}, HvL1tfMigitationEnabled : {:?}, HvL1tfMigitationNotEnabled_Hardware : {:?}, HvL1tfMigitationNotEnabled_LoadOption : {:?}, HvL1tfMigitationNotEnabled_CoreScheduler : {:?}, EnhancedIbrsReported : {:?}, MdsHardwareProtected : {:?}, MbClearEnabled : {:?}, MbClearReported : {:?}, ReservedTaa : {:?}, Reserved : {:?} }}",
            self.BpbEnabled(),
            self.BpbDisabledSystemPolicy(),
            self.BpbDisabledNoHardwareSupport(),
            self.SpecCtrlEnumerated(),
            self.SpecCmdEnumerated(),
            self.IbrsPresent(),
            self.StibpPresent(),
            self.SmepPresent(),
            self.SpeculativeStoreBypassDisableAvailable(),
            self.SpeculativeStoreBypassDisableSupported(),
            self.SpeculativeStoreBypassDisabledSystemWide(),
            self.SpeculativeStoreBypassDisabledKernel(),
            self.SpeculativeStoreBypassDisableRequired(),
            self.BpbDisabledKernelToUser(),
            self.SpecCtrlRetpolineEnabled(),
            self.SpecCtrlImportOptimizationEnabled(),
            self.EnhancedIbrs(),
            self.HvL1tfStatusAvailable(),
            self.HvL1tfProcessorNotAffected(),
            self.HvL1tfMigitationEnabled(),
            self.HvL1tfMigitationNotEnabled_Hardware(),
            self.HvL1tfMigitationNotEnabled_LoadOption(),
            self.HvL1tfMigitationNotEnabled_CoreScheduler(),
            self.EnhancedIbrsReported(),
            self.MdsHardwareProtected(),
            self.MbClearEnabled(),
            self.MbClearReported(),
            self.ReservedTaa(),
            self.Reserved()
        )
    }
}
impl SYSTEM_SPECULATION_CONTROL_INFORMATION_1_1 {
    #[inline]
    pub fn BpbEnabled(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_BpbEnabled(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn BpbDisabledSystemPolicy(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_BpbDisabledSystemPolicy(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn BpbDisabledNoHardwareSupport(&self) -> u32 {
        self._bitfield_1.get(2usize, 1u8) as u32
    }
    #[inline]
    pub fn set_BpbDisabledNoHardwareSupport(&mut self, val: u32) {
        self._bitfield_1.set(2usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SpecCtrlEnumerated(&self) -> u32 {
        self._bitfield_1.get(3usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SpecCtrlEnumerated(&mut self, val: u32) {
        self._bitfield_1.set(3usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SpecCmdEnumerated(&self) -> u32 {
        self._bitfield_1.get(4usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SpecCmdEnumerated(&mut self, val: u32) {
        self._bitfield_1.set(4usize, 1u8, val as u64)
    }
    #[inline]
    pub fn IbrsPresent(&self) -> u32 {
        self._bitfield_1.get(5usize, 1u8) as u32
    }
    #[inline]
    pub fn set_IbrsPresent(&mut self, val: u32) {
        self._bitfield_1.set(5usize, 1u8, val as u64)
    }
    #[inline]
    pub fn StibpPresent(&self) -> u32 {
        self._bitfield_1.get(6usize, 1u8) as u32
    }
    #[inline]
    pub fn set_StibpPresent(&mut self, val: u32) {
        self._bitfield_1.set(6usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SmepPresent(&self) -> u32 {
        self._bitfield_1.get(7usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SmepPresent(&mut self, val: u32) {
        self._bitfield_1.set(7usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SpeculativeStoreBypassDisableAvailable(&self) -> u32 {
        self._bitfield_1.get(8usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SpeculativeStoreBypassDisableAvailable(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SpeculativeStoreBypassDisableSupported(&self) -> u32 {
        self._bitfield_1.get(9usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SpeculativeStoreBypassDisableSupported(&mut self, val: u32) {
        self._bitfield_1.set(9usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SpeculativeStoreBypassDisabledSystemWide(&self) -> u32 {
        self._bitfield_1.get(10usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SpeculativeStoreBypassDisabledSystemWide(&mut self, val: u32) {
        self._bitfield_1.set(10usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SpeculativeStoreBypassDisabledKernel(&self) -> u32 {
        self._bitfield_1.get(11usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SpeculativeStoreBypassDisabledKernel(&mut self, val: u32) {
        self._bitfield_1.set(11usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SpeculativeStoreBypassDisableRequired(&self) -> u32 {
        self._bitfield_1.get(12usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SpeculativeStoreBypassDisableRequired(&mut self, val: u32) {
        self._bitfield_1.set(12usize, 1u8, val as u64)
    }
    #[inline]
    pub fn BpbDisabledKernelToUser(&self) -> u32 {
        self._bitfield_1.get(13usize, 1u8) as u32
    }
    #[inline]
    pub fn set_BpbDisabledKernelToUser(&mut self, val: u32) {
        self._bitfield_1.set(13usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SpecCtrlRetpolineEnabled(&self) -> u32 {
        self._bitfield_1.get(14usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SpecCtrlRetpolineEnabled(&mut self, val: u32) {
        self._bitfield_1.set(14usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SpecCtrlImportOptimizationEnabled(&self) -> u32 {
        self._bitfield_1.get(15usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SpecCtrlImportOptimizationEnabled(&mut self, val: u32) {
        self._bitfield_1.set(15usize, 1u8, val as u64)
    }
    #[inline]
    pub fn EnhancedIbrs(&self) -> u32 {
        self._bitfield_1.get(16usize, 1u8) as u32
    }
    #[inline]
    pub fn set_EnhancedIbrs(&mut self, val: u32) {
        self._bitfield_1.set(16usize, 1u8, val as u64)
    }
    #[inline]
    pub fn HvL1tfStatusAvailable(&self) -> u32 {
        self._bitfield_1.get(17usize, 1u8) as u32
    }
    #[inline]
    pub fn set_HvL1tfStatusAvailable(&mut self, val: u32) {
        self._bitfield_1.set(17usize, 1u8, val as u64)
    }
    #[inline]
    pub fn HvL1tfProcessorNotAffected(&self) -> u32 {
        self._bitfield_1.get(18usize, 1u8) as u32
    }
    #[inline]
    pub fn set_HvL1tfProcessorNotAffected(&mut self, val: u32) {
        self._bitfield_1.set(18usize, 1u8, val as u64)
    }
    #[inline]
    pub fn HvL1tfMigitationEnabled(&self) -> u32 {
        self._bitfield_1.get(19usize, 1u8) as u32
    }
    #[inline]
    pub fn set_HvL1tfMigitationEnabled(&mut self, val: u32) {
        self._bitfield_1.set(19usize, 1u8, val as u64)
    }
    #[inline]
    pub fn HvL1tfMigitationNotEnabled_Hardware(&self) -> u32 {
        self._bitfield_1.get(20usize, 1u8) as u32
    }
    #[inline]
    pub fn set_HvL1tfMigitationNotEnabled_Hardware(&mut self, val: u32) {
        self._bitfield_1.set(20usize, 1u8, val as u64)
    }
    #[inline]
    pub fn HvL1tfMigitationNotEnabled_LoadOption(&self) -> u32 {
        self._bitfield_1.get(21usize, 1u8) as u32
    }
    #[inline]
    pub fn set_HvL1tfMigitationNotEnabled_LoadOption(&mut self, val: u32) {
        self._bitfield_1.set(21usize, 1u8, val as u64)
    }
    #[inline]
    pub fn HvL1tfMigitationNotEnabled_CoreScheduler(&self) -> u32 {
        self._bitfield_1.get(22usize, 1u8) as u32
    }
    #[inline]
    pub fn set_HvL1tfMigitationNotEnabled_CoreScheduler(&mut self, val: u32) {
        self._bitfield_1.set(22usize, 1u8, val as u64)
    }
    #[inline]
    pub fn EnhancedIbrsReported(&self) -> u32 {
        self._bitfield_1.get(23usize, 1u8) as u32
    }
    #[inline]
    pub fn set_EnhancedIbrsReported(&mut self, val: u32) {
        self._bitfield_1.set(23usize, 1u8, val as u64)
    }
    #[inline]
    pub fn MdsHardwareProtected(&self) -> u32 {
        self._bitfield_1.get(24usize, 1u8) as u32
    }
    #[inline]
    pub fn set_MdsHardwareProtected(&mut self, val: u32) {
        self._bitfield_1.set(24usize, 1u8, val as u64)
    }
    #[inline]
    pub fn MbClearEnabled(&self) -> u32 {
        self._bitfield_1.get(25usize, 1u8) as u32
    }
    #[inline]
    pub fn set_MbClearEnabled(&mut self, val: u32) {
        self._bitfield_1.set(25usize, 1u8, val as u64)
    }
    #[inline]
    pub fn MbClearReported(&self) -> u32 {
        self._bitfield_1.get(26usize, 1u8) as u32
    }
    #[inline]
    pub fn set_MbClearReported(&mut self, val: u32) {
        self._bitfield_1.set(26usize, 1u8, val as u64)
    }
    #[inline]
    pub fn ReservedTaa(&self) -> u32 {
        self._bitfield_1.get(27usize, 4u8) as u32
    }
    #[inline]
    pub fn set_ReservedTaa(&mut self, val: u32) {
        self._bitfield_1.set(27usize, 4u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(31usize, 1u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(31usize, 1u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        BpbEnabled: u32,
        BpbDisabledSystemPolicy: u32,
        BpbDisabledNoHardwareSupport: u32,
        SpecCtrlEnumerated: u32,
        SpecCmdEnumerated: u32,
        IbrsPresent: u32,
        StibpPresent: u32,
        SmepPresent: u32,
        SpeculativeStoreBypassDisableAvailable: u32,
        SpeculativeStoreBypassDisableSupported: u32,
        SpeculativeStoreBypassDisabledSystemWide: u32,
        SpeculativeStoreBypassDisabledKernel: u32,
        SpeculativeStoreBypassDisableRequired: u32,
        BpbDisabledKernelToUser: u32,
        SpecCtrlRetpolineEnabled: u32,
        SpecCtrlImportOptimizationEnabled: u32,
        EnhancedIbrs: u32,
        HvL1tfStatusAvailable: u32,
        HvL1tfProcessorNotAffected: u32,
        HvL1tfMigitationEnabled: u32,
        HvL1tfMigitationNotEnabled_Hardware: u32,
        HvL1tfMigitationNotEnabled_LoadOption: u32,
        HvL1tfMigitationNotEnabled_CoreScheduler: u32,
        EnhancedIbrsReported: u32,
        MdsHardwareProtected: u32,
        MbClearEnabled: u32,
        MbClearReported: u32,
        ReservedTaa: u32,
        Reserved: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, BpbEnabled as u64);
        bitfield_unit.set(1usize, 1u8, BpbDisabledSystemPolicy as u64);
        bitfield_unit.set(2usize, 1u8, BpbDisabledNoHardwareSupport as u64);
        bitfield_unit.set(3usize, 1u8, SpecCtrlEnumerated as u64);
        bitfield_unit.set(4usize, 1u8, SpecCmdEnumerated as u64);
        bitfield_unit.set(5usize, 1u8, IbrsPresent as u64);
        bitfield_unit.set(6usize, 1u8, StibpPresent as u64);
        bitfield_unit.set(7usize, 1u8, SmepPresent as u64);
        bitfield_unit.set(8usize, 1u8, SpeculativeStoreBypassDisableAvailable as u64);
        bitfield_unit.set(9usize, 1u8, SpeculativeStoreBypassDisableSupported as u64);
        bitfield_unit.set(
            10usize,
            1u8,
            SpeculativeStoreBypassDisabledSystemWide as u64,
        );
        bitfield_unit.set(11usize, 1u8, SpeculativeStoreBypassDisabledKernel as u64);
        bitfield_unit.set(12usize, 1u8, SpeculativeStoreBypassDisableRequired as u64);
        bitfield_unit.set(13usize, 1u8, BpbDisabledKernelToUser as u64);
        bitfield_unit.set(14usize, 1u8, SpecCtrlRetpolineEnabled as u64);
        bitfield_unit.set(15usize, 1u8, SpecCtrlImportOptimizationEnabled as u64);
        bitfield_unit.set(16usize, 1u8, EnhancedIbrs as u64);
        bitfield_unit.set(17usize, 1u8, HvL1tfStatusAvailable as u64);
        bitfield_unit.set(18usize, 1u8, HvL1tfProcessorNotAffected as u64);
        bitfield_unit.set(19usize, 1u8, HvL1tfMigitationEnabled as u64);
        bitfield_unit.set(20usize, 1u8, HvL1tfMigitationNotEnabled_Hardware as u64);
        bitfield_unit.set(21usize, 1u8, HvL1tfMigitationNotEnabled_LoadOption as u64);
        bitfield_unit.set(
            22usize,
            1u8,
            HvL1tfMigitationNotEnabled_CoreScheduler as u64,
        );
        bitfield_unit.set(23usize, 1u8, EnhancedIbrsReported as u64);
        bitfield_unit.set(24usize, 1u8, MdsHardwareProtected as u64);
        bitfield_unit.set(25usize, 1u8, MbClearEnabled as u64);
        bitfield_unit.set(26usize, 1u8, MbClearReported as u64);
        bitfield_unit.set(27usize, 4u8, ReservedTaa as u64);
        bitfield_unit.set(31usize, 1u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_SPECULATION_CONTROL_INFORMATION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SPECULATION_CONTROL_INFORMATION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SPECULATION_CONTROL_INFORMATION_1 {{ union }}")
    }
}
#[repr(C)]
pub struct SYSTEM_SPECULATION_CONTROL_INFORMATION_2 {
    pub Flags: UnionField<u32>,
    pub Anonymous1: UnionField<SYSTEM_SPECULATION_CONTROL_INFORMATION_2_1>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_SPECULATION_CONTROL_INFORMATION_2_1 {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSTEM_SPECULATION_CONTROL_INFORMATION_2_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SPECULATION_CONTROL_INFORMATION_2_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SPECULATION_CONTROL_INFORMATION_2_1 {{ Reserved1 : {:?}, BhbEnabled : {:?}, BhbDisabledSystemPolicy : {:?}, BhbDisabledNoHardwareSupport : {:?}, Reserved2 : {:?}, RdclHardwareProtectedReported : {:?}, RdclHardwareProtected : {:?}, Reserved : {:?} }}",
            self.Reserved1(),
            self.BhbEnabled(),
            self.BhbDisabledSystemPolicy(),
            self.BhbDisabledNoHardwareSupport(),
            self.Reserved2(),
            self.RdclHardwareProtectedReported(),
            self.RdclHardwareProtected(),
            self.Reserved()
        )
    }
}
impl SYSTEM_SPECULATION_CONTROL_INFORMATION_2_1 {
    #[inline]
    pub fn Reserved1(&self) -> u32 {
        self._bitfield_1.get(0usize, 5u8) as u32
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 5u8, val as u64)
    }
    #[inline]
    pub fn BhbEnabled(&self) -> u32 {
        self._bitfield_1.get(5usize, 1u8) as u32
    }
    #[inline]
    pub fn set_BhbEnabled(&mut self, val: u32) {
        self._bitfield_1.set(5usize, 1u8, val as u64)
    }
    #[inline]
    pub fn BhbDisabledSystemPolicy(&self) -> u32 {
        self._bitfield_1.get(6usize, 1u8) as u32
    }
    #[inline]
    pub fn set_BhbDisabledSystemPolicy(&mut self, val: u32) {
        self._bitfield_1.set(6usize, 1u8, val as u64)
    }
    #[inline]
    pub fn BhbDisabledNoHardwareSupport(&self) -> u32 {
        self._bitfield_1.get(7usize, 1u8) as u32
    }
    #[inline]
    pub fn set_BhbDisabledNoHardwareSupport(&mut self, val: u32) {
        self._bitfield_1.set(7usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Reserved2(&self) -> u32 {
        self._bitfield_1.get(8usize, 3u8) as u32
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 3u8, val as u64)
    }
    #[inline]
    pub fn RdclHardwareProtectedReported(&self) -> u32 {
        self._bitfield_1.get(11usize, 1u8) as u32
    }
    #[inline]
    pub fn set_RdclHardwareProtectedReported(&mut self, val: u32) {
        self._bitfield_1.set(11usize, 1u8, val as u64)
    }
    #[inline]
    pub fn RdclHardwareProtected(&self) -> u32 {
        self._bitfield_1.get(12usize, 1u8) as u32
    }
    #[inline]
    pub fn set_RdclHardwareProtected(&mut self, val: u32) {
        self._bitfield_1.set(12usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(13usize, 19u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(13usize, 19u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: u32,
        BhbEnabled: u32,
        BhbDisabledSystemPolicy: u32,
        BhbDisabledNoHardwareSupport: u32,
        Reserved2: u32,
        RdclHardwareProtectedReported: u32,
        RdclHardwareProtected: u32,
        Reserved: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 5u8, Reserved1 as u64);
        bitfield_unit.set(5usize, 1u8, BhbEnabled as u64);
        bitfield_unit.set(6usize, 1u8, BhbDisabledSystemPolicy as u64);
        bitfield_unit.set(7usize, 1u8, BhbDisabledNoHardwareSupport as u64);
        bitfield_unit.set(8usize, 3u8, Reserved2 as u64);
        bitfield_unit.set(11usize, 1u8, RdclHardwareProtectedReported as u64);
        bitfield_unit.set(12usize, 1u8, RdclHardwareProtected as u64);
        bitfield_unit.set(13usize, 19u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_SPECULATION_CONTROL_INFORMATION_2 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SPECULATION_CONTROL_INFORMATION_2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SPECULATION_CONTROL_INFORMATION_2 {{ union }}")
    }
}
impl Default for SYSTEM_SPECULATION_CONTROL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SPECULATION_CONTROL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SPECULATION_CONTROL_INFORMATION {{ SpeculationControlFlags: {:?}, SpeculationControlFlags2: {:?} }}",
            self.SpeculationControlFlags, self.SpeculationControlFlags2
        )
    }
}
#[repr(C)]
pub struct SYSTEM_DMA_GUARD_POLICY_INFORMATION {
    pub DmaGuardPolicyEnabled: BOOLEAN,
}
impl Default for SYSTEM_DMA_GUARD_POLICY_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_DMA_GUARD_POLICY_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_DMA_GUARD_POLICY_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION {
    pub EnclaveLaunchSigner: [u8; 32usize],
}
impl Default for SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION {{ EnclaveLaunchSigner: {:?} }}",
            self.EnclaveLaunchSigner
        )
    }
}
#[repr(C)]
pub struct SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION {
    pub WorkloadClass: u64,
    pub CpuSets: [u64; 1usize],
}
impl Default for SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION {{ CpuSets: {:?} }}",
            self.CpuSets
        )
    }
}
#[repr(C)]
pub struct SYSTEM_SECURITY_MODEL_INFORMATION {
    pub Anonymous1: SYSTEM_SECURITY_MODEL_INFORMATION_1,
}
#[repr(C)]
pub struct SYSTEM_SECURITY_MODEL_INFORMATION_1 {
    pub SecurityModelFlags: UnionField<u32>,
    pub Anonymous1: UnionField<SYSTEM_SECURITY_MODEL_INFORMATION_1_1>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_SECURITY_MODEL_INFORMATION_1_1 {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSTEM_SECURITY_MODEL_INFORMATION_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SECURITY_MODEL_INFORMATION_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SECURITY_MODEL_INFORMATION_1_1 {{ SModeAdminlessEnabled : {:?}, AllowDeviceOwnerProtectionDowngrade : {:?}, Reserved : {:?} }}",
            self.SModeAdminlessEnabled(),
            self.AllowDeviceOwnerProtectionDowngrade(),
            self.Reserved()
        )
    }
}
impl SYSTEM_SECURITY_MODEL_INFORMATION_1_1 {
    #[inline]
    pub fn SModeAdminlessEnabled(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SModeAdminlessEnabled(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn AllowDeviceOwnerProtectionDowngrade(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_AllowDeviceOwnerProtectionDowngrade(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(2usize, 30u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(2usize, 30u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        SModeAdminlessEnabled: u32,
        AllowDeviceOwnerProtectionDowngrade: u32,
        Reserved: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, SModeAdminlessEnabled as u64);
        bitfield_unit.set(1usize, 1u8, AllowDeviceOwnerProtectionDowngrade as u64);
        bitfield_unit.set(2usize, 30u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_SECURITY_MODEL_INFORMATION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SECURITY_MODEL_INFORMATION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SECURITY_MODEL_INFORMATION_1 {{ union }}")
    }
}
impl Default for SYSTEM_SECURITY_MODEL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SECURITY_MODEL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SECURITY_MODEL_INFORMATION {{ Anonymous1: {:?} }}",
            self.Anonymous1
        )
    }
}
#[repr(C)]
pub struct SYSTEM_FEATURE_CONFIGURATION_INFORMATION {
    pub ChangeStamp: u64,
    pub Configuration: *mut RTL_FEATURE_CONFIGURATION,
}
impl Default for SYSTEM_FEATURE_CONFIGURATION_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_FEATURE_CONFIGURATION_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_FEATURE_CONFIGURATION_INFORMATION {{ Configuration: {:?} }}",
            self.Configuration
        )
    }
}
#[repr(C)]
pub struct SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY {
    pub ChangeStamp: u64,
    pub Section: *mut std::ffi::c_void,
    pub Size: u64,
}
impl Default for SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY {{  }}"
        )
    }
}
#[repr(C)]
pub struct SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION {
    pub OverallChangeStamp: u64,
    pub Descriptors: [SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION_ENTRY; 3usize],
}
impl Default for SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION {{ Descriptors: {:?} }}",
            self.Descriptors
        )
    }
}
#[repr(C)]
pub struct RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET {
    pub Data: [u32; 2usize],
}
impl Default for RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET {{ Data: {:?} }}",
            self.Data
        )
    }
}
#[repr(C)]
pub struct SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS {
    pub FeatureId: u32,
    pub ReportingKind: u16,
    pub ReportingOptions: u16,
    pub ReportingTarget: RTL_FEATURE_USAGE_SUBSCRIPTION_TARGET,
}
impl Default for SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS {{ ReportingTarget: {:?} }}",
            self.ReportingTarget
        )
    }
}
#[repr(C)]
#[repr(align(1))]
pub union SECURE_SPECULATION_CONTROL_INFORMATION {
    _bitfield_align_1: [u8; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SECURE_SPECULATION_CONTROL_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SECURE_SPECULATION_CONTROL_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SECURE_SPECULATION_CONTROL_INFORMATION {{ union }}")
    }
}
impl SECURE_SPECULATION_CONTROL_INFORMATION {
    #[inline]
    pub fn KvaShadowSupported(&self) -> u32 {
        unsafe { self._bitfield_1.get(0usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_KvaShadowSupported(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(0usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn KvaShadowEnabled(&self) -> u32 {
        unsafe { self._bitfield_1.get(1usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_KvaShadowEnabled(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(1usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn KvaShadowUserGlobal(&self) -> u32 {
        unsafe { self._bitfield_1.get(2usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_KvaShadowUserGlobal(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(2usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn KvaShadowPcid(&self) -> u32 {
        unsafe { self._bitfield_1.get(3usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_KvaShadowPcid(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(3usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn MbClearEnabled(&self) -> u32 {
        unsafe { self._bitfield_1.get(4usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_MbClearEnabled(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(4usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn L1TFMitigated(&self) -> u32 {
        unsafe { self._bitfield_1.get(5usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_L1TFMitigated(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(5usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn BpbEnabled(&self) -> u32 {
        unsafe { self._bitfield_1.get(6usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_BpbEnabled(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(6usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn IbrsPresent(&self) -> u32 {
        unsafe { self._bitfield_1.get(7usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_IbrsPresent(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(7usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn EnhancedIbrs(&self) -> u32 {
        unsafe { self._bitfield_1.get(8usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_EnhancedIbrs(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(8usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn StibpPresent(&self) -> u32 {
        unsafe { self._bitfield_1.get(9usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_StibpPresent(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(9usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn SsbdSupported(&self) -> u32 {
        unsafe { self._bitfield_1.get(10usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_SsbdSupported(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(10usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn SsbdRequired(&self) -> u32 {
        unsafe { self._bitfield_1.get(11usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_SsbdRequired(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(11usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn BpbKernelToUser(&self) -> u32 {
        unsafe { self._bitfield_1.get(12usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_BpbKernelToUser(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(12usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn BpbUserToKernel(&self) -> u32 {
        unsafe { self._bitfield_1.get(13usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_BpbUserToKernel(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(13usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn ReturnSpeculate(&self) -> u32 {
        unsafe { self._bitfield_1.get(14usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_ReturnSpeculate(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(14usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn BranchConfusionSafe(&self) -> u32 {
        unsafe { self._bitfield_1.get(15usize, 1u8) as u32 }
    }
    #[inline]
    pub fn set_BranchConfusionSafe(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(15usize, 1u8, val as u64) }
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        unsafe { self._bitfield_1.get(16usize, 16u8) as u32 }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        unsafe { self._bitfield_1.set(16usize, 16u8, val as u64) }
    }
}
#[inline]
pub fn new_bitfield_1(
    KvaShadowSupported: u32,
    KvaShadowEnabled: u32,
    KvaShadowUserGlobal: u32,
    KvaShadowPcid: u32,
    MbClearEnabled: u32,
    L1TFMitigated: u32,
    BpbEnabled: u32,
    IbrsPresent: u32,
    EnhancedIbrs: u32,
    StibpPresent: u32,
    SsbdSupported: u32,
    SsbdRequired: u32,
    BpbKernelToUser: u32,
    BpbUserToKernel: u32,
    ReturnSpeculate: u32,
    BranchConfusionSafe: u32,
    Reserved: u32,
) -> BitfieldUnit<[u8; 4usize]> {
    let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
    bitfield_unit.set(0usize, 1u8, KvaShadowSupported as u64);
    bitfield_unit.set(1usize, 1u8, KvaShadowEnabled as u64);
    bitfield_unit.set(2usize, 1u8, KvaShadowUserGlobal as u64);
    bitfield_unit.set(3usize, 1u8, KvaShadowPcid as u64);
    bitfield_unit.set(4usize, 1u8, MbClearEnabled as u64);
    bitfield_unit.set(5usize, 1u8, L1TFMitigated as u64);
    bitfield_unit.set(6usize, 1u8, BpbEnabled as u64);
    bitfield_unit.set(7usize, 1u8, IbrsPresent as u64);
    bitfield_unit.set(8usize, 1u8, EnhancedIbrs as u64);
    bitfield_unit.set(9usize, 1u8, StibpPresent as u64);
    bitfield_unit.set(10usize, 1u8, SsbdSupported as u64);
    bitfield_unit.set(11usize, 1u8, SsbdRequired as u64);
    bitfield_unit.set(12usize, 1u8, BpbKernelToUser as u64);
    bitfield_unit.set(13usize, 1u8, BpbUserToKernel as u64);
    bitfield_unit.set(14usize, 1u8, ReturnSpeculate as u64);
    bitfield_unit.set(15usize, 1u8, BranchConfusionSafe as u64);
    bitfield_unit.set(16usize, 16u8, Reserved as u64);
    bitfield_unit
}
#[repr(C)]
pub struct SYSTEM_FIRMWARE_RAMDISK_INFORMATION {
    pub Version: u32,
    pub BlockSize: u32,
    pub BaseAddress: usize,
    pub Size: usize,
}
impl Default for SYSTEM_FIRMWARE_RAMDISK_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_FIRMWARE_RAMDISK_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_FIRMWARE_RAMDISK_INFORMATION {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_SHADOW_STACK_INFORMATION {
    pub Anonymous1: SYSTEM_SHADOW_STACK_INFORMATION_1,
}
#[repr(C)]
pub struct SYSTEM_SHADOW_STACK_INFORMATION_1 {
    pub Flags: UnionField<u32>,
    pub Anonymous1: UnionField<SYSTEM_SHADOW_STACK_INFORMATION_1_1>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_SHADOW_STACK_INFORMATION_1_1 {
    _bitfield_align_1: [u16; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSTEM_SHADOW_STACK_INFORMATION_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SHADOW_STACK_INFORMATION_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SHADOW_STACK_INFORMATION_1_1 {{ CetCapable : {:?}, UserCetAllowed : {:?}, ReservedForUserCet : {:?}, KernelCetEnabled : {:?}, KernelCetAuditModeEnabled : {:?}, ReservedForKernelCet : {:?}, Reserved : {:?} }}",
            self.CetCapable(),
            self.UserCetAllowed(),
            self.ReservedForUserCet(),
            self.KernelCetEnabled(),
            self.KernelCetAuditModeEnabled(),
            self.ReservedForKernelCet(),
            self.Reserved()
        )
    }
}
impl SYSTEM_SHADOW_STACK_INFORMATION_1_1 {
    #[inline]
    pub fn CetCapable(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_CetCapable(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn UserCetAllowed(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_UserCetAllowed(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn ReservedForUserCet(&self) -> u32 {
        self._bitfield_1.get(2usize, 6u8) as u32
    }
    #[inline]
    pub fn set_ReservedForUserCet(&mut self, val: u32) {
        self._bitfield_1.set(2usize, 6u8, val as u64)
    }
    #[inline]
    pub fn KernelCetEnabled(&self) -> u32 {
        self._bitfield_1.get(8usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KernelCetEnabled(&mut self, val: u32) {
        self._bitfield_1.set(8usize, 1u8, val as u64)
    }
    #[inline]
    pub fn KernelCetAuditModeEnabled(&self) -> u32 {
        self._bitfield_1.get(9usize, 1u8) as u32
    }
    #[inline]
    pub fn set_KernelCetAuditModeEnabled(&mut self, val: u32) {
        self._bitfield_1.set(9usize, 1u8, val as u64)
    }
    #[inline]
    pub fn ReservedForKernelCet(&self) -> u32 {
        self._bitfield_1.get(10usize, 6u8) as u32
    }
    #[inline]
    pub fn set_ReservedForKernelCet(&mut self, val: u32) {
        self._bitfield_1.set(10usize, 6u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(16usize, 16u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(16usize, 16u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        CetCapable: u32,
        UserCetAllowed: u32,
        ReservedForUserCet: u32,
        KernelCetEnabled: u32,
        KernelCetAuditModeEnabled: u32,
        ReservedForKernelCet: u32,
        Reserved: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, CetCapable as u64);
        bitfield_unit.set(1usize, 1u8, UserCetAllowed as u64);
        bitfield_unit.set(2usize, 6u8, ReservedForUserCet as u64);
        bitfield_unit.set(8usize, 1u8, KernelCetEnabled as u64);
        bitfield_unit.set(9usize, 1u8, KernelCetAuditModeEnabled as u64);
        bitfield_unit.set(10usize, 6u8, ReservedForKernelCet as u64);
        bitfield_unit.set(16usize, 16u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_SHADOW_STACK_INFORMATION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SHADOW_STACK_INFORMATION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_SHADOW_STACK_INFORMATION_1 {{ union }}")
    }
}
impl Default for SYSTEM_SHADOW_STACK_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_SHADOW_STACK_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_SHADOW_STACK_INFORMATION {{ Anonymous1: {:?} }}",
            self.Anonymous1
        )
    }
}
#[repr(C)]
pub struct SYSTEM_BUILD_VERSION_INFORMATION_FLAGS {
    pub Value32: UnionField<u32>,
    pub Anonymous1: UnionField<SYSTEM_BUILD_VERSION_INFORMATION_FLAGS_1>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSTEM_BUILD_VERSION_INFORMATION_FLAGS_1 {
    _bitfield_align_1: [u8; 0],
    _bitfield_1: BitfieldUnit<[u8; 1usize]>,
    pub padding_0: [u8; 3usize],
}
impl Default for SYSTEM_BUILD_VERSION_INFORMATION_FLAGS_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BUILD_VERSION_INFORMATION_FLAGS_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_BUILD_VERSION_INFORMATION_FLAGS_1 {{ IsTopLevel : {:?}, IsChecked : {:?} }}",
            self.IsTopLevel(),
            self.IsChecked()
        )
    }
}
impl SYSTEM_BUILD_VERSION_INFORMATION_FLAGS_1 {
    #[inline]
    pub fn IsTopLevel(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_IsTopLevel(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn IsChecked(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_IsChecked(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(IsTopLevel: u32, IsChecked: u32) -> BitfieldUnit<[u8; 1usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 1usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, IsTopLevel as u64);
        bitfield_unit.set(1usize, 1u8, IsChecked as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_BUILD_VERSION_INFORMATION_FLAGS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BUILD_VERSION_INFORMATION_FLAGS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_BUILD_VERSION_INFORMATION_FLAGS {{ union }}")
    }
}
#[repr(C)]
pub struct SYSTEM_BUILD_VERSION_INFORMATION {
    pub LayerNumber: u16,
    pub LayerCount: u16,
    pub OsMajorVersion: u32,
    pub OsMinorVersion: u32,
    pub NtBuildNumber: u32,
    pub NtBuildQfe: u32,
    pub LayerName: [u8; 128usize],
    pub NtBuildBranch: [u8; 128usize],
    pub NtBuildLab: [u8; 128usize],
    pub NtBuildLabEx: [u8; 128usize],
    pub NtBuildStamp: [u8; 26usize],
    pub NtBuildArch: [u8; 16usize],
    pub Flags: SYSTEM_BUILD_VERSION_INFORMATION_FLAGS,
}
impl Default for SYSTEM_BUILD_VERSION_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_BUILD_VERSION_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_BUILD_VERSION_INFORMATION {{ LayerName: {:?}, NtBuildBranch: {:?}, NtBuildLab: {:?}, NtBuildLabEx: {:?}, NtBuildStamp: {:?}, NtBuildArch: {:?}, Flags: {:?} }}",
            self.LayerName,
            self.NtBuildBranch,
            self.NtBuildLab,
            self.NtBuildLabEx,
            self.NtBuildStamp,
            self.NtBuildArch,
            self.Flags
        )
    }
}
#[repr(C)]
pub struct SYSTEM_POOL_LIMIT_MEM_INFO {
    pub MemoryLimit: u64,
    pub NotificationLimit: u64,
}
impl Default for SYSTEM_POOL_LIMIT_MEM_INFO {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POOL_LIMIT_MEM_INFO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_POOL_LIMIT_MEM_INFO {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_POOL_LIMIT_INFO {
    pub PoolTag: u32,
    pub MemLimits: [SYSTEM_POOL_LIMIT_MEM_INFO; 2usize],
    pub NotificationHandle: WNF_STATE_NAME,
}
impl Default for SYSTEM_POOL_LIMIT_INFO {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POOL_LIMIT_INFO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_POOL_LIMIT_INFO {{ MemLimits: {:?}, NotificationHandle: {:?} }}",
            self.MemLimits, self.NotificationHandle
        )
    }
}
#[repr(C)]
pub struct SYSTEM_POOL_LIMIT_INFORMATION {
    pub Version: u32,
    pub EntryCount: u32,
    pub LimitEntries: [SYSTEM_POOL_LIMIT_INFO; 1usize],
}
impl Default for SYSTEM_POOL_LIMIT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POOL_LIMIT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_POOL_LIMIT_INFORMATION {{ LimitEntries: {:?} }}",
            self.LimitEntries
        )
    }
}
#[repr(C)]
pub struct HV_MINROOT_NUMA_LPS {
    pub NodeIndex: u32,
    pub Mask: [usize; 16usize],
}
impl Default for HV_MINROOT_NUMA_LPS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for HV_MINROOT_NUMA_LPS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "HV_MINROOT_NUMA_LPS {{ Mask: {:?} }}", self.Mask)
    }
}
#[repr(C)]
pub struct SYSTEM_XFG_FAILURE_INFORMATION {
    pub ReturnAddress: *mut std::ffi::c_void,
    pub TargetAddress: *mut std::ffi::c_void,
    pub DispatchMode: u32,
    pub XfgValue: u64,
}
impl Default for SYSTEM_XFG_FAILURE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_XFG_FAILURE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_XFG_FAILURE_INFORMATION {{  }}")
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSTEM_IOMMU_STATE {
    IommuStateBlock = 0,
    IommuStateUnblock = 1,
}
#[repr(C)]
pub struct SYSTEM_IOMMU_STATE_INFORMATION {
    pub State: SYSTEM_IOMMU_STATE,
    pub Pdo: *mut std::ffi::c_void,
}
impl Default for SYSTEM_IOMMU_STATE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_IOMMU_STATE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_IOMMU_STATE_INFORMATION {{ State: {:?} }}",
            self.State
        )
    }
}
#[repr(C)]
pub struct SYSTEM_HYPERVISOR_MINROOT_INFORMATION {
    pub NumProc: u32,
    pub RootProc: u32,
    pub RootProcNumaNodesSpecified: u32,
    pub RootProcNumaNodes: [u16; 64usize],
    pub RootProcPerCore: u32,
    pub RootProcPerNode: u32,
    pub RootProcNumaNodesLpsSpecified: u32,
    pub RootProcNumaNodeLps: [HV_MINROOT_NUMA_LPS; 64usize],
}
impl Default for SYSTEM_HYPERVISOR_MINROOT_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HYPERVISOR_MINROOT_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_HYPERVISOR_MINROOT_INFORMATION {{ RootProcNumaNodes: {:?}, RootProcNumaNodeLps: {:?} }}",
            self.RootProcNumaNodes, self.RootProcNumaNodeLps
        )
    }
}
#[repr(C)]
pub struct SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION {
    pub RangeCount: u32,
    pub RangeArray: [usize; 1usize],
}
impl Default for SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION {{ RangeArray: {:?} }}",
            self.RangeArray
        )
    }
}
#[repr(C)]
pub struct SYSTEM_POINTER_AUTH_INFORMATION {
    pub Anonymous1: SYSTEM_POINTER_AUTH_INFORMATION_1,
    pub Anonymous2: SYSTEM_POINTER_AUTH_INFORMATION_2,
}
#[repr(C)]
pub struct SYSTEM_POINTER_AUTH_INFORMATION_1 {
    pub SupportedFlags: UnionField<u16>,
    pub Anonymous1: UnionField<SYSTEM_POINTER_AUTH_INFORMATION_1_1>,
    pub union_field: u16,
}
#[repr(C)]
#[repr(align(2))]
pub struct SYSTEM_POINTER_AUTH_INFORMATION_1_1 {
    _bitfield_align_1: [u16; 0],
    _bitfield_1: BitfieldUnit<[u8; 2usize]>,
}
impl Default for SYSTEM_POINTER_AUTH_INFORMATION_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POINTER_AUTH_INFORMATION_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_POINTER_AUTH_INFORMATION_1_1 {{ AddressAuthSupported : {:?}, AddressAuthQarma : {:?}, GenericAuthSupported : {:?}, GenericAuthQarma : {:?}, SupportedReserved : {:?} }}",
            self.AddressAuthSupported(),
            self.AddressAuthQarma(),
            self.GenericAuthSupported(),
            self.GenericAuthQarma(),
            self.SupportedReserved()
        )
    }
}
impl SYSTEM_POINTER_AUTH_INFORMATION_1_1 {
    #[inline]
    pub fn AddressAuthSupported(&self) -> u16 {
        self._bitfield_1.get(0usize, 1u8) as u16
    }
    #[inline]
    pub fn set_AddressAuthSupported(&mut self, val: u16) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn AddressAuthQarma(&self) -> u16 {
        self._bitfield_1.get(1usize, 1u8) as u16
    }
    #[inline]
    pub fn set_AddressAuthQarma(&mut self, val: u16) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn GenericAuthSupported(&self) -> u16 {
        self._bitfield_1.get(2usize, 1u8) as u16
    }
    #[inline]
    pub fn set_GenericAuthSupported(&mut self, val: u16) {
        self._bitfield_1.set(2usize, 1u8, val as u64)
    }
    #[inline]
    pub fn GenericAuthQarma(&self) -> u16 {
        self._bitfield_1.get(3usize, 1u8) as u16
    }
    #[inline]
    pub fn set_GenericAuthQarma(&mut self, val: u16) {
        self._bitfield_1.set(3usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SupportedReserved(&self) -> u16 {
        self._bitfield_1.get(4usize, 12u8) as u16
    }
    #[inline]
    pub fn set_SupportedReserved(&mut self, val: u16) {
        self._bitfield_1.set(4usize, 12u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        AddressAuthSupported: u16,
        AddressAuthQarma: u16,
        GenericAuthSupported: u16,
        GenericAuthQarma: u16,
        SupportedReserved: u16,
    ) -> BitfieldUnit<[u8; 2usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 2usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, AddressAuthSupported as u64);
        bitfield_unit.set(1usize, 1u8, AddressAuthQarma as u64);
        bitfield_unit.set(2usize, 1u8, GenericAuthSupported as u64);
        bitfield_unit.set(3usize, 1u8, GenericAuthQarma as u64);
        bitfield_unit.set(4usize, 12u8, SupportedReserved as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_POINTER_AUTH_INFORMATION_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POINTER_AUTH_INFORMATION_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_POINTER_AUTH_INFORMATION_1 {{ union }}")
    }
}
#[repr(C)]
pub struct SYSTEM_POINTER_AUTH_INFORMATION_2 {
    pub EnabledFlags: UnionField<u16>,
    pub Anonymous1: UnionField<SYSTEM_POINTER_AUTH_INFORMATION_2_1>,
    pub union_field: u16,
}
#[repr(C)]
#[repr(align(2))]
pub struct SYSTEM_POINTER_AUTH_INFORMATION_2_1 {
    _bitfield_align_1: [u8; 0],
    _bitfield_1: BitfieldUnit<[u8; 2usize]>,
}
impl Default for SYSTEM_POINTER_AUTH_INFORMATION_2_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POINTER_AUTH_INFORMATION_2_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_POINTER_AUTH_INFORMATION_2_1 {{ UserPerProcessIpAuthEnabled : {:?}, UserGlobalIpAuthEnabled : {:?}, UserEnabledReserved : {:?}, KernelIpAuthEnabled : {:?}, KernelEnabledReserved : {:?} }}",
            self.UserPerProcessIpAuthEnabled(),
            self.UserGlobalIpAuthEnabled(),
            self.UserEnabledReserved(),
            self.KernelIpAuthEnabled(),
            self.KernelEnabledReserved()
        )
    }
}
impl SYSTEM_POINTER_AUTH_INFORMATION_2_1 {
    #[inline]
    pub fn UserPerProcessIpAuthEnabled(&self) -> u16 {
        self._bitfield_1.get(0usize, 1u8) as u16
    }
    #[inline]
    pub fn set_UserPerProcessIpAuthEnabled(&mut self, val: u16) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn UserGlobalIpAuthEnabled(&self) -> u16 {
        self._bitfield_1.get(1usize, 1u8) as u16
    }
    #[inline]
    pub fn set_UserGlobalIpAuthEnabled(&mut self, val: u16) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn UserEnabledReserved(&self) -> u16 {
        self._bitfield_1.get(2usize, 6u8) as u16
    }
    #[inline]
    pub fn set_UserEnabledReserved(&mut self, val: u16) {
        self._bitfield_1.set(2usize, 6u8, val as u64)
    }
    #[inline]
    pub fn KernelIpAuthEnabled(&self) -> u16 {
        self._bitfield_1.get(8usize, 1u8) as u16
    }
    #[inline]
    pub fn set_KernelIpAuthEnabled(&mut self, val: u16) {
        self._bitfield_1.set(8usize, 1u8, val as u64)
    }
    #[inline]
    pub fn KernelEnabledReserved(&self) -> u16 {
        self._bitfield_1.get(9usize, 7u8) as u16
    }
    #[inline]
    pub fn set_KernelEnabledReserved(&mut self, val: u16) {
        self._bitfield_1.set(9usize, 7u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        UserPerProcessIpAuthEnabled: u16,
        UserGlobalIpAuthEnabled: u16,
        UserEnabledReserved: u16,
        KernelIpAuthEnabled: u16,
        KernelEnabledReserved: u16,
    ) -> BitfieldUnit<[u8; 2usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 2usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, UserPerProcessIpAuthEnabled as u64);
        bitfield_unit.set(1usize, 1u8, UserGlobalIpAuthEnabled as u64);
        bitfield_unit.set(2usize, 6u8, UserEnabledReserved as u64);
        bitfield_unit.set(8usize, 1u8, KernelIpAuthEnabled as u64);
        bitfield_unit.set(9usize, 7u8, KernelEnabledReserved as u64);
        bitfield_unit
    }
}
impl Default for SYSTEM_POINTER_AUTH_INFORMATION_2 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POINTER_AUTH_INFORMATION_2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_POINTER_AUTH_INFORMATION_2 {{ union }}")
    }
}
impl Default for SYSTEM_POINTER_AUTH_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_POINTER_AUTH_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSTEM_POINTER_AUTH_INFORMATION {{ Anonymous1: {:?}, Anonymous2: {:?} }}",
            self.Anonymous1, self.Anonymous2
        )
    }
}
#[repr(C)]
pub struct SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT {
    pub Version: u32,
    pub FeatureName: PWSTR,
    pub BornOnVersion: u32,
}
impl Default for SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT {{  }}")
    }
}
#[repr(C)]
pub struct SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT {
    pub Version: u32,
    pub FeatureIsEnabled: BOOLEAN,
}
impl Default for SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT {{  }}")
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQuerySystemInformation(
        SystemInformationClass: SYSTEM_INFORMATION_CLASS,
        SystemInformation: *mut std::ffi::c_void,
        SystemInformationLength: u32,
        ReturnLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQuerySystemInformationEx(
        SystemInformationClass: SYSTEM_INFORMATION_CLASS,
        InputBuffer: *mut std::ffi::c_void,
        InputBufferLength: u32,
        SystemInformation: *mut std::ffi::c_void,
        SystemInformationLength: u32,
        ReturnLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetSystemInformation(
        SystemInformationClass: SYSTEM_INFORMATION_CLASS,
        SystemInformation: *mut std::ffi::c_void,
        SystemInformationLength: u32,
    ) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SYSDBG_COMMAND {
    SysDbgQueryModuleInformation = 0,
    SysDbgQueryTraceInformation = 1,
    SysDbgSetTracepoint = 2,
    SysDbgSetSpecialCall = 3,
    SysDbgClearSpecialCalls = 4,
    SysDbgQuerySpecialCalls = 5,
    SysDbgBreakPoint = 6,
    SysDbgQueryVersion = 7,
    SysDbgReadVirtual = 8,
    SysDbgWriteVirtual = 9,
    SysDbgReadPhysical = 10,
    SysDbgWritePhysical = 11,
    SysDbgReadControlSpace = 12,
    SysDbgWriteControlSpace = 13,
    SysDbgReadIoSpace = 14,
    SysDbgWriteIoSpace = 15,
    SysDbgReadMsr = 16,
    SysDbgWriteMsr = 17,
    SysDbgReadBusData = 18,
    SysDbgWriteBusData = 19,
    SysDbgCheckLowMemory = 20,
    SysDbgEnableKernelDebugger = 21,
    SysDbgDisableKernelDebugger = 22,
    SysDbgGetAutoKdEnable = 23,
    SysDbgSetAutoKdEnable = 24,
    SysDbgGetPrintBufferSize = 25,
    SysDbgSetPrintBufferSize = 26,
    SysDbgGetKdUmExceptionEnable = 27,
    SysDbgSetKdUmExceptionEnable = 28,
    SysDbgGetTriageDump = 29,
    SysDbgGetKdBlockEnable = 30,
    SysDbgSetKdBlockEnable = 31,
    SysDbgRegisterForUmBreakInfo = 32,
    SysDbgGetUmBreakPid = 33,
    SysDbgClearUmBreakPid = 34,
    SysDbgGetUmAttachPid = 35,
    SysDbgClearUmAttachPid = 36,
    SysDbgGetLiveKernelDump = 37,
    SysDbgKdPullRemoteFile = 38,
    SysDbgMaxInfoClass = 39,
}
#[repr(C)]
pub struct SYSDBG_VIRTUAL {
    pub Address: *mut std::ffi::c_void,
    pub Buffer: *mut std::ffi::c_void,
    pub Request: u32,
}
impl Default for SYSDBG_VIRTUAL {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_VIRTUAL {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_VIRTUAL {{  }}")
    }
}
#[repr(C)]
pub struct SYSDBG_PHYSICAL {
    pub Address: i64,
    pub Buffer: *mut std::ffi::c_void,
    pub Request: u32,
}
impl Default for SYSDBG_PHYSICAL {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_PHYSICAL {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_PHYSICAL {{  }}")
    }
}
#[repr(C)]
pub struct SYSDBG_CONTROL_SPACE {
    pub Address: u64,
    pub Buffer: *mut std::ffi::c_void,
    pub Request: u32,
    pub Processor: u32,
}
impl Default for SYSDBG_CONTROL_SPACE {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_CONTROL_SPACE {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_CONTROL_SPACE {{  }}")
    }
}
#[repr(C)]
pub struct SYSDBG_IO_SPACE {
    pub Address: u64,
    pub Buffer: *mut std::ffi::c_void,
    pub Request: u32,
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: u32,
    pub AddressSpace: u32,
}
impl Default for SYSDBG_IO_SPACE {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_IO_SPACE {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_IO_SPACE {{  }}")
    }
}
#[repr(C)]
pub struct SYSDBG_MSR {
    pub Msr: u32,
    pub Data: u64,
}
impl Default for SYSDBG_MSR {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_MSR {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_MSR {{  }}")
    }
}
#[repr(C)]
pub struct SYSDBG_BUS_DATA {
    pub Address: u32,
    pub Buffer: *mut std::ffi::c_void,
    pub Request: u32,
    pub BusDataType: BUS_DATA_TYPE,
    pub BusNumber: u32,
    pub SlotNumber: u32,
}
impl Default for SYSDBG_BUS_DATA {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_BUS_DATA {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_BUS_DATA {{  }}")
    }
}
#[repr(C)]
pub struct SYSDBG_TRIAGE_DUMP {
    pub Flags: u32,
    pub BugCheckCode: u32,
    pub BugCheckParam1: usize,
    pub BugCheckParam2: usize,
    pub BugCheckParam3: usize,
    pub BugCheckParam4: usize,
    pub ProcessHandles: u32,
    pub ThreadHandles: u32,
    pub Handles: *mut HANDLE,
}
impl Default for SYSDBG_TRIAGE_DUMP {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_TRIAGE_DUMP {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_TRIAGE_DUMP {{  }}")
    }
}
#[repr(C)]
pub struct SYSDBG_LIVEDUMP_CONTROL_FLAGS {
    pub Anonymous1: UnionField<SYSDBG_LIVEDUMP_CONTROL_FLAGS_1>,
    pub AsUlong: UnionField<u32>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSDBG_LIVEDUMP_CONTROL_FLAGS_1 {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSDBG_LIVEDUMP_CONTROL_FLAGS_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_LIVEDUMP_CONTROL_FLAGS_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSDBG_LIVEDUMP_CONTROL_FLAGS_1 {{ UseDumpStorageStack : {:?}, CompressMemoryPagesData : {:?}, IncludeUserSpaceMemoryPages : {:?}, AbortIfMemoryPressure : {:?}, SelectiveDump : {:?}, Reserved : {:?} }}",
            self.UseDumpStorageStack(),
            self.CompressMemoryPagesData(),
            self.IncludeUserSpaceMemoryPages(),
            self.AbortIfMemoryPressure(),
            self.SelectiveDump(),
            self.Reserved()
        )
    }
}
impl SYSDBG_LIVEDUMP_CONTROL_FLAGS_1 {
    #[inline]
    pub fn UseDumpStorageStack(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_UseDumpStorageStack(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn CompressMemoryPagesData(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_CompressMemoryPagesData(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn IncludeUserSpaceMemoryPages(&self) -> u32 {
        self._bitfield_1.get(2usize, 1u8) as u32
    }
    #[inline]
    pub fn set_IncludeUserSpaceMemoryPages(&mut self, val: u32) {
        self._bitfield_1.set(2usize, 1u8, val as u64)
    }
    #[inline]
    pub fn AbortIfMemoryPressure(&self) -> u32 {
        self._bitfield_1.get(3usize, 1u8) as u32
    }
    #[inline]
    pub fn set_AbortIfMemoryPressure(&mut self, val: u32) {
        self._bitfield_1.set(3usize, 1u8, val as u64)
    }
    #[inline]
    pub fn SelectiveDump(&self) -> u32 {
        self._bitfield_1.get(4usize, 1u8) as u32
    }
    #[inline]
    pub fn set_SelectiveDump(&mut self, val: u32) {
        self._bitfield_1.set(4usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(5usize, 27u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(5usize, 27u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        UseDumpStorageStack: u32,
        CompressMemoryPagesData: u32,
        IncludeUserSpaceMemoryPages: u32,
        AbortIfMemoryPressure: u32,
        SelectiveDump: u32,
        Reserved: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, UseDumpStorageStack as u64);
        bitfield_unit.set(1usize, 1u8, CompressMemoryPagesData as u64);
        bitfield_unit.set(2usize, 1u8, IncludeUserSpaceMemoryPages as u64);
        bitfield_unit.set(3usize, 1u8, AbortIfMemoryPressure as u64);
        bitfield_unit.set(4usize, 1u8, SelectiveDump as u64);
        bitfield_unit.set(5usize, 27u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for SYSDBG_LIVEDUMP_CONTROL_FLAGS {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_LIVEDUMP_CONTROL_FLAGS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_LIVEDUMP_CONTROL_FLAGS {{ union }}")
    }
}
#[repr(C)]
pub struct SYSDBG_LIVEDUMP_CONTROL_ADDPAGES {
    pub Anonymous1: UnionField<SYSDBG_LIVEDUMP_CONTROL_ADDPAGES_1>,
    pub AsUlong: UnionField<u32>,
    pub union_field: u32,
}
#[repr(C)]
#[repr(align(4))]
pub struct SYSDBG_LIVEDUMP_CONTROL_ADDPAGES_1 {
    _bitfield_align_1: [u32; 0],
    _bitfield_1: BitfieldUnit<[u8; 4usize]>,
}
impl Default for SYSDBG_LIVEDUMP_CONTROL_ADDPAGES_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_LIVEDUMP_CONTROL_ADDPAGES_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSDBG_LIVEDUMP_CONTROL_ADDPAGES_1 {{ HypervisorPages : {:?}, NonEssentialHypervisorPages : {:?}, Reserved : {:?} }}",
            self.HypervisorPages(),
            self.NonEssentialHypervisorPages(),
            self.Reserved()
        )
    }
}
impl SYSDBG_LIVEDUMP_CONTROL_ADDPAGES_1 {
    #[inline]
    pub fn HypervisorPages(&self) -> u32 {
        self._bitfield_1.get(0usize, 1u8) as u32
    }
    #[inline]
    pub fn set_HypervisorPages(&mut self, val: u32) {
        self._bitfield_1.set(0usize, 1u8, val as u64)
    }
    #[inline]
    pub fn NonEssentialHypervisorPages(&self) -> u32 {
        self._bitfield_1.get(1usize, 1u8) as u32
    }
    #[inline]
    pub fn set_NonEssentialHypervisorPages(&mut self, val: u32) {
        self._bitfield_1.set(1usize, 1u8, val as u64)
    }
    #[inline]
    pub fn Reserved(&self) -> u32 {
        self._bitfield_1.get(2usize, 30u8) as u32
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: u32) {
        self._bitfield_1.set(2usize, 30u8, val as u64)
    }
    #[inline]
    pub fn new_bitfield_1(
        HypervisorPages: u32,
        NonEssentialHypervisorPages: u32,
        Reserved: u32,
    ) -> BitfieldUnit<[u8; 4usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 4usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, HypervisorPages as u64);
        bitfield_unit.set(1usize, 1u8, NonEssentialHypervisorPages as u64);
        bitfield_unit.set(2usize, 30u8, Reserved as u64);
        bitfield_unit
    }
}
impl Default for SYSDBG_LIVEDUMP_CONTROL_ADDPAGES {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_LIVEDUMP_CONTROL_ADDPAGES {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_LIVEDUMP_CONTROL_ADDPAGES {{ union }}")
    }
}
#[repr(C)]
pub struct SYSDBG_LIVEDUMP_SELECTIVE_CONTROL {
    pub Version: u32,
    pub Size: u32,
    pub Anonymous1: SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1,
    pub Reserved: [u64; 4usize],
}
#[repr(C)]
pub struct SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1 {
    pub Flags: UnionField<u64>,
    pub Anonymous1: UnionField<SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1_1>,
    pub union_field: u64,
}
#[repr(C)]
#[repr(align(8))]
pub struct SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1_1 {
    _bitfield_align_1: [u64; 0],
    _bitfield_1: BitfieldUnit<[u8; 8usize]>,
}
impl Default for SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1_1 {{ ThreadKernelStacks : {:?}, ReservedFlags : {:?} }}",
            self.ThreadKernelStacks(),
            self.ReservedFlags()
        )
    }
}
impl SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1_1 {
    #[inline]
    pub fn ThreadKernelStacks(&self) -> u64 {
        self._bitfield_1.get(0usize, 1u8)
    }
    #[inline]
    pub fn set_ThreadKernelStacks(&mut self, val: u64) {
        self._bitfield_1.set(0usize, 1u8, val)
    }
    #[inline]
    pub fn ReservedFlags(&self) -> u64 {
        self._bitfield_1.get(1usize, 63u8)
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: u64) {
        self._bitfield_1.set(1usize, 63u8, val)
    }
    #[inline]
    pub fn new_bitfield_1(
        ThreadKernelStacks: u64,
        ReservedFlags: u64,
    ) -> BitfieldUnit<[u8; 8usize]> {
        let mut bitfield_unit: BitfieldUnit<[u8; 8usize]> = Default::default();
        bitfield_unit.set(0usize, 1u8, ThreadKernelStacks);
        bitfield_unit.set(1usize, 63u8, ReservedFlags);
        bitfield_unit
    }
}
impl Default for SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_LIVEDUMP_SELECTIVE_CONTROL_1 {{ union }}")
    }
}
impl Default for SYSDBG_LIVEDUMP_SELECTIVE_CONTROL {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_LIVEDUMP_SELECTIVE_CONTROL {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSDBG_LIVEDUMP_SELECTIVE_CONTROL {{ Anonymous1: {:?}, Reserved: {:?} }}",
            self.Anonymous1, self.Reserved
        )
    }
}
#[repr(C)]
pub struct SYSDBG_LIVEDUMP_CONTROL {
    pub Version: u32,
    pub BugCheckCode: u32,
    pub BugCheckParam1: usize,
    pub BugCheckParam2: usize,
    pub BugCheckParam3: usize,
    pub BugCheckParam4: usize,
    pub DumpFileHandle: HANDLE,
    pub CancelEventHandle: HANDLE,
    pub Flags: SYSDBG_LIVEDUMP_CONTROL_FLAGS,
    pub AddPagesControl: SYSDBG_LIVEDUMP_CONTROL_ADDPAGES,
    pub SelectiveControl: *mut SYSDBG_LIVEDUMP_SELECTIVE_CONTROL,
}
impl Default for SYSDBG_LIVEDUMP_CONTROL {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_LIVEDUMP_CONTROL {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SYSDBG_LIVEDUMP_CONTROL {{ Flags: {:?}, AddPagesControl: {:?}, SelectiveControl: {:?} }}",
            self.Flags, self.AddPagesControl, self.SelectiveControl
        )
    }
}
#[repr(C)]
pub struct SYSDBG_KD_PULL_REMOTE_FILE {
    pub ImageFileName: UNICODE_STRING,
}
impl Default for SYSDBG_KD_PULL_REMOTE_FILE {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for SYSDBG_KD_PULL_REMOTE_FILE {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SYSDBG_KD_PULL_REMOTE_FILE {{  }}")
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSystemDebugControl(
        Command: SYSDBG_COMMAND,
        InputBuffer: *mut std::ffi::c_void,
        InputBufferLength: u32,
        OutputBuffer: *mut std::ffi::c_void,
        OutputBufferLength: u32,
        ReturnLength: *mut u32,
    ) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HARDERROR_RESPONSE_OPTION {
    OptionAbortRetryIgnore = 0,
    OptionOk = 1,
    OptionOkCancel = 2,
    OptionRetryCancel = 3,
    OptionYesNo = 4,
    OptionYesNoCancel = 5,
    OptionShutdownSystem = 6,
    OptionOkNoWait = 7,
    OptionCancelTryContinue = 8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HARDERROR_RESPONSE {
    ResponseReturnToCaller = 0,
    ResponseNotHandled = 1,
    ResponseAbort = 2,
    ResponseCancel = 3,
    ResponseIgnore = 4,
    ResponseNo = 5,
    ResponseOk = 6,
    ResponseRetry = 7,
    ResponseYes = 8,
    ResponseTryAgain = 9,
    ResponseContinue = 10,
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtRaiseHardError(
        ErrorStatus: NTSTATUS,
        NumberOfParameters: u32,
        UnicodeStringParameterMask: u32,
        Parameters: *mut usize,
        ValidResponseOptions: u32,
        Response: *mut u32,
    ) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign = 0,
    NEC98x86 = 1,
    EndAlternatives = 2,
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: *mut u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetDefaultLocale(UserProfile: BOOLEAN, DefaultLocaleId: u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryInstallUILanguage(InstallUILanguageId: *mut u16) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtFlushInstallUILanguage(InstallUILanguage: u16, SetComittedFlag: u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryDefaultUILanguage(DefaultUILanguageId: *mut u16) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetDefaultUILanguage(DefaultUILanguageId: u16) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtIsUILanguageComitted() -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtInitializeNlsFiles(
        BaseAddress: *mut *mut std::ffi::c_void,
        DefaultLocaleId: *mut u32,
        DefaultCasingTableSize: *mut i64,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtReleaseCMFViewOwnership() -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtMapCMFModule(
        What: u32,
        Index: u32,
        CacheIndexOut: *mut u32,
        CacheFlagsOut: *mut u32,
        ViewSizeOut: *mut u32,
        BaseAddress: *mut *mut std::ffi::c_void,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtGetMUIRegistryInfo(
        Flags: u32,
        DataSize: *mut u32,
        Data: *mut std::ffi::c_void,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtAddAtom(AtomName: PWSTR, Length: u32, Atom: *mut u16) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtAddAtomEx(AtomName: PWSTR, Length: u32, Atom: *mut u16, Flags: u32) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtFindAtom(AtomName: PWSTR, Length: u32, Atom: *mut u16) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtDeleteAtom(Atom: u16) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ATOM_INFORMATION_CLASS {
    AtomBasicInformation = 0,
    AtomTableInformation = 1,
}
#[repr(C)]
pub struct ATOM_BASIC_INFORMATION {
    pub UsageCount: u16,
    pub Flags: u16,
    pub NameLength: u16,
    pub Name: [u16; 1usize],
}
impl Default for ATOM_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ATOM_BASIC_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ATOM_BASIC_INFORMATION {{ Name: {:?} }}", self.Name)
    }
}
#[repr(C)]
pub struct ATOM_TABLE_INFORMATION {
    pub NumberOfAtoms: u32,
    pub Atoms: [u16; 1usize],
}
impl Default for ATOM_TABLE_INFORMATION {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
impl std::fmt::Debug for ATOM_TABLE_INFORMATION {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ATOM_TABLE_INFORMATION {{ Atoms: {:?} }}", self.Atoms)
    }
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryInformationAtom(
        Atom: u16,
        AtomInformationClass: ATOM_INFORMATION_CLASS,
        AtomInformation: *mut std::ffi::c_void,
        AtomInformationLength: u32,
        ReturnLength: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtQueryLicenseValue(
        ValueName: *mut UNICODE_STRING,
        Type: *mut u32,
        Data: *mut std::ffi::c_void,
        DataSize: u32,
        ResultDataSize: *mut u32,
    ) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtSetDefaultHardErrorPort(DefaultHardErrorPort: HANDLE) -> NTSTATUS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SHUTDOWN_ACTION {
    ShutdownNoReboot = 0,
    ShutdownReboot = 1,
    ShutdownPowerOff = 2,
    ShutdownRebootForRecovery = 3,
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtShutdownSystem(Action: SHUTDOWN_ACTION) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtDisplayString(String: *mut UNICODE_STRING) -> NTSTATUS;
}
#[link(name = "ntdll.dll", kind = "raw-dylib", modifiers = "+verbatim")]
extern "system" {
    pub fn NtDrawText(Text: *mut UNICODE_STRING) -> NTSTATUS;
}
